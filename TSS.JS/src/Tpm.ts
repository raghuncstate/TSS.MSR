/* 
 * Copyright(c) Microsoft Corporation.All rights reserved. 
 * Licensed under the MIT License. 
 * See the LICENSE file in the project root for full license information. 
 */

/*
 * This file is automatically generated from the TPM 2.0 rev. 1.46 specification documents.
 * Do not edit it directly.
 */


import * as tt from "./TpmTypes.js";
import { TpmBase, TpmError } from "./TpmBase.js";
import { TpmBuffer, TpmMarshaller, TpmStructure }
            from "./TpmMarshaller.js";

export class Tpm extends TpmBase
{
    /**
     * TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
     * 
     * @param startupType TPM_SU_CLEAR or TPM_SU_STATE
     */
    Startup (startupType: tt.TPM_SU, 
             continuation: (err: TpmError, res?: tt.StartupResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Startup, null);
        let inStruct = new tt.TPM2_Startup_REQUEST(startupType);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Startup, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // Startup()
    
    /**
     * This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
     * 
     * @param shutdownType TPM_SU_CLEAR or TPM_SU_STATE
     */
    Shutdown (shutdownType: tt.TPM_SU, 
              continuation: (err: TpmError, res?: tt.ShutdownResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Shutdown, null);
        let inStruct = new tt.TPM2_Shutdown_REQUEST(shutdownType);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Shutdown, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // Shutdown()
    
    /**
     * This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
     * 
     * @param fullTest YES if full test to be performed NO if only test of untested functions required
     */
    SelfTest (fullTest: number, 
              continuation: (err: TpmError, res?: tt.SelfTestResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SelfTest, null);
        let inStruct = new tt.TPM2_SelfTest_REQUEST(fullTest);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SelfTest, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // SelfTest()
    
    /**
     * This command causes the TPM to perform a test of the selected algorithms.
     * 
     * @param toTest list of algorithms that should be tested 
     * @return list of algorithms that need testing
     */
    IncrementalSelfTest (toTest: tt.TPM_ALG_ID[], 
                         continuation: (err: TpmError, res?: tt.TPM_ALG_ID[]) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.IncrementalSelfTest, null);
        let inStruct = new tt.TPM2_IncrementalSelfTest_REQUEST(toTest);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.IncrementalSelfTest, respBuf);
        let res: tt.IncrementalSelfTestResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.IncrementalSelfTestResponse);
            setImmediate(continuation, null, res.toDoList);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // IncrementalSelfTest()
    
    /**
     * This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
     * 
     * @return TPM2_GetTestResult_RESPONSE{(ul)(li)(code)outData(/code) - test result data contains manufacturer-specific information(/li)(li)(code)testResult(/code) - -(/li)(/ul)}
     */
    GetTestResult (continuation: (err: TpmError, res?: tt.GetTestResultResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetTestResult, null);
        let inStruct = new tt.TPM2_GetTestResult_REQUEST();
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetTestResult, respBuf);
        let res: tt.GetTestResultResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.GetTestResultResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // GetTestResult()
    
    /**
     * This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
     * 
     * @param tpmKey handle of a loaded decrypt key used to encrypt salt may be TPM_RH_NULL Auth Index: None 
     * @param bind entity providing the authValue may be TPM_RH_NULL Auth Index: None 
     * @param nonceCaller initial nonceCaller, sets nonceTPM size for the session shall be at least 16 octets 
     * @param encryptedSalt value encrypted according to the type of tpmKey If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer. 
     * @param sessionType indicates the type of the session; simple HMAC or policy (including a trial policy) 
     * @param symmetric the algorithm and key size for parameter encryption may select TPM_ALG_NULL 
     * @param authHash hash algorithm to use for the session Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL 
     * @return TPM2_StartAuthSession_RESPONSE{(ul)(li)(code)handle(/code) - handle for the newly created session(/li)(li)(code)nonceTPM(/code) - the initial nonce from the TPM, used in the computation of the sessionKey(/li)(/ul)}
     */
    StartAuthSession (tpmKey: tt.TPM_HANDLE, bind: tt.TPM_HANDLE, nonceCaller: Buffer, encryptedSalt: Buffer, sessionType: tt.TPM_SE, symmetric: tt.TPMT_SYM_DEF, authHash: tt.TPM_ALG_ID, 
                      continuation: (err: TpmError, res?: tt.StartAuthSessionResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.StartAuthSession, [tpmKey, bind]);
        let inStruct = new tt.TPM2_StartAuthSession_REQUEST(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.StartAuthSession, respBuf);
        let res: tt.StartAuthSessionResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.StartAuthSessionResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // StartAuthSession()
    
    /**
     * This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
     * 
     * @param sessionHandle the handle for the policy session
     */
    PolicyRestart (sessionHandle: tt.TPM_HANDLE, 
                   continuation: (err: TpmError, res?: tt.PolicyRestartResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyRestart, [sessionHandle]);
        let inStruct = new tt.TPM2_PolicyRestart_REQUEST(sessionHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyRestart, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyRestart()
    
    /**
     * This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
     * 
     * @param parentHandle handle of parent for new object Auth Index: 1 Auth Role: USER 
     * @param inSensitive the sensitive data 
     * @param inPublic the public template 
     * @param outsideInfo data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data 
     * @param creationPCR PCR that will be used in creation data 
     * @return TPM2_Create_RESPONSE{(ul)(li)(code)outPrivate(/code) - the private portion of the object(/li)(li)(code)outPublic(/code) - the public portion of the created object(/li)(li)(code)creationData(/code) - contains a TPMS_CREATION_DATA(/li)(li)(code)creationHash(/code) - digest of creationData using nameAlg of outPublic(/li)(li)(code)creationTicket(/code) - ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM(/li)(/ul)}
     */
    Create (parentHandle: tt.TPM_HANDLE, inSensitive: tt.TPMS_SENSITIVE_CREATE, inPublic: tt.TPMT_PUBLIC, outsideInfo: Buffer, creationPCR: tt.TPMS_PCR_SELECTION[], 
            continuation: (err: TpmError, res?: tt.CreateResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Create, [parentHandle]);
        let inStruct = new tt.TPM2_Create_REQUEST(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Create, respBuf);
        let res: tt.CreateResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CreateResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Create()
    
    /**
     * This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
     * 
     * @param parentHandle TPM handle of parent key; shall not be a reserved handle Auth Index: 1 Auth Role: USER 
     * @param inPrivate the private portion of the object 
     * @param inPublic the public portion of the object 
     * @return handle of type TPM_HT_TRANSIENT for the loaded object
     */
    Load (parentHandle: tt.TPM_HANDLE, inPrivate: tt.TPM2B_PRIVATE, inPublic: tt.TPMT_PUBLIC, 
          continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Load, [parentHandle]);
        let inStruct = new tt.TPM2_Load_REQUEST(parentHandle,inPrivate,inPublic);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Load, respBuf);
        let res: tt.LoadResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.LoadResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // Load()
    
    /**
     * This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
     * 
     * @param inPrivate the sensitive portion of the object (optional) 
     * @param inPublic the public portion of the object 
     * @param hierarchy hierarchy with which the object area is associated 
     * @return handle of type TPM_HT_TRANSIENT for the loaded object
     */
    LoadExternal (inPrivate: tt.TPMT_SENSITIVE, inPublic: tt.TPMT_PUBLIC, hierarchy: tt.TPM_HANDLE, 
                  continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.LoadExternal, null);
        let inStruct = new tt.TPM2_LoadExternal_REQUEST(inPrivate,inPublic,hierarchy);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.LoadExternal, respBuf);
        let res: tt.LoadExternalResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.LoadExternalResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // LoadExternal()
    
    /**
     * This command allows access to the public area of a loaded object.
     * 
     * @param objectHandle TPM handle of an object Auth Index: None 
     * @return TPM2_ReadPublic_RESPONSE{(ul)(li)(code)outPublic(/code) - structure containing the public area of an object(/li)(li)(code)name(/code) - name of the object(/li)(li)(code)qualifiedName(/code) - the Qualified Name of the object(/li)(/ul)}
     */
    ReadPublic (objectHandle: tt.TPM_HANDLE, 
                continuation: (err: TpmError, res?: tt.ReadPublicResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ReadPublic, [objectHandle]);
        let inStruct = new tt.TPM2_ReadPublic_REQUEST(objectHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ReadPublic, respBuf);
        let res: tt.ReadPublicResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.ReadPublicResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // ReadPublic()
    
    /**
     * This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
     * 
     * @param activateHandle handle of the object associated with certificate in credentialBlob Auth Index: 1 Auth Role: ADMIN 
     * @param keyHandle loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob Auth Index: 2 Auth Role: USER 
     * @param credentialBlob the credential 
     * @param secret keyHandle algorithm-dependent encrypted seed that protects credentialBlob 
     * @return the decrypted certificate information the data should be no larger than the size of the digest of the nameAlg associated with keyHandle
     */
    ActivateCredential (activateHandle: tt.TPM_HANDLE, keyHandle: tt.TPM_HANDLE, credentialBlob: tt.TPMS_ID_OBJECT, secret: Buffer, 
                        continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ActivateCredential, [activateHandle, keyHandle]);
        let inStruct = new tt.TPM2_ActivateCredential_REQUEST(activateHandle,keyHandle,credentialBlob,secret);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ActivateCredential, respBuf);
        let res: tt.ActivateCredentialResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ActivateCredentialResponse);
            setImmediate(continuation, null, res.certInfo);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ActivateCredential()
    
    /**
     * This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
     * 
     * @param handle loaded public area, used to encrypt the sensitive area containing the credential key Auth Index: None 
     * @param credential the credential information 
     * @param objectName Name of the object to which the credential applies 
     * @return TPM2_MakeCredential_RESPONSE{(ul)(li)(code)credentialBlob(/code) - the credential(/li)(li)(code)secret(/code) - handle algorithm-dependent data that wraps the key that encrypts credentialBlob(/li)(/ul)}
     */
    MakeCredential (handle: tt.TPM_HANDLE, credential: Buffer, objectName: Buffer, 
                    continuation: (err: TpmError, res?: tt.MakeCredentialResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.MakeCredential, [handle]);
        let inStruct = new tt.TPM2_MakeCredential_REQUEST(handle,credential,objectName);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.MakeCredential, respBuf);
        let res: tt.MakeCredentialResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.MakeCredentialResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // MakeCredential()
    
    /**
     * This command returns the data in a loaded Sealed Data Object.
     * 
     * @param itemHandle handle of a loaded data object Auth Index: 1 Auth Role: USER 
     * @return unsealed data Size of outData is limited to be no more than 128 octets.
     */
    Unseal (itemHandle: tt.TPM_HANDLE, 
            continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Unseal, [itemHandle]);
        let inStruct = new tt.TPM2_Unseal_REQUEST(itemHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Unseal, respBuf);
        let res: tt.UnsealResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.UnsealResponse);
            setImmediate(continuation, null, res.outData);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // Unseal()
    
    /**
     * This command is used to change the authorization secret for a TPM-resident object.
     * 
     * @param objectHandle handle of the object Auth Index: 1 Auth Role: ADMIN 
     * @param parentHandle handle of the parent Auth Index: None 
     * @param newAuth new authorization value 
     * @return private area containing the new authorization value
     */
    ObjectChangeAuth (objectHandle: tt.TPM_HANDLE, parentHandle: tt.TPM_HANDLE, newAuth: Buffer, 
                      continuation: (err: TpmError, res?: tt.TPM2B_PRIVATE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ObjectChangeAuth, [objectHandle, parentHandle]);
        let inStruct = new tt.TPM2_ObjectChangeAuth_REQUEST(objectHandle,parentHandle,newAuth);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ObjectChangeAuth, respBuf);
        let res: tt.ObjectChangeAuthResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ObjectChangeAuthResponse);
            setImmediate(continuation, null, res.outPrivate);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ObjectChangeAuth()
    
    /**
     * This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
     * 
     * @param parentHandle Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER 
     * @param inSensitive the sensitive data, see TPM 2.0 Part 1 Sensitive Values 
     * @param inPublic the public template 
     * @return TPM2_CreateLoaded_RESPONSE{(ul)(li)(code)handle(/code) - handle of type TPM_HT_TRANSIENT for created object(/li)(li)(code)outPrivate(/code) - the sensitive area of the object (optional)(/li)(li)(code)outPublic(/code) - the public portion of the created object(/li)(li)(code)name(/code) - the name of the created object(/li)(/ul)}
     */
    CreateLoaded (parentHandle: tt.TPM_HANDLE, inSensitive: tt.TPMS_SENSITIVE_CREATE, inPublic: Buffer, 
                  continuation: (err: TpmError, res?: tt.CreateLoadedResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.CreateLoaded, [parentHandle]);
        let inStruct = new tt.TPM2_CreateLoaded_REQUEST(parentHandle,inSensitive,inPublic);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.CreateLoaded, respBuf);
        let res: tt.CreateLoadedResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CreateLoadedResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // CreateLoaded()
    
    /**
     * This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
     * 
     * @param objectHandle loaded object to duplicate Auth Index: 1 Auth Role: DUP 
     * @param newParentHandle shall reference the public area of an asymmetric key Auth Index: None 
     * @param encryptionKeyIn optional symmetric encryption key The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted. 
     * @param symmetricAlg definition for the symmetric algorithm to be used for the inner wrapper may be TPM_ALG_NULL if no inner wrapper is applied 
     * @return TPM2_Duplicate_RESPONSE{(ul)(li)(code)encryptionKeyOut(/code) - If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.(/li)(li)(code)duplicate(/code) - private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted(/li)(li)(code)outSymSeed(/code) - seed protected by the asymmetric algorithms of new parent (NP)(/li)(/ul)}
     */
    Duplicate (objectHandle: tt.TPM_HANDLE, newParentHandle: tt.TPM_HANDLE, encryptionKeyIn: Buffer, symmetricAlg: tt.TPMT_SYM_DEF_OBJECT, 
               continuation: (err: TpmError, res?: tt.DuplicateResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Duplicate, [objectHandle, newParentHandle]);
        let inStruct = new tt.TPM2_Duplicate_REQUEST(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Duplicate, respBuf);
        let res: tt.DuplicateResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.DuplicateResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Duplicate()
    
    /**
     * This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
     * 
     * @param oldParent parent of object Auth Index: 1 Auth Role: User 
     * @param newParent new parent of the object Auth Index: None 
     * @param inDuplicate an object encrypted using symmetric key derived from inSymSeed 
     * @param name the Name of the object being rewrapped 
     * @param inSymSeed the seed for the symmetric key and HMAC key needs oldParent private key to recover the seed and generate the symmetric key 
     * @return TPM2_Rewrap_RESPONSE{(ul)(li)(code)outDuplicate(/code) - an object encrypted using symmetric key derived from outSymSeed(/li)(li)(code)outSymSeed(/code) - seed for a symmetric key protected by newParent asymmetric key(/li)(/ul)}
     */
    Rewrap (oldParent: tt.TPM_HANDLE, newParent: tt.TPM_HANDLE, inDuplicate: tt.TPM2B_PRIVATE, name: Buffer, inSymSeed: Buffer, 
            continuation: (err: TpmError, res?: tt.RewrapResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Rewrap, [oldParent, newParent]);
        let inStruct = new tt.TPM2_Rewrap_REQUEST(oldParent,newParent,inDuplicate,name,inSymSeed);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Rewrap, respBuf);
        let res: tt.RewrapResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.RewrapResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Rewrap()
    
    /**
     * This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
     * 
     * @param parentHandle the handle of the new parent for the object Auth Index: 1 Auth Role: USER 
     * @param encryptionKey the optional symmetric encryption key used as the inner wrapper for duplicate If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer. 
     * @param objectPublic the public area of the object to be imported This is provided so that the integrity value for duplicate and the object attributes can be checked. NOTE Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object. 
     * @param duplicate the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper 
     * @param inSymSeed the seed for the symmetric key and HMAC key inSymSeed is encrypted/encoded using the algorithms of newParent. 
     * @param symmetricAlg definition for the symmetric algorithm to use for the inner wrapper If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer. 
     * @return the sensitive area encrypted with the symmetric key of parentHandle
     */
    Import (parentHandle: tt.TPM_HANDLE, encryptionKey: Buffer, objectPublic: tt.TPMT_PUBLIC, duplicate: tt.TPM2B_PRIVATE, inSymSeed: Buffer, symmetricAlg: tt.TPMT_SYM_DEF_OBJECT, 
            continuation: (err: TpmError, res?: tt.TPM2B_PRIVATE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Import, [parentHandle]);
        let inStruct = new tt.TPM2_Import_REQUEST(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Import, respBuf);
        let res: tt.ImportResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ImportResponse);
            setImmediate(continuation, null, res.outPrivate);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // Import()
    
    /**
     * This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
     * 
     * @param keyHandle reference to public portion of RSA key to use for encryption Auth Index: None 
     * @param message message to be encrypted NOTE 1 The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle. 
     * @param inScheme the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL 
     * @param label optional label L to be associated with the message Size of the buffer is zero if no label is present NOTE 2 See description of label above. 
     * @return encrypted output
     */
    RSA_Encrypt (keyHandle: tt.TPM_HANDLE, message: Buffer, inScheme: tt.TPMU_ASYM_SCHEME, label: Buffer, 
                 continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.RSA_Encrypt, [keyHandle]);
        let inStruct = new tt.TPM2_RSA_Encrypt_REQUEST(keyHandle,message,inScheme,label);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.RSA_Encrypt, respBuf);
        let res: tt.RSA_EncryptResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.RSA_EncryptResponse);
            setImmediate(continuation, null, res.outData);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // RSA_Encrypt()
    
    /**
     * This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
     * 
     * @param keyHandle RSA key to use for decryption Auth Index: 1 Auth Role: USER 
     * @param cipherText cipher text to be decrypted NOTE An encrypted RSA data block is the size of the public modulus. 
     * @param inScheme the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL 
     * @param label label whose association with the message is to be verified 
     * @return decrypted output
     */
    RSA_Decrypt (keyHandle: tt.TPM_HANDLE, cipherText: Buffer, inScheme: tt.TPMU_ASYM_SCHEME, label: Buffer, 
                 continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.RSA_Decrypt, [keyHandle]);
        let inStruct = new tt.TPM2_RSA_Decrypt_REQUEST(keyHandle,cipherText,inScheme,label);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.RSA_Decrypt, respBuf);
        let res: tt.RSA_DecryptResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.RSA_DecryptResponse);
            setImmediate(continuation, null, res.message);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // RSA_Decrypt()
    
    /**
     * This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
     * 
     * @param keyHandle Handle of a loaded ECC key public area. Auth Index: None 
     * @return TPM2_ECDH_KeyGen_RESPONSE{(ul)(li)(code)zPoint(/code) - results of P h[de]Qs(/li)(li)(code)pubPoint(/code) - generated ephemeral public point (Qe)(/li)(/ul)}
     */
    ECDH_KeyGen (keyHandle: tt.TPM_HANDLE, 
                 continuation: (err: TpmError, res?: tt.ECDH_KeyGenResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ECDH_KeyGen, [keyHandle]);
        let inStruct = new tt.TPM2_ECDH_KeyGen_REQUEST(keyHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ECDH_KeyGen, respBuf);
        let res: tt.ECDH_KeyGenResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.ECDH_KeyGenResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // ECDH_KeyGen()
    
    /**
     * This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
     * 
     * @param keyHandle handle of a loaded ECC key Auth Index: 1 Auth Role: USER 
     * @param inPoint a public key 
     * @return X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
     */
    ECDH_ZGen (keyHandle: tt.TPM_HANDLE, inPoint: tt.TPMS_ECC_POINT, 
               continuation: (err: TpmError, res?: tt.TPMS_ECC_POINT) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ECDH_ZGen, [keyHandle]);
        let inStruct = new tt.TPM2_ECDH_ZGen_REQUEST(keyHandle,inPoint);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ECDH_ZGen, respBuf);
        let res: tt.ECDH_ZGenResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ECDH_ZGenResponse);
            setImmediate(continuation, null, res.outPoint);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ECDH_ZGen()
    
    /**
     * This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
     * 
     * @param curveID parameter set selector 
     * @return ECC parameters for the selected curve
     */
    ECC_Parameters (curveID: tt.TPM_ECC_CURVE, 
                    continuation: (err: TpmError, res?: tt.TPMS_ALGORITHM_DETAIL_ECC) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ECC_Parameters, null);
        let inStruct = new tt.TPM2_ECC_Parameters_REQUEST(curveID);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ECC_Parameters, respBuf);
        let res: tt.ECC_ParametersResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ECC_ParametersResponse);
            setImmediate(continuation, null, res.parameters);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ECC_Parameters()
    
    /**
     * This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
     * 
     * @param keyA handle of an unrestricted decryption key ECC The private key referenced by this handle is used as dS,A Auth Index: 1 Auth Role: USER 
     * @param inQsB other partys static public key (Qs,B = (Xs,B, Ys,B)) 
     * @param inQeB other party's ephemeral public key (Qe,B = (Xe,B, Ye,B)) 
     * @param inScheme the key exchange scheme 
     * @param counter value returned by TPM2_EC_Ephemeral() 
     * @return TPM2_ZGen_2Phase_RESPONSE{(ul)(li)(code)outZ1(/code) - X and Y coordinates of the computed value (scheme dependent)(/li)(li)(code)outZ2(/code) - X and Y coordinates of the second computed value (scheme dependent)(/li)(/ul)}
     */
    ZGen_2Phase (keyA: tt.TPM_HANDLE, inQsB: tt.TPMS_ECC_POINT, inQeB: tt.TPMS_ECC_POINT, inScheme: tt.TPM_ALG_ID, counter: number, 
                 continuation: (err: TpmError, res?: tt.ZGen_2PhaseResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ZGen_2Phase, [keyA]);
        let inStruct = new tt.TPM2_ZGen_2Phase_REQUEST(keyA,inQsB,inQeB,inScheme,counter);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ZGen_2Phase, respBuf);
        let res: tt.ZGen_2PhaseResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.ZGen_2PhaseResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // ZGen_2Phase()
    
    /**
     * NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
     * 
     * @param keyHandle the symmetric key used for the operation Auth Index: 1 Auth Role: USER 
     * @param decrypt if YES, then the operation is decryption; if NO, the operation is encryption 
     * @param mode symmetric encryption/decryption mode this field shall match the default mode of the key or be TPM_ALG_NULL. 
     * @param ivIn an initial value as required by the algorithm 
     * @param inData the data to be encrypted/decrypted 
     * @return TPM2_EncryptDecrypt_RESPONSE{(ul)(li)(code)outData(/code) - encrypted or decrypted output(/li)(li)(code)ivOut(/code) - chaining value to use for IV in next round(/li)(/ul)}
     */
    EncryptDecrypt (keyHandle: tt.TPM_HANDLE, decrypt: number, mode: tt.TPM_ALG_ID, ivIn: Buffer, inData: Buffer, 
                    continuation: (err: TpmError, res?: tt.EncryptDecryptResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.EncryptDecrypt, [keyHandle]);
        let inStruct = new tt.TPM2_EncryptDecrypt_REQUEST(keyHandle,decrypt,mode,ivIn,inData);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.EncryptDecrypt, respBuf);
        let res: tt.EncryptDecryptResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.EncryptDecryptResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // EncryptDecrypt()
    
    /**
     * This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
     * 
     * @param keyHandle the symmetric key used for the operation Auth Index: 1 Auth Role: USER 
     * @param inData the data to be encrypted/decrypted 
     * @param decrypt if YES, then the operation is decryption; if NO, the operation is encryption 
     * @param mode symmetric mode this field shall match the default mode of the key or be TPM_ALG_NULL. 
     * @param ivIn an initial value as required by the algorithm 
     * @return TPM2_EncryptDecrypt2_RESPONSE{(ul)(li)(code)outData(/code) - encrypted or decrypted output(/li)(li)(code)ivOut(/code) - chaining value to use for IV in next round(/li)(/ul)}
     */
    EncryptDecrypt2 (keyHandle: tt.TPM_HANDLE, inData: Buffer, decrypt: number, mode: tt.TPM_ALG_ID, ivIn: Buffer, 
                     continuation: (err: TpmError, res?: tt.EncryptDecrypt2Response) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.EncryptDecrypt2, [keyHandle]);
        let inStruct = new tt.TPM2_EncryptDecrypt2_REQUEST(keyHandle,inData,decrypt,mode,ivIn);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.EncryptDecrypt2, respBuf);
        let res: tt.EncryptDecrypt2Response = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.EncryptDecrypt2Response);
        setImmediate(continuation, this.lastError, res);  });
    } // EncryptDecrypt2()
    
    /**
     * This command performs a hash operation on a data buffer and returns the results.
     * 
     * @param data data to be hashed 
     * @param hashAlg algorithm for the hash being computed shall not be TPM_ALG_NULL 
     * @param hierarchy hierarchy to use for the ticket (TPM_RH_NULL allowed) 
     * @return TPM2_Hash_RESPONSE{(ul)(li)(code)outHash(/code) - results(/li)(li)(code)validation(/code) - ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE will be a NULL ticket if the digest may not be signed with a restricted key(/li)(/ul)}
     */
    Hash (data: Buffer, hashAlg: tt.TPM_ALG_ID, hierarchy: tt.TPM_HANDLE, 
          continuation: (err: TpmError, res?: tt.HashResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Hash, null);
        let inStruct = new tt.TPM2_Hash_REQUEST(data,hashAlg,hierarchy);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Hash, respBuf);
        let res: tt.HashResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.HashResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Hash()
    
    /**
     * This command performs an HMAC on the supplied data using the indicated hash algorithm.
     * 
     * @param handle handle for the symmetric signing key providing the HMAC key Auth Index: 1 Auth Role: USER 
     * @param buffer HMAC data 
     * @param hashAlg algorithm to use for HMAC 
     * @return the returned HMAC in a sized buffer
     */
    HMAC (handle: tt.TPM_HANDLE, buffer: Buffer, hashAlg: tt.TPM_ALG_ID, 
          continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.HMAC, [handle]);
        let inStruct = new tt.TPM2_HMAC_REQUEST(handle,buffer,hashAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.HMAC, respBuf);
        let res: tt.HMACResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.HMACResponse);
            setImmediate(continuation, null, res.outHMAC);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // HMAC()
    
    /**
     * This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
     * 
     * @param handle handle for the symmetric signing key providing the MAC key Auth Index: 1 Auth Role: USER 
     * @param buffer MAC data 
     * @param inScheme algorithm to use for MAC 
     * @return the returned MAC in a sized buffer
     */
    MAC (handle: tt.TPM_HANDLE, buffer: Buffer, inScheme: tt.TPM_ALG_ID, 
         continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.MAC, [handle]);
        let inStruct = new tt.TPM2_MAC_REQUEST(handle,buffer,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.MAC, respBuf);
        let res: tt.MACResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.MACResponse);
            setImmediate(continuation, null, res.outMAC);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // MAC()
    
    /**
     * This command returns the next bytesRequested octets from the random number generator (RNG).
     * 
     * @param bytesRequested number of octets to return 
     * @return the random octets
     */
    GetRandom (bytesRequested: number, 
               continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetRandom, null);
        let inStruct = new tt.TPM2_GetRandom_REQUEST(bytesRequested);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetRandom, respBuf);
        let res: tt.GetRandomResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.GetRandomResponse);
            setImmediate(continuation, null, res.randomBytes);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // GetRandom()
    
    /**
     * This command is used to add "additional information" to the RNG state.
     * 
     * @param inData additional information
     */
    StirRandom (inData: Buffer, 
                continuation: (err: TpmError, res?: tt.StirRandomResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.StirRandom, null);
        let inStruct = new tt.TPM2_StirRandom_REQUEST(inData);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.StirRandom, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // StirRandom()
    
    /**
     * This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
     * 
     * @param handle handle of an HMAC key Auth Index: 1 Auth Role: USER 
     * @param auth authorization value for subsequent use of the sequence 
     * @param hashAlg the hash algorithm to use for the HMAC 
     * @return a handle to reference the sequence
     */
    HMAC_Start (handle: tt.TPM_HANDLE, auth: Buffer, hashAlg: tt.TPM_ALG_ID, 
                continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.HMAC_Start, [handle]);
        let inStruct = new tt.TPM2_HMAC_Start_REQUEST(handle,auth,hashAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.HMAC_Start, respBuf);
        let res: tt.HMAC_StartResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.HMAC_StartResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // HMAC_Start()
    
    /**
     * This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
     * 
     * @param handle handle of a MAC key Auth Index: 1 Auth Role: USER 
     * @param auth authorization value for subsequent use of the sequence 
     * @param inScheme the algorithm to use for the MAC 
     * @return a handle to reference the sequence
     */
    MAC_Start (handle: tt.TPM_HANDLE, auth: Buffer, inScheme: tt.TPM_ALG_ID, 
               continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.MAC_Start, [handle]);
        let inStruct = new tt.TPM2_MAC_Start_REQUEST(handle,auth,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.MAC_Start, respBuf);
        let res: tt.MAC_StartResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.MAC_StartResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // MAC_Start()
    
    /**
     * This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
     * 
     * @param auth authorization value for subsequent use of the sequence 
     * @param hashAlg the hash algorithm to use for the hash sequence An Event Sequence starts if this is TPM_ALG_NULL. 
     * @return a handle to reference the sequence
     */
    HashSequenceStart (auth: Buffer, hashAlg: tt.TPM_ALG_ID, 
                       continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.HashSequenceStart, null);
        let inStruct = new tt.TPM2_HashSequenceStart_REQUEST(auth,hashAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.HashSequenceStart, respBuf);
        let res: tt.HashSequenceStartResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.HashSequenceStartResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // HashSequenceStart()
    
    /**
     * This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
     * 
     * @param sequenceHandle handle for the sequence object Auth Index: 1 Auth Role: USER 
     * @param buffer data to be added to hash
     */
    SequenceUpdate (sequenceHandle: tt.TPM_HANDLE, buffer: Buffer, 
                    continuation: (err: TpmError, res?: tt.SequenceUpdateResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SequenceUpdate, [sequenceHandle]);
        let inStruct = new tt.TPM2_SequenceUpdate_REQUEST(sequenceHandle,buffer);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SequenceUpdate, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // SequenceUpdate()
    
    /**
     * This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
     * 
     * @param sequenceHandle authorization for the sequence Auth Index: 1 Auth Role: USER 
     * @param buffer data to be added to the hash/HMAC 
     * @param hierarchy hierarchy of the ticket for a hash 
     * @return TPM2_SequenceComplete_RESPONSE{(ul)(li)(code)result(/code) - the returned HMAC or digest in a sized buffer(/li)(li)(code)validation(/code) - ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE This is a NULL Ticket when the sequence is HMAC.(/li)(/ul)}
     */
    SequenceComplete (sequenceHandle: tt.TPM_HANDLE, buffer: Buffer, hierarchy: tt.TPM_HANDLE, 
                      continuation: (err: TpmError, res?: tt.SequenceCompleteResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SequenceComplete, [sequenceHandle]);
        let inStruct = new tt.TPM2_SequenceComplete_REQUEST(sequenceHandle,buffer,hierarchy);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SequenceComplete, respBuf);
        let res: tt.SequenceCompleteResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.SequenceCompleteResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // SequenceComplete()
    
    /**
     * This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
     * 
     * @param pcrHandle PCR to be extended with the Event data Auth Index: 1 Auth Role: USER 
     * @param sequenceHandle authorization for the sequence Auth Index: 2 Auth Role: USER 
     * @param buffer data to be added to the Event 
     * @return list of digests computed for the PCR
     */
    EventSequenceComplete (pcrHandle: tt.TPM_HANDLE, sequenceHandle: tt.TPM_HANDLE, buffer: Buffer, 
                           continuation: (err: TpmError, res?: tt.TPMT_HA[]) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.EventSequenceComplete, [pcrHandle, sequenceHandle]);
        let inStruct = new tt.TPM2_EventSequenceComplete_REQUEST(pcrHandle,sequenceHandle,buffer);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.EventSequenceComplete, respBuf);
        let res: tt.EventSequenceCompleteResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.EventSequenceCompleteResponse);
            setImmediate(continuation, null, res.results);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // EventSequenceComplete()
    
    /**
     * The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
     * 
     * @param objectHandle handle of the object to be certified Auth Index: 1 Auth Role: ADMIN 
     * @param signHandle handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER 
     * @param qualifyingData user provided qualifying data 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @return TPM2_Certify_RESPONSE{(ul)(li)(code)certifyInfo(/code) - the structure that was signed(/li)(li)(code)signature(/code) - the asymmetric signature over certifyInfo using the key referenced by signHandle(/li)(/ul)}
     */
    Certify (objectHandle: tt.TPM_HANDLE, signHandle: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, 
             continuation: (err: TpmError, res?: tt.CertifyResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Certify, [objectHandle, signHandle]);
        let inStruct = new tt.TPM2_Certify_REQUEST(objectHandle,signHandle,qualifyingData,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Certify, respBuf);
        let res: tt.CertifyResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CertifyResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Certify()
    
    /**
     * This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
     * 
     * @param signHandle handle of the key that will sign the attestation block Auth Index: 1 Auth Role: USER 
     * @param objectHandle the object associated with the creation data Auth Index: None 
     * @param qualifyingData user-provided qualifying data 
     * @param creationHash hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary() 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @param creationTicket ticket produced by TPM2_Create() or TPM2_CreatePrimary() 
     * @return TPM2_CertifyCreation_RESPONSE{(ul)(li)(code)certifyInfo(/code) - the structure that was signed(/li)(li)(code)signature(/code) - the signature over certifyInfo(/li)(/ul)}
     */
    CertifyCreation (signHandle: tt.TPM_HANDLE, objectHandle: tt.TPM_HANDLE, qualifyingData: Buffer, creationHash: Buffer, inScheme: tt.TPMU_SIG_SCHEME, creationTicket: tt.TPMT_TK_CREATION, 
                     continuation: (err: TpmError, res?: tt.CertifyCreationResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.CertifyCreation, [signHandle, objectHandle]);
        let inStruct = new tt.TPM2_CertifyCreation_REQUEST(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.CertifyCreation, respBuf);
        let res: tt.CertifyCreationResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CertifyCreationResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // CertifyCreation()
    
    /**
     * This command is used to quote PCR values.
     * 
     * @param signHandle handle of key that will perform signature Auth Index: 1 Auth Role: USER 
     * @param qualifyingData data supplied by the caller 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @param PCRselect PCR set to quote 
     * @return TPM2_Quote_RESPONSE{(ul)(li)(code)quoted(/code) - the quoted information(/li)(li)(code)signature(/code) - the signature over quoted(/li)(/ul)}
     */
    Quote (signHandle: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, PCRselect: tt.TPMS_PCR_SELECTION[], 
           continuation: (err: TpmError, res?: tt.QuoteResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Quote, [signHandle]);
        let inStruct = new tt.TPM2_Quote_REQUEST(signHandle,qualifyingData,inScheme,PCRselect);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Quote, respBuf);
        let res: tt.QuoteResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.QuoteResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Quote()
    
    /**
     * This command returns a digital signature of the audit session digest.
     * 
     * @param privacyAdminHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
     * @param signHandle handle of the signing key Auth Index: 2 Auth Role: USER 
     * @param sessionHandle handle of the audit session Auth Index: None 
     * @param qualifyingData user-provided qualifying data may be zero-length 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @return TPM2_GetSessionAuditDigest_RESPONSE{(ul)(li)(code)auditInfo(/code) - the audit information that was signed(/li)(li)(code)signature(/code) - the signature over auditInfo(/li)(/ul)}
     */
    GetSessionAuditDigest (privacyAdminHandle: tt.TPM_HANDLE, signHandle: tt.TPM_HANDLE, sessionHandle: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, 
                           continuation: (err: TpmError, res?: tt.GetSessionAuditDigestResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetSessionAuditDigest, [privacyAdminHandle, signHandle, sessionHandle]);
        let inStruct = new tt.TPM2_GetSessionAuditDigest_REQUEST(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetSessionAuditDigest, respBuf);
        let res: tt.GetSessionAuditDigestResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.GetSessionAuditDigestResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // GetSessionAuditDigest()
    
    /**
     * This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
     * 
     * @param privacyHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
     * @param signHandle the handle of the signing key Auth Index: 2 Auth Role: USER 
     * @param qualifyingData other data to associate with this audit digest 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @return TPM2_GetCommandAuditDigest_RESPONSE{(ul)(li)(code)auditInfo(/code) - the auditInfo that was signed(/li)(li)(code)signature(/code) - the signature over auditInfo(/li)(/ul)}
     */
    GetCommandAuditDigest (privacyHandle: tt.TPM_HANDLE, signHandle: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, 
                           continuation: (err: TpmError, res?: tt.GetCommandAuditDigestResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetCommandAuditDigest, [privacyHandle, signHandle]);
        let inStruct = new tt.TPM2_GetCommandAuditDigest_REQUEST(privacyHandle,signHandle,qualifyingData,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetCommandAuditDigest, respBuf);
        let res: tt.GetCommandAuditDigestResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.GetCommandAuditDigestResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // GetCommandAuditDigest()
    
    /**
     * This command returns the current values of Time and Clock.
     * 
     * @param privacyAdminHandle handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER 
     * @param signHandle the keyHandle identifier of a loaded key that can perform digital signatures Auth Index: 2 Auth Role: USER 
     * @param qualifyingData data to tick stamp 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @return TPM2_GetTime_RESPONSE{(ul)(li)(code)timeInfo(/code) - standard TPM-generated attestation block(/li)(li)(code)signature(/code) - the signature over timeInfo(/li)(/ul)}
     */
    GetTime (privacyAdminHandle: tt.TPM_HANDLE, signHandle: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, 
             continuation: (err: TpmError, res?: tt.GetTimeResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetTime, [privacyAdminHandle, signHandle]);
        let inStruct = new tt.TPM2_GetTime_REQUEST(privacyAdminHandle,signHandle,qualifyingData,inScheme);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetTime, respBuf);
        let res: tt.GetTimeResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.GetTimeResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // GetTime()
    
    /**
     * TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
     * 
     * @param signHandle handle of the key that will be used in the signing operation Auth Index: 1 Auth Role: USER 
     * @param P1 a point (M) on the curve used by signHandle 
     * @param s2 octet array used to derive x-coordinate of a base point 
     * @param y2 y coordinate of the point associated with s2 
     * @return TPM2_Commit_RESPONSE{(ul)(li)(code)K(/code) - ECC point K [ds](x2, y2)(/li)(li)(code)L(/code) - ECC point L [r](x2, y2)(/li)(li)(code)E(/code) - ECC point E [r]P1(/li)(li)(code)counter(/code) - least-significant 16 bits of commitCount(/li)(/ul)}
     */
    Commit (signHandle: tt.TPM_HANDLE, P1: tt.TPMS_ECC_POINT, s2: Buffer, y2: Buffer, 
            continuation: (err: TpmError, res?: tt.CommitResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Commit, [signHandle]);
        let inStruct = new tt.TPM2_Commit_REQUEST(signHandle,P1,s2,y2);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Commit, respBuf);
        let res: tt.CommitResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CommitResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // Commit()
    
    /**
     * TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
     * 
     * @param curveID The curve for the computed ephemeral point 
     * @return TPM2_EC_Ephemeral_RESPONSE{(ul)(li)(code)Q(/code) - ephemeral public key Q [r]G(/li)(li)(code)counter(/code) - least-significant 16 bits of commitCount(/li)(/ul)}
     */
    EC_Ephemeral (curveID: tt.TPM_ECC_CURVE, 
                  continuation: (err: TpmError, res?: tt.EC_EphemeralResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.EC_Ephemeral, null);
        let inStruct = new tt.TPM2_EC_Ephemeral_REQUEST(curveID);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.EC_Ephemeral, respBuf);
        let res: tt.EC_EphemeralResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.EC_EphemeralResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // EC_Ephemeral()
    
    /**
     * This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
     * 
     * @param keyHandle handle of public key that will be used in the validation Auth Index: None 
     * @param digest digest of the signed message 
     * @param signature signature to be tested 
     * @return This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
     */
    VerifySignature (keyHandle: tt.TPM_HANDLE, digest: Buffer, signature: tt.TPMU_SIGNATURE, 
                     continuation: (err: TpmError, res?: tt.TPMT_TK_VERIFIED) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.VerifySignature, [keyHandle]);
        let inStruct = new tt.TPM2_VerifySignature_REQUEST(keyHandle,digest,signature);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.VerifySignature, respBuf);
        let res: tt.VerifySignatureResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.VerifySignatureResponse);
            setImmediate(continuation, null, res.validation);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // VerifySignature()
    
    /**
     * This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
     * 
     * @param keyHandle Handle of key that will perform signing Auth Index: 1 Auth Role: USER 
     * @param digest digest to be signed 
     * @param inScheme signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL 
     * @param validation proof that digest was created by the TPM If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH. 
     * @return the signature
     */
    Sign (keyHandle: tt.TPM_HANDLE, digest: Buffer, inScheme: tt.TPMU_SIG_SCHEME, validation: tt.TPMT_TK_HASHCHECK, 
          continuation: (err: TpmError, res?: tt.TPMU_SIGNATURE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Sign, [keyHandle]);
        let inStruct = new tt.TPM2_Sign_REQUEST(keyHandle,digest,inScheme,validation);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Sign, respBuf);
        let res: tt.SignResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.SignResponse);
            setImmediate(continuation, null, res.signature);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // Sign()
    
    /**
     * This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
     * 
     * @param auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param auditAlg hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed 
     * @param setList list of commands that will be added to those that will be audited 
     * @param clearList list of commands that will no longer be audited
     */
    SetCommandCodeAuditStatus (auth: tt.TPM_HANDLE, auditAlg: tt.TPM_ALG_ID, setList: tt.TPM_CC[], clearList: tt.TPM_CC[], 
                               continuation: (err: TpmError, res?: tt.SetCommandCodeAuditStatusResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SetCommandCodeAuditStatus, [auth]);
        let inStruct = new tt.TPM2_SetCommandCodeAuditStatus_REQUEST(auth,auditAlg,setList,clearList);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SetCommandCodeAuditStatus, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // SetCommandCodeAuditStatus()
    
    /**
     * This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
     * 
     * @param pcrHandle handle of the PCR Auth Handle: 1 Auth Role: USER 
     * @param digests list of tagged digest values to be extended
     */
    PCR_Extend (pcrHandle: tt.TPM_HANDLE, digests: tt.TPMT_HA[], 
                continuation: (err: TpmError, res?: tt.PCR_ExtendResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_Extend, [pcrHandle]);
        let inStruct = new tt.TPM2_PCR_Extend_REQUEST(pcrHandle,digests);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_Extend, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PCR_Extend()
    
    /**
     * This command is used to cause an update to the indicated PCR.
     * 
     * @param pcrHandle Handle of the PCR Auth Handle: 1 Auth Role: USER 
     * @param eventData Event data in sized buffer 
     * @return -
     */
    PCR_Event (pcrHandle: tt.TPM_HANDLE, eventData: Buffer, 
               continuation: (err: TpmError, res?: tt.TPMT_HA[]) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_Event, [pcrHandle]);
        let inStruct = new tt.TPM2_PCR_Event_REQUEST(pcrHandle,eventData);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_Event, respBuf);
        let res: tt.PCR_EventResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.PCR_EventResponse);
            setImmediate(continuation, null, res.digests);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // PCR_Event()
    
    /**
     * This command returns the values of all PCR specified in pcrSelectionIn.
     * 
     * @param pcrSelectionIn The selection of PCR to read 
     * @return TPM2_PCR_Read_RESPONSE{(ul)(li)(code)pcrUpdateCounter(/code) - the current value of the PCR update counter(/li)(li)(code)pcrSelectionOut(/code) - the PCR in the returned list(/li)(li)(code)pcrValues(/code) - the contents of the PCR indicated in pcrSelectOut-) pcrSelection[] as tagged digests(/li)(/ul)}
     */
    PCR_Read (pcrSelectionIn: tt.TPMS_PCR_SELECTION[], 
              continuation: (err: TpmError, res?: tt.PCR_ReadResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_Read, null);
        let inStruct = new tt.TPM2_PCR_Read_REQUEST(pcrSelectionIn);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_Read, respBuf);
        let res: tt.PCR_ReadResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.PCR_ReadResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // PCR_Read()
    
    /**
     * This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
     * 
     * @param authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param pcrAllocation the requested allocation 
     * @return TPM2_PCR_Allocate_RESPONSE{(ul)(li)(code)allocationSuccess(/code) - YES if the allocation succeeded(/li)(li)(code)maxPCR(/code) - maximum number of PCR that may be in a bank(/li)(li)(code)sizeNeeded(/code) - number of octets required to satisfy the request(/li)(li)(code)sizeAvailable(/code) - Number of octets available. Computed before the allocation.(/li)(/ul)}
     */
    PCR_Allocate (authHandle: tt.TPM_HANDLE, pcrAllocation: tt.TPMS_PCR_SELECTION[], 
                  continuation: (err: TpmError, res?: tt.PCR_AllocateResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_Allocate, [authHandle]);
        let inStruct = new tt.TPM2_PCR_Allocate_REQUEST(authHandle,pcrAllocation);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_Allocate, respBuf);
        let res: tt.PCR_AllocateResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.PCR_AllocateResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // PCR_Allocate()
    
    /**
     * This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
     * 
     * @param authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param authPolicy the desired authPolicy 
     * @param hashAlg the hash algorithm of the policy 
     * @param pcrNum the PCR for which the policy is to be set
     */
    PCR_SetAuthPolicy (authHandle: tt.TPM_HANDLE, authPolicy: Buffer, hashAlg: tt.TPM_ALG_ID, pcrNum: tt.TPM_HANDLE, 
                       continuation: (err: TpmError, res?: tt.PCR_SetAuthPolicyResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_SetAuthPolicy, [authHandle]);
        let inStruct = new tt.TPM2_PCR_SetAuthPolicy_REQUEST(authHandle,authPolicy,hashAlg,pcrNum);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_SetAuthPolicy, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PCR_SetAuthPolicy()
    
    /**
     * This command changes the authValue of a PCR or group of PCR.
     * 
     * @param pcrHandle handle for a PCR that may have an authorization value set Auth Index: 1 Auth Role: USER 
     * @param auth the desired authorization value
     */
    PCR_SetAuthValue (pcrHandle: tt.TPM_HANDLE, auth: Buffer, 
                      continuation: (err: TpmError, res?: tt.PCR_SetAuthValueResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_SetAuthValue, [pcrHandle]);
        let inStruct = new tt.TPM2_PCR_SetAuthValue_REQUEST(pcrHandle,auth);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_SetAuthValue, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PCR_SetAuthValue()
    
    /**
     * If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
     * 
     * @param pcrHandle the PCR to reset Auth Index: 1 Auth Role: USER
     */
    PCR_Reset (pcrHandle: tt.TPM_HANDLE, 
               continuation: (err: TpmError, res?: tt.PCR_ResetResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PCR_Reset, [pcrHandle]);
        let inStruct = new tt.TPM2_PCR_Reset_REQUEST(pcrHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PCR_Reset, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PCR_Reset()
    
    /**
     * This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
     * 
     * @param authObject handle for a key that will validate the signature Auth Index: None 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param nonceTPM the policy nonce for the session This can be the Empty Buffer. 
     * @param cpHashA digest of the command parameters to which this authorization is limited This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer. 
     * @param policyRef a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM. 
     * @param expiration time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5. 
     * @param auth signed authorization (not optional) 
     * @return TPM2_PolicySigned_RESPONSE{(ul)(li)(code)timeout(/code) - implementation-specific time value, used to indicate to the TPM when the ticket expires NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.(/li)(li)(code)policyTicket(/code) - produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5(/li)(/ul)}
     */
    PolicySigned (authObject: tt.TPM_HANDLE, policySession: tt.TPM_HANDLE, nonceTPM: Buffer, cpHashA: Buffer, policyRef: Buffer, expiration: number, auth: tt.TPMU_SIGNATURE, 
                  continuation: (err: TpmError, res?: tt.PolicySignedResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicySigned, [authObject, policySession]);
        let inStruct = new tt.TPM2_PolicySigned_REQUEST(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicySigned, respBuf);
        let res: tt.PolicySignedResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.PolicySignedResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // PolicySigned()
    
    /**
     * This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
     * 
     * @param authHandle handle for an entity providing the authorization Auth Index: 1 Auth Role: USER 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param nonceTPM the policy nonce for the session This can be the Empty Buffer. 
     * @param cpHashA digest of the command parameters to which this authorization is limited This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer. 
     * @param policyRef a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM. 
     * @param expiration time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5. 
     * @return TPM2_PolicySecret_RESPONSE{(ul)(li)(code)timeout(/code) - implementation-specific time value used to indicate to the TPM when the ticket expires(/li)(li)(code)policyTicket(/code) - produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag(/li)(/ul)}
     */
    PolicySecret (authHandle: tt.TPM_HANDLE, policySession: tt.TPM_HANDLE, nonceTPM: Buffer, cpHashA: Buffer, policyRef: Buffer, expiration: number, 
                  continuation: (err: TpmError, res?: tt.PolicySecretResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicySecret, [authHandle, policySession]);
        let inStruct = new tt.TPM2_PolicySecret_REQUEST(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicySecret, respBuf);
        let res: tt.PolicySecretResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.PolicySecretResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // PolicySecret()
    
    /**
     * This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param timeout time when authorization will expire The contents are TPM specific. This shall be the value returned when ticket was produced. 
     * @param cpHashA digest of the command parameters to which this authorization is limited If it is not limited, the parameter will be the Empty Buffer. 
     * @param policyRef reference to a qualifier for the policy may be the Empty Buffer 
     * @param authName name of the object that provided the authorization 
     * @param ticket an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
     */
    PolicyTicket (policySession: tt.TPM_HANDLE, timeout: Buffer, cpHashA: Buffer, policyRef: Buffer, authName: Buffer, ticket: tt.TPMT_TK_AUTH, 
                  continuation: (err: TpmError, res?: tt.PolicyTicketResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyTicket, [policySession]);
        let inStruct = new tt.TPM2_PolicyTicket_REQUEST(policySession,timeout,cpHashA,policyRef,authName,ticket);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyTicket, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyTicket()
    
    /**
     * This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param pHashList the list of hashes to check for a match
     */
    PolicyOR (policySession: tt.TPM_HANDLE, pHashList: tt.TPM2B_DIGEST[], 
              continuation: (err: TpmError, res?: tt.PolicyORResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyOR, [policySession]);
        let inStruct = new tt.TPM2_PolicyOR_REQUEST(policySession,pHashList);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyOR, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyOR()
    
    /**
     * This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param pcrDigest expected digest value of the selected PCR using the hash algorithm of the session; may be zero length 
     * @param pcrs the PCR to include in the check digest
     */
    PolicyPCR (policySession: tt.TPM_HANDLE, pcrDigest: Buffer, pcrs: tt.TPMS_PCR_SELECTION[], 
               continuation: (err: TpmError, res?: tt.PolicyPCRResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyPCR, [policySession]);
        let inStruct = new tt.TPM2_PolicyPCR_REQUEST(policySession,pcrDigest,pcrs);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyPCR, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyPCR()
    
    /**
     * This command indicates that the authorization will be limited to a specific locality.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param locality the allowed localities for the policy
     */
    PolicyLocality (policySession: tt.TPM_HANDLE, locality: tt.TPMA_LOCALITY, 
                    continuation: (err: TpmError, res?: tt.PolicyLocalityResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyLocality, [policySession]);
        let inStruct = new tt.TPM2_PolicyLocality_REQUEST(policySession,locality);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyLocality, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyLocality()
    
    /**
     * This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index of the area to read Auth Index: None 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param operandB the second operand 
     * @param offset the octet offset in the NV Index for the start of operand A 
     * @param operation the comparison to make
     */
    PolicyNV (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, policySession: tt.TPM_HANDLE, operandB: Buffer, offset: number, operation: tt.TPM_EO, 
              continuation: (err: TpmError, res?: tt.PolicyNVResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyNV, [authHandle, nvIndex, policySession]);
        let inStruct = new tt.TPM2_PolicyNV_REQUEST(authHandle,nvIndex,policySession,operandB,offset,operation);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyNV, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyNV()
    
    /**
     * This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param operandB the second operand 
     * @param offset the octet offset in the TPMS_TIME_INFO structure for the start of operand A 
     * @param operation the comparison to make
     */
    PolicyCounterTimer (policySession: tt.TPM_HANDLE, operandB: Buffer, offset: number, operation: tt.TPM_EO, 
                        continuation: (err: TpmError, res?: tt.PolicyCounterTimerResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyCounterTimer, [policySession]);
        let inStruct = new tt.TPM2_PolicyCounterTimer_REQUEST(policySession,operandB,offset,operation);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyCounterTimer, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyCounterTimer()
    
    /**
     * This command indicates that the authorization will be limited to a specific command code.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param code the allowed commandCode
     */
    PolicyCommandCode (policySession: tt.TPM_HANDLE, code: tt.TPM_CC, 
                       continuation: (err: TpmError, res?: tt.PolicyCommandCodeResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyCommandCode, [policySession]);
        let inStruct = new tt.TPM2_PolicyCommandCode_REQUEST(policySession,code);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyCommandCode, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyCommandCode()
    
    /**
     * This command indicates that physical presence will need to be asserted at the time the authorization is performed.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None
     */
    PolicyPhysicalPresence (policySession: tt.TPM_HANDLE, 
                            continuation: (err: TpmError, res?: tt.PolicyPhysicalPresenceResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyPhysicalPresence, [policySession]);
        let inStruct = new tt.TPM2_PolicyPhysicalPresence_REQUEST(policySession);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyPhysicalPresence, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyPhysicalPresence()
    
    /**
     * This command is used to allow a policy to be bound to a specific command and command parameters.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param cpHashA the cpHash added to the policy
     */
    PolicyCpHash (policySession: tt.TPM_HANDLE, cpHashA: Buffer, 
                  continuation: (err: TpmError, res?: tt.PolicyCpHashResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyCpHash, [policySession]);
        let inStruct = new tt.TPM2_PolicyCpHash_REQUEST(policySession,cpHashA);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyCpHash, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyCpHash()
    
    /**
     * This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param nameHash the digest to be added to the policy
     */
    PolicyNameHash (policySession: tt.TPM_HANDLE, nameHash: Buffer, 
                    continuation: (err: TpmError, res?: tt.PolicyNameHashResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyNameHash, [policySession]);
        let inStruct = new tt.TPM2_PolicyNameHash_REQUEST(policySession,nameHash);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyNameHash, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyNameHash()
    
    /**
     * This command allows qualification of duplication to allow duplication to a selected new parent.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param objectName the Name of the object to be duplicated 
     * @param newParentName the Name of the new parent 
     * @param includeObject if YES, the objectName will be included in the value in policySessionpolicyDigest
     */
    PolicyDuplicationSelect (policySession: tt.TPM_HANDLE, objectName: Buffer, newParentName: Buffer, includeObject: number, 
                             continuation: (err: TpmError, res?: tt.PolicyDuplicationSelectResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyDuplicationSelect, [policySession]);
        let inStruct = new tt.TPM2_PolicyDuplicationSelect_REQUEST(policySession,objectName,newParentName,includeObject);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyDuplicationSelect, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyDuplicationSelect()
    
    /**
     * This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param approvedPolicy digest of the policy being approved 
     * @param policyRef a policy qualifier 
     * @param keySign Name of a key that can sign a policy addition 
     * @param checkTicket ticket validating that approvedPolicy and policyRef were signed by keySign
     */
    PolicyAuthorize (policySession: tt.TPM_HANDLE, approvedPolicy: Buffer, policyRef: Buffer, keySign: Buffer, checkTicket: tt.TPMT_TK_VERIFIED, 
                     continuation: (err: TpmError, res?: tt.PolicyAuthorizeResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyAuthorize, [policySession]);
        let inStruct = new tt.TPM2_PolicyAuthorize_REQUEST(policySession,approvedPolicy,policyRef,keySign,checkTicket);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyAuthorize, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyAuthorize()
    
    /**
     * This command allows a policy to be bound to the authorization value of the authorized entity.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None
     */
    PolicyAuthValue (policySession: tt.TPM_HANDLE, 
                     continuation: (err: TpmError, res?: tt.PolicyAuthValueResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyAuthValue, [policySession]);
        let inStruct = new tt.TPM2_PolicyAuthValue_REQUEST(policySession);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyAuthValue, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyAuthValue()
    
    /**
     * This command allows a policy to be bound to the authorization value of the authorized object.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None
     */
    PolicyPassword (policySession: tt.TPM_HANDLE, 
                    continuation: (err: TpmError, res?: tt.PolicyPasswordResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyPassword, [policySession]);
        let inStruct = new tt.TPM2_PolicyPassword_REQUEST(policySession);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyPassword, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyPassword()
    
    /**
     * This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
     * 
     * @param policySession handle for the policy session Auth Index: None 
     * @return the current value of the policySessionpolicyDigest
     */
    PolicyGetDigest (policySession: tt.TPM_HANDLE, 
                     continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyGetDigest, [policySession]);
        let inStruct = new tt.TPM2_PolicyGetDigest_REQUEST(policySession);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyGetDigest, respBuf);
        let res: tt.PolicyGetDigestResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.PolicyGetDigestResponse);
            setImmediate(continuation, null, res.policyDigest);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // PolicyGetDigest()
    
    /**
     * This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param writtenSet YES if NV Index is required to have been written NO if NV Index is required not to have been written
     */
    PolicyNvWritten (policySession: tt.TPM_HANDLE, writtenSet: number, 
                     continuation: (err: TpmError, res?: tt.PolicyNvWrittenResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyNvWritten, [policySession]);
        let inStruct = new tt.TPM2_PolicyNvWritten_REQUEST(policySession,writtenSet);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyNvWritten, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyNvWritten()
    
    /**
     * This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param templateHash the digest to be added to the policy
     */
    PolicyTemplate (policySession: tt.TPM_HANDLE, templateHash: Buffer, 
                    continuation: (err: TpmError, res?: tt.PolicyTemplateResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyTemplate, [policySession]);
        let inStruct = new tt.TPM2_PolicyTemplate_REQUEST(policySession,templateHash);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyTemplate, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyTemplate()
    
    /**
     * This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index of the area to read Auth Index: None 
     * @param policySession handle for the policy session being extended Auth Index: None
     */
    PolicyAuthorizeNV (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, policySession: tt.TPM_HANDLE, 
                       continuation: (err: TpmError, res?: tt.PolicyAuthorizeNVResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PolicyAuthorizeNV, [authHandle, nvIndex, policySession]);
        let inStruct = new tt.TPM2_PolicyAuthorizeNV_REQUEST(authHandle,nvIndex,policySession);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PolicyAuthorizeNV, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PolicyAuthorizeNV()
    
    /**
     * This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
     * 
     * @param primaryHandle TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER 
     * @param inSensitive the sensitive data, see TPM 2.0 Part 1 Sensitive Values 
     * @param inPublic the public template 
     * @param outsideInfo data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data 
     * @param creationPCR PCR that will be used in creation data 
     * @return TPM2_CreatePrimary_RESPONSE{(ul)(li)(code)handle(/code) - handle of type TPM_HT_TRANSIENT for created Primary Object(/li)(li)(code)outPublic(/code) - the public portion of the created object(/li)(li)(code)creationData(/code) - contains a TPMT_CREATION_DATA(/li)(li)(code)creationHash(/code) - digest of creationData using nameAlg of outPublic(/li)(li)(code)creationTicket(/code) - ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM(/li)(li)(code)name(/code) - the name of the created object(/li)(/ul)}
     */
    CreatePrimary (primaryHandle: tt.TPM_HANDLE, inSensitive: tt.TPMS_SENSITIVE_CREATE, inPublic: tt.TPMT_PUBLIC, outsideInfo: Buffer, creationPCR: tt.TPMS_PCR_SELECTION[], 
                   continuation: (err: TpmError, res?: tt.CreatePrimaryResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.CreatePrimary, [primaryHandle]);
        let inStruct = new tt.TPM2_CreatePrimary_REQUEST(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.CreatePrimary, respBuf);
        let res: tt.CreatePrimaryResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.CreatePrimaryResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // CreatePrimary()
    
    /**
     * This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
     * 
     * @param authHandle TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param enable the enable being modified TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV 
     * @param state YES if the enable should be SET, NO if the enable should be CLEAR
     */
    HierarchyControl (authHandle: tt.TPM_HANDLE, enable: tt.TPM_HANDLE, state: number, 
                      continuation: (err: TpmError, res?: tt.HierarchyControlResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.HierarchyControl, [authHandle]);
        let inStruct = new tt.TPM2_HierarchyControl_REQUEST(authHandle,enable,state);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.HierarchyControl, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // HierarchyControl()
    
    /**
     * This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
     * 
     * @param authHandle TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param authPolicy an authorization policy digest; may be the Empty Buffer If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer. 
     * @param hashAlg the hash algorithm to use for the policy If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
     */
    SetPrimaryPolicy (authHandle: tt.TPM_HANDLE, authPolicy: Buffer, hashAlg: tt.TPM_ALG_ID, 
                      continuation: (err: TpmError, res?: tt.SetPrimaryPolicyResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SetPrimaryPolicy, [authHandle]);
        let inStruct = new tt.TPM2_SetPrimaryPolicy_REQUEST(authHandle,authPolicy,hashAlg);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SetPrimaryPolicy, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // SetPrimaryPolicy()
    
    /**
     * This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
     * 
     * @param authHandle TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
     */
    ChangePPS (authHandle: tt.TPM_HANDLE, 
               continuation: (err: TpmError, res?: tt.ChangePPSResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ChangePPS, [authHandle]);
        let inStruct = new tt.TPM2_ChangePPS_REQUEST(authHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ChangePPS, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // ChangePPS()
    
    /**
     * This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
     * 
     * @param authHandle TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
     */
    ChangeEPS (authHandle: tt.TPM_HANDLE, 
               continuation: (err: TpmError, res?: tt.ChangeEPSResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ChangeEPS, [authHandle]);
        let inStruct = new tt.TPM2_ChangeEPS_REQUEST(authHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ChangeEPS, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // ChangeEPS()
    
    /**
     * This command removes all TPM context associated with a specific Owner.
     * 
     * @param authHandle TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
     */
    Clear (authHandle: tt.TPM_HANDLE, 
           continuation: (err: TpmError, res?: tt.ClearResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Clear, [authHandle]);
        let inStruct = new tt.TPM2_Clear_REQUEST(authHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Clear, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // Clear()
    
    /**
     * TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
     * 
     * @param auth TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
     * @param disable YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
     */
    ClearControl (auth: tt.TPM_HANDLE, disable: number, 
                  continuation: (err: TpmError, res?: tt.ClearControlResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ClearControl, [auth]);
        let inStruct = new tt.TPM2_ClearControl_REQUEST(auth,disable);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ClearControl, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // ClearControl()
    
    /**
     * This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
     * 
     * @param authHandle TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param newAuth new authorization value
     */
    HierarchyChangeAuth (authHandle: tt.TPM_HANDLE, newAuth: Buffer, 
                         continuation: (err: TpmError, res?: tt.HierarchyChangeAuthResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.HierarchyChangeAuth, [authHandle]);
        let inStruct = new tt.TPM2_HierarchyChangeAuth_REQUEST(authHandle,newAuth);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.HierarchyChangeAuth, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // HierarchyChangeAuth()
    
    /**
     * This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
     * 
     * @param lockHandle TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
     */
    DictionaryAttackLockReset (lockHandle: tt.TPM_HANDLE, 
                               continuation: (err: TpmError, res?: tt.DictionaryAttackLockResetResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.DictionaryAttackLockReset, [lockHandle]);
        let inStruct = new tt.TPM2_DictionaryAttackLockReset_REQUEST(lockHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.DictionaryAttackLockReset, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // DictionaryAttackLockReset()
    
    /**
     * This command changes the lockout parameters.
     * 
     * @param lockHandle TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER 
     * @param newMaxTries count of authorization failures before the lockout is imposed 
     * @param newRecoveryTime time in seconds before the authorization failure count is automatically decremented A value of zero indicates that DA protection is disabled. 
     * @param lockoutRecovery time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed A value of zero indicates that a reboot is required.
     */
    DictionaryAttackParameters (lockHandle: tt.TPM_HANDLE, newMaxTries: number, newRecoveryTime: number, lockoutRecovery: number, 
                                continuation: (err: TpmError, res?: tt.DictionaryAttackParametersResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.DictionaryAttackParameters, [lockHandle]);
        let inStruct = new tt.TPM2_DictionaryAttackParameters_REQUEST(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.DictionaryAttackParameters, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // DictionaryAttackParameters()
    
    /**
     * This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
     * 
     * @param auth TPM_RH_PLATFORM+PP Auth Index: 1 Auth Role: USER + Physical Presence 
     * @param setList list of commands to be added to those that will require that Physical Presence be asserted 
     * @param clearList list of commands that will no longer require that Physical Presence be asserted
     */
    PP_Commands (auth: tt.TPM_HANDLE, setList: tt.TPM_CC[], clearList: tt.TPM_CC[], 
                 continuation: (err: TpmError, res?: tt.PP_CommandsResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.PP_Commands, [auth]);
        let inStruct = new tt.TPM2_PP_Commands_REQUEST(auth,setList,clearList);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.PP_Commands, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // PP_Commands()
    
    /**
     * This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
     * 
     * @param authHandle TPM_RH_PLATFORM Auth Index: 1 Auth Role: USER 
     * @param algorithmSet a TPM vendor-dependent value indicating the algorithm set selection
     */
    SetAlgorithmSet (authHandle: tt.TPM_HANDLE, algorithmSet: number, 
                     continuation: (err: TpmError, res?: tt.SetAlgorithmSetResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.SetAlgorithmSet, [authHandle]);
        let inStruct = new tt.TPM2_SetAlgorithmSet_REQUEST(authHandle,algorithmSet);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.SetAlgorithmSet, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // SetAlgorithmSet()
    
    /**
     * This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
     * 
     * @param authorization TPM_RH_PLATFORM+{PP} Auth Index:1 Auth Role: ADMIN 
     * @param keyHandle handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature Auth Index: None 
     * @param fuDigest digest of the first block in the field upgrade sequence 
     * @param manifestSignature signature over fuDigest using the key associated with keyHandle (not optional)
     */
    FieldUpgradeStart (authorization: tt.TPM_HANDLE, keyHandle: tt.TPM_HANDLE, fuDigest: Buffer, manifestSignature: tt.TPMU_SIGNATURE, 
                       continuation: (err: TpmError, res?: tt.FieldUpgradeStartResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.FieldUpgradeStart, [authorization, keyHandle]);
        let inStruct = new tt.TPM2_FieldUpgradeStart_REQUEST(authorization,keyHandle,fuDigest,manifestSignature);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.FieldUpgradeStart, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // FieldUpgradeStart()
    
    /**
     * This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
     * 
     * @param fuData field upgrade image data 
     * @return TPM2_FieldUpgradeData_RESPONSE{(ul)(li)(code)nextDigest(/code) - tagged digest of the next block TPM_ALG_NULL if field update is complete(/li)(li)(code)firstDigest(/code) - tagged digest of the first block of the sequence(/li)(/ul)}
     */
    FieldUpgradeData (fuData: Buffer, 
                      continuation: (err: TpmError, res?: tt.FieldUpgradeDataResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.FieldUpgradeData, null);
        let inStruct = new tt.TPM2_FieldUpgradeData_REQUEST(fuData);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.FieldUpgradeData, respBuf);
        let res: tt.FieldUpgradeDataResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.FieldUpgradeDataResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // FieldUpgradeData()
    
    /**
     * This command is used to read a copy of the current firmware installed in the TPM.
     * 
     * @param sequenceNumber the number of previous calls to this command in this sequence set to 0 on the first call 
     * @return field upgrade image data
     */
    FirmwareRead (sequenceNumber: number, 
                  continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.FirmwareRead, null);
        let inStruct = new tt.TPM2_FirmwareRead_REQUEST(sequenceNumber);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.FirmwareRead, respBuf);
        let res: tt.FirmwareReadResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.FirmwareReadResponse);
            setImmediate(continuation, null, res.fuData);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // FirmwareRead()
    
    /**
     * This command saves a session context, object context, or sequence object context outside the TPM.
     * 
     * @param saveHandle handle of the resource to save Auth Index: None 
     * @return This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
     */
    ContextSave (saveHandle: tt.TPM_HANDLE, 
                 continuation: (err: TpmError, res?: tt.TPMS_CONTEXT) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ContextSave, [saveHandle]);
        let inStruct = new tt.TPM2_ContextSave_REQUEST(saveHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ContextSave, respBuf);
        let res: tt.ContextSaveResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ContextSaveResponse);
            setImmediate(continuation, null, res.context);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ContextSave()
    
    /**
     * This command is used to reload a context that has been saved by TPM2_ContextSave().
     * 
     * @param context the context blob 
     * @return the handle assigned to the resource after it has been successfully loaded
     */
    ContextLoad (context: tt.TPMS_CONTEXT, 
                 continuation: (err: TpmError, res?: tt.TPM_HANDLE) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ContextLoad, null);
        let inStruct = new tt.TPM2_ContextLoad_REQUEST(context);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ContextLoad, respBuf);
        let res: tt.ContextLoadResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ContextLoadResponse);
            setImmediate(continuation, null, res.handle);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ContextLoad()
    
    /**
     * This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
     * 
     * @param flushHandle the handle of the item to flush NOTE This is a use of a handle as a parameter.
     */
    FlushContext (flushHandle: tt.TPM_HANDLE, 
                  continuation: (err: TpmError, res?: tt.FlushContextResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.FlushContext, null);
        let inStruct = new tt.TPM2_FlushContext_REQUEST(flushHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.FlushContext, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // FlushContext()
    
    /**
     * This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
     * 
     * @param auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
     * @param objectHandle the handle of a loaded object Auth Index: None 
     * @param persistentHandle if objectHandle is a transient object handle, then this is the persistent handle for the object if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle
     */
    EvictControl (auth: tt.TPM_HANDLE, objectHandle: tt.TPM_HANDLE, persistentHandle: tt.TPM_HANDLE, 
                  continuation: (err: TpmError, res?: tt.EvictControlResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.EvictControl, [auth, objectHandle]);
        let inStruct = new tt.TPM2_EvictControl_REQUEST(auth,objectHandle,persistentHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.EvictControl, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // EvictControl()
    
    /**
     * This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
     * 
     * @return This structure is used in the TPM2_GetTime() attestation.
     */
    ReadClock (continuation: (err: TpmError, res?: tt.TPMS_TIME_INFO) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ReadClock, null);
        let inStruct = new tt.TPM2_ReadClock_REQUEST();
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ReadClock, respBuf);
        let res: tt.ReadClockResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.ReadClockResponse);
            setImmediate(continuation, null, res.currentTime);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // ReadClock()
    
    /**
     * This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
     * 
     * @param auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
     * @param newTime new Clock setting in milliseconds
     */
    ClockSet (auth: tt.TPM_HANDLE, newTime: number, 
              continuation: (err: TpmError, res?: tt.ClockSetResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ClockSet, [auth]);
        let inStruct = new tt.TPM2_ClockSet_REQUEST(auth,newTime);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ClockSet, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // ClockSet()
    
    /**
     * This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
     * 
     * @param auth TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER 
     * @param rateAdjust Adjustment to current Clock update rate
     */
    ClockRateAdjust (auth: tt.TPM_HANDLE, rateAdjust: tt.TPM_CLOCK_ADJUST, 
                     continuation: (err: TpmError, res?: tt.ClockRateAdjustResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.ClockRateAdjust, [auth]);
        let inStruct = new tt.TPM2_ClockRateAdjust_REQUEST(auth,rateAdjust);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.ClockRateAdjust, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // ClockRateAdjust()
    
    /**
     * This command returns various information regarding the TPM and its current state.
     * 
     * @param capability group selection; determines the format of the response 
     * @param property further definition of information 
     * @param propertyCount number of properties of the indicated type to return 
     * @return TPM2_GetCapability_RESPONSE{(ul)(li)(code)moreData(/code) - flag to indicate if there are more values of this type(/li)(li)(code)capabilityData(/code) - the capability data(/li)(/ul)}
     */
    GetCapability (capability: tt.TPM_CAP, property: number, propertyCount: number, 
                   continuation: (err: TpmError, res?: tt.GetCapabilityResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.GetCapability, null);
        let inStruct = new tt.TPM2_GetCapability_REQUEST(capability,property,propertyCount);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.GetCapability, respBuf);
        let res: tt.GetCapabilityResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.GetCapabilityResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // GetCapability()
    
    /**
     * This command is used to check to see if specific combinations of algorithm parameters are supported.
     * 
     * @param parameters algorithm parameters to be validated
     */
    TestParms (parameters: tt.TPMU_PUBLIC_PARMS, 
               continuation: (err: TpmError, res?: tt.TestParmsResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.TestParms, null);
        let inStruct = new tt.TPM2_TestParms_REQUEST(parameters);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.TestParms, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // TestParms()
    
    /**
     * This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
     * 
     * @param authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param auth the authorization value 
     * @param publicInfo the public parameters of the NV area
     */
    NV_DefineSpace (authHandle: tt.TPM_HANDLE, auth: Buffer, publicInfo: tt.TPMS_NV_PUBLIC, 
                    continuation: (err: TpmError, res?: tt.NV_DefineSpaceResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_DefineSpace, [authHandle]);
        let inStruct = new tt.TPM2_NV_DefineSpace_REQUEST(authHandle,auth,publicInfo);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_DefineSpace, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_DefineSpace()
    
    /**
     * This command removes an Index from the TPM.
     * 
     * @param authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index to remove from NV space Auth Index: None
     */
    NV_UndefineSpace (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, 
                      continuation: (err: TpmError, res?: tt.NV_UndefineSpaceResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_UndefineSpace, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_UndefineSpace_REQUEST(authHandle,nvIndex);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_UndefineSpace, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_UndefineSpace()
    
    /**
     * This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
     * 
     * @param nvIndex Index to be deleted Auth Index: 1 Auth Role: ADMIN 
     * @param platform TPM_RH_PLATFORM + {PP} Auth Index: 2 Auth Role: USER
     */
    NV_UndefineSpaceSpecial (nvIndex: tt.TPM_HANDLE, platform: tt.TPM_HANDLE, 
                             continuation: (err: TpmError, res?: tt.NV_UndefineSpaceSpecialResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_UndefineSpaceSpecial, [nvIndex, platform]);
        let inStruct = new tt.TPM2_NV_UndefineSpaceSpecial_REQUEST(nvIndex,platform);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_UndefineSpaceSpecial, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_UndefineSpaceSpecial()
    
    /**
     * This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
     * 
     * @param nvIndex the NV Index Auth Index: None 
     * @return TPM2_NV_ReadPublic_RESPONSE{(ul)(li)(code)nvPublic(/code) - the public area of the NV Index(/li)(li)(code)nvName(/code) - the Name of the nvIndex(/li)(/ul)}
     */
    NV_ReadPublic (nvIndex: tt.TPM_HANDLE, 
                   continuation: (err: TpmError, res?: tt.NV_ReadPublicResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_ReadPublic, [nvIndex]);
        let inStruct = new tt.TPM2_NV_ReadPublic_REQUEST(nvIndex);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_ReadPublic, respBuf);
        let res: tt.NV_ReadPublicResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.NV_ReadPublicResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // NV_ReadPublic()
    
    /**
     * This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index of the area to write Auth Index: None 
     * @param data the data to write 
     * @param offset the octet offset into the NV Area
     */
    NV_Write (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, data: Buffer, offset: number, 
              continuation: (err: TpmError, res?: tt.NV_WriteResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_Write, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_Write_REQUEST(authHandle,nvIndex,data,offset);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_Write, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_Write()
    
    /**
     * This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index to increment Auth Index: None
     */
    NV_Increment (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, 
                  continuation: (err: TpmError, res?: tt.NV_IncrementResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_Increment, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_Increment_REQUEST(authHandle,nvIndex);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_Increment, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_Increment()
    
    /**
     * This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index to extend Auth Index: None 
     * @param data the data to extend
     */
    NV_Extend (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, data: Buffer, 
               continuation: (err: TpmError, res?: tt.NV_ExtendResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_Extend, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_Extend_REQUEST(authHandle,nvIndex,data);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_Extend, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_Extend()
    
    /**
     * This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex NV Index of the area in which the bit is to be set Auth Index: None 
     * @param bits the data to OR with the current contents
     */
    NV_SetBits (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, bits: number, 
                continuation: (err: TpmError, res?: tt.NV_SetBitsResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_SetBits, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_SetBits_REQUEST(authHandle,nvIndex,bits);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_SetBits, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_SetBits()
    
    /**
     * If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
     * 
     * @param authHandle handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index of the area to lock Auth Index: None
     */
    NV_WriteLock (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, 
                  continuation: (err: TpmError, res?: tt.NV_WriteLockResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_WriteLock, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_WriteLock_REQUEST(authHandle,nvIndex);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_WriteLock, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_WriteLock()
    
    /**
     * The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
     * 
     * @param authHandle TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
     */
    NV_GlobalWriteLock (authHandle: tt.TPM_HANDLE, 
                        continuation: (err: TpmError, res?: tt.NV_GlobalWriteLockResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_GlobalWriteLock, [authHandle]);
        let inStruct = new tt.TPM2_NV_GlobalWriteLock_REQUEST(authHandle);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_GlobalWriteLock, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_GlobalWriteLock()
    
    /**
     * This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
     * 
     * @param authHandle the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index to be read Auth Index: None 
     * @param size number of octets to read 
     * @param offset octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data. 
     * @return the data read
     */
    NV_Read (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, size: number, offset: number, 
             continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_Read, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_Read_REQUEST(authHandle,nvIndex,size,offset);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_Read, respBuf);
        let res: tt.NV_ReadResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.NV_ReadResponse);
            setImmediate(continuation, null, res.data);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // NV_Read()
    
    /**
     * If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
     * 
     * @param authHandle the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER 
     * @param nvIndex the NV Index to be locked Auth Index: None
     */
    NV_ReadLock (authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, 
                 continuation: (err: TpmError, res?: tt.NV_ReadLockResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_ReadLock, [authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_ReadLock_REQUEST(authHandle,nvIndex);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_ReadLock, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_ReadLock()
    
    /**
     * This command allows the authorization secret for an NV Index to be changed.
     * 
     * @param nvIndex handle of the entity Auth Index: 1 Auth Role: ADMIN 
     * @param newAuth new authorization value
     */
    NV_ChangeAuth (nvIndex: tt.TPM_HANDLE, newAuth: Buffer, 
                   continuation: (err: TpmError, res?: tt.NV_ChangeAuthResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_ChangeAuth, [nvIndex]);
        let inStruct = new tt.TPM2_NV_ChangeAuth_REQUEST(nvIndex,newAuth);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_ChangeAuth, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // NV_ChangeAuth()
    
    /**
     * The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
     * 
     * @param signHandle handle of the key used to sign the attestation structure Auth Index: 1 Auth Role: USER 
     * @param authHandle handle indicating the source of the authorization value for the NV Index Auth Index: 2 Auth Role: USER 
     * @param nvIndex Index for the area to be certified Auth Index: None 
     * @param qualifyingData user-provided qualifying data 
     * @param inScheme signing scheme to use if the scheme for signHandle is TPM_ALG_NULL 
     * @param size number of octets to certify 
     * @param offset octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data. 
     * @return TPM2_NV_Certify_RESPONSE{(ul)(li)(code)certifyInfo(/code) - the structure that was signed(/li)(li)(code)signature(/code) - the asymmetric signature over certifyInfo using the key referenced by signHandle(/li)(/ul)}
     */
    NV_Certify (signHandle: tt.TPM_HANDLE, authHandle: tt.TPM_HANDLE, nvIndex: tt.TPM_HANDLE, qualifyingData: Buffer, inScheme: tt.TPMU_SIG_SCHEME, size: number, offset: number, 
                continuation: (err: TpmError, res?: tt.NV_CertifyResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.NV_Certify, [signHandle, authHandle, nvIndex]);
        let inStruct = new tt.TPM2_NV_Certify_REQUEST(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.NV_Certify, respBuf);
        let res: tt.NV_CertifyResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.NV_CertifyResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // NV_Certify()
    
    /**
     * The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
     * 
     * @param ac handle indicating the Attached Component Auth Index: None 
     * @param capability starting info type 
     * @param count maximum number of values to return 
     * @return TPM2_AC_GetCapability_RESPONSE{(ul)(li)(code)moreData(/code) - flag to indicate whether there are more values(/li)(li)(code)capabilitiesData(/code) - list of capabilities(/li)(/ul)}
     */
    AC_GetCapability (ac: tt.TPM_HANDLE, capability: tt.TPM_AT, count: number, 
                      continuation: (err: TpmError, res?: tt.AC_GetCapabilityResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.AC_GetCapability, [ac]);
        let inStruct = new tt.TPM2_AC_GetCapability_REQUEST(ac,capability,count);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.AC_GetCapability, respBuf);
        let res: tt.AC_GetCapabilityResponse = null;
        if (!this.lastError)
            res = respBuf.createFromTpm(tt.AC_GetCapabilityResponse);
        setImmediate(continuation, this.lastError, res);  });
    } // AC_GetCapability()
    
    /**
     * The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
     * 
     * @param sendObject handle of the object being sent to ac Auth Index: 1 Auth Role: DUP 
     * @param authHandle the handle indicating the source of the authorization value Auth Index: 2 Auth Role: USER 
     * @param ac handle indicating the Attached Component to which the object will be sent Auth Index: None 
     * @param acDataIn Optional non sensitive information related to the object 
     * @return May include AC specific data or information about an error.
     */
    AC_Send (sendObject: tt.TPM_HANDLE, authHandle: tt.TPM_HANDLE, ac: tt.TPM_HANDLE, acDataIn: Buffer, 
             continuation: (err: TpmError, res?: tt.TPMS_AC_OUTPUT) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.AC_Send, [sendObject, authHandle, ac]);
        let inStruct = new tt.TPM2_AC_Send_REQUEST(sendObject,authHandle,ac,acDataIn);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.AC_Send, respBuf);
        let res: tt.AC_SendResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.AC_SendResponse);
            setImmediate(continuation, null, res.acDataOut);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // AC_Send()
    
    /**
     * This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
     * 
     * @param policySession handle for the policy session being extended Auth Index: None 
     * @param objectName the Name of the Object to be sent 
     * @param authHandleName the Name associated with authHandle used in the TPM2_AC_Send() command 
     * @param acName the Name of the Attached Component to which the Object will be sent 
     * @param includeObject if SET, objectName will be included in the value in policySessionpolicyDigest
     */
    Policy_AC_SendSelect (policySession: tt.TPM_HANDLE, objectName: Buffer, authHandleName: Buffer, acName: Buffer, includeObject: number, 
                          continuation: (err: TpmError, res?: tt.Policy_AC_SendSelectResponse) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Policy_AC_SendSelect, [policySession]);
        let inStruct = new tt.TPM2_Policy_AC_SendSelect_REQUEST(policySession,objectName,authHandleName,acName,includeObject);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Policy_AC_SendSelect, respBuf);
        setImmediate(continuation, this.lastError);  });
    } // Policy_AC_SendSelect()
    
    /**
     * This is a placeholder to allow testing of the dispatch code.
     * 
     * @param inputData dummy data 
     * @return dummy data
     */
    Vendor_TCG_Test (inputData: Buffer, 
                     continuation: (err: TpmError, res?: Buffer) => void)
    {
        let cmdBuf = super.prepareCmdBuf(tt.TPM_CC.Vendor_TCG_Test, null);
        let inStruct = new tt.TPM2_Vendor_TCG_Test_REQUEST(inputData);
        inStruct.toTpm(cmdBuf);
        super.dispatchCommand(cmdBuf.trim(), (respBuf: TpmBuffer): void => {
        if (!this.lastError)
            super.processResponse(tt.TPM_CC.Vendor_TCG_Test, respBuf);
        let res: tt.Vendor_TCG_TestResponse = null;
        if (!this.lastError)
        {
            res = respBuf.createFromTpm(tt.Vendor_TCG_TestResponse);
            setImmediate(continuation, null, res.outputData);
        }
        else
            setImmediate(continuation, this.lastError, null);  });
    } // Vendor_TCG_Test()
    
} // class Tpm
