/* 
 * Copyright(c) Microsoft Corporation.All rights reserved. 
 * Licensed under the MIT License. 
 * See the LICENSE file in the project root for full license information. 
 */

/*
 * This file is automatically generated from the TPM 2.0 rev. 1.46 specification documents.
 * Do not edit it directly.
 */


import { TpmBuffer, TpmMarshaller, TpmStructure, nonStandardFromTpm, nonStandardToTpm }
       from "./TpmMarshaller.js";

import { Crypto } from "./Crypt.js";


/**
* Selector type for TPMU_NAME [TSS]
*/
export enum NameUnionTagValues // byte
{
    TAG_TPMU_NAME_TPMT_HA = 0,
    
    TAG_TPMU_NAME_TPM_HANDLE = 1
}; // NameUnionTagValues

/**
* Table 2 is the list of algorithms to which the TCG has assigned an algorithm identifier along with its numeric identifier.
*/
export enum TPM_ALG_ID // UINT16
{
    /**
    * should not occur
    */
    ERROR = 0x0000,
    
    /**
    * an object type that contains an RSA key
    */
    FIRST = 0x0001,
    
    /**
    * an object type that contains an RSA key
    */
    RSA = 0x0001,
    
    TDES = 0x0003,
    
    /**
    * hash algorithm producing a 160-bit digest
    */
    SHA = 0x0004,
    
    /**
    * redefinition for documentation consistency
    */
    SHA1 = 0x0004,
    
    /**
    * Hash Message Authentication Code (HMAC) algorithm
    */
    HMAC = 0x0005,
    
    /**
    * block cipher with various key sizes
    */
    AES = 0x0006,
    
    /**
    * hash-based mask-generation function
    */
    MGF1 = 0x0007,
    
    /**
    * an object type that may use XOR for encryption or an HMAC for signing and may also refer to a data object that is neither signing nor encrypting
    */
    KEYEDHASH = 0x0008,
    
    /**
    * hash-based stream cipher
    */
    XOR = 0x000A,
    
    /**
    * hash algorithm producing a 256-bit digest
    */
    SHA256 = 0x000B,
    
    /**
    * hash algorithm producing a 384-bit digest
    */
    SHA384 = 0x000C,
    
    /**
    * hash algorithm producing a 512-bit digest
    */
    SHA512 = 0x000D,
    
    /**
    * Indication that no algorithm is selected
    */
    NULL = 0x0010,
    
    /**
    * hash algorithm producing a 256-bit digest
    */
    SM3_256 = 0x0012,
    
    /**
    * symmetric block cipher with 128 bit key
    */
    SM4 = 0x0013,
    
    /**
    * a signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)
    */
    RSASSA = 0x0014,
    
    /**
    * a padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)
    */
    RSAES = 0x0015,
    
    /**
    * a signature algorithm defined in section 8.1 (RSASSA-PSS)
    */
    RSAPSS = 0x0016,
    
    /**
    * a padding algorithm defined in Section 7.1 (RSAES_OAEP)
    */
    OAEP = 0x0017,
    
    /**
    * signature algorithm using elliptic curve cryptography (ECC)
    */
    ECDSA = 0x0018,
    
    /**
    * secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman, C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
    */
    ECDH = 0x0019,
    
    /**
    * elliptic-curve based, anonymous signing scheme
    */
    ECDAA = 0x001A,
    
    /**
    * depending on context, either an elliptic-curve based, signature algorithm or a key exchange protocol NOTE Type listed as signing but, other uses are allowed according to context.
    */
    SM2 = 0x001B,
    
    /**
    * elliptic-curve based Schnorr signature
    */
    ECSCHNORR = 0x001C,
    
    /**
    * two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4
    */
    ECMQV = 0x001D,
    
    /**
    * concatenation key derivation function (approved alternative 1) Section 5.8.1
    */
    KDF1_SP800_56A = 0x0020,
    
    /**
    * key derivation function KDF2 Section 13.2
    */
    KDF2 = 0x0021,
    
    /**
    * a key derivation method SP800-108, Section 5.1 KDF in Counter Mode
    */
    KDF1_SP800_108 = 0x0022,
    
    /**
    * prime field ECC
    */
    ECC = 0x0023,
    
    /**
    * the object type for a symmetric block cipher key
    */
    SYMCIPHER = 0x0025,
    
    /**
    * symmetric block cipher with various key sizes
    */
    CAMELLIA = 0x0026,
    
    CMAC = 0x003F,
    
    /**
    * Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    */
    CTR = 0x0040,
    
    /**
    * Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    */
    OFB = 0x0041,
    
    /**
    * Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    */
    CBC = 0x0042,
    
    /**
    * Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented shall be capable of using this mode.
    */
    CFB = 0x0043,
    
    /**
    * Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S type) shall be capable of using this mode. NOTE This mode is not recommended for uses unless the key is frequently rotated such as in video codecs
    */
    ECB = 0x0044,
    
    LAST = 0x0044,
    
    /**
    * Phony alg ID to be used for the first union member with no selector
    */
    ANY = 0x7FFF,
    
    /**
    * Phony alg ID to be used for the second union member with no selector
    */
    ANY2 = 0x7FFE
}; // TPM_ALG_ID

/**
* Table 3 is the list of identifiers for TCG-registered curve ID values for elliptic curve cryptography.
*/
export enum TPM_ECC_CURVE // UINT16
{
    NONE = 0x0000,
    
    NIST_P192 = 0x0001,
    
    NIST_P224 = 0x0002,
    
    NIST_P256 = 0x0003,
    
    NIST_P384 = 0x0004,
    
    NIST_P521 = 0x0005,
    
    /**
    * curve to support ECDAA
    */
    BN_P256 = 0x0010,
    
    /**
    * curve to support ECDAA
    */
    BN_P638 = 0x0011,
    
    SM2_P256 = 0x0020
}; // TPM_ECC_CURVE

/**
* Table 12 Defines for SHA1 Hash Values
*/
export enum SHA1 // UINT32
{
    /**
    * size of digest in octets
    */
    DIGEST_SIZE = 20,
    
    /**
    * size of hash block in octets
    */
    BLOCK_SIZE = 64,
    
    /**
    * size of the DER in octets
    */
    DER_SIZE = 15
}; // SHA1

/**
* Table 13 Defines for SHA256 Hash Values
*/
export enum SHA256 // UINT32
{
    /**
    * size of digest
    */
    DIGEST_SIZE = 32,
    
    /**
    * size of hash block
    */
    BLOCK_SIZE = 64,
    
    /**
    * size of the DER in octets
    */
    DER_SIZE = 19
}; // SHA256

/**
* Table 14 Defines for SHA384 Hash Values
*/
export enum SHA384 // UINT32
{
    /**
    * size of digest in octets
    */
    DIGEST_SIZE = 48,
    
    /**
    * size of hash block in octets
    */
    BLOCK_SIZE = 128,
    
    /**
    * size of the DER in octets
    */
    DER_SIZE = 19
}; // SHA384

/**
* Table 15 Defines for SHA512 Hash Values
*/
export enum SHA512 // UINT32
{
    /**
    * size of digest in octets
    */
    DIGEST_SIZE = 64,
    
    /**
    * size of hash block in octets
    */
    BLOCK_SIZE = 128,
    
    /**
    * size of the DER in octets
    */
    DER_SIZE = 19
}; // SHA512

/**
* Table 16 Defines for SM3_256 Hash Values
*/
export enum SM3_256 // UINT32
{
    /**
    * size of digest in octets
    */
    DIGEST_SIZE = 32,
    
    /**
    * size of hash block in octets
    */
    BLOCK_SIZE = 64,
    
    /**
    * size of the DER in octets
    */
    DER_SIZE = 18
}; // SM3_256

/**
* Architecturally defined constants
*/
export enum ImplementationConstants // uint
{
    OSSL = 1,
    
    LTC = 2,
    
    MSBN = 3,
    
    SYMCRYPT = 4,
    
    HASH_COUNT = 3,
    
    MAX_SYM_KEY_BITS = 256,
    
    MAX_SYM_KEY_BYTES = ((ImplementationConstants.MAX_SYM_KEY_BITS + 7) / 8),
    
    MAX_SYM_BLOCK_SIZE = 16,
    
    MAX_CAP_CC = 0x00000196,
    
    MAX_RSA_KEY_BYTES = 256,
    
    MAX_AES_KEY_BYTES = 32,
    
    MAX_ECC_KEY_BYTES = 48,
    
    LABEL_MAX_BUFFER = 32,
    
    MAX_CAP_DATA = (1024-1-1),
    
    MAX_CAP_ALGS = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_CAP_HANDLES = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_TPM_PROPERTIES = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_PCR_PROPERTIES = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_ECC_CURVES = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_TAGGED_POLICIES = (ImplementationConstants.MAX_CAP_DATA / 1),
    
    MAX_AC_CAPABILITIES = (ImplementationConstants.MAX_CAP_DATA / 1)
}; // ImplementationConstants

/**
* Table 4 Defines for Logic Values
*/
export enum Logic // byte
{
    TRUE = 1,
    
    FALSE = 0,
    
    YES = 1,
    
    NO = 0,
    
    SET = 1,
    
    CLEAR = 0
}; // Logic

/**
* These values are readable with TPM2_GetCapability(). (Ssee 6.13 for the format).
*/
export enum TPM_SPEC // UINT32
{
    /**
    * ASCII 2.0 with null terminator
    */
    FAMILY = 0x322E3000,
    
    /**
    * the level number for the specification
    */
    LEVEL = 0,
    
    /**
    * the version number of the spec (001.46 * 100)
    */
    VERSION = 146,
    
    /**
    * the year of the version
    */
    YEAR = 2017,
    
    /**
    * the day of the year (June 15, 2017)
    */
    DAY_OF_YEAR = 167
}; // TPM_SPEC

/**
* This constant value differentiates TPM-generated structures from non-TPM structures.
*/
export enum TPM_GENERATED // UINT32
{
    /**
    * 0xFF TCG (FF 54 43 4716)
    */
    VALUE = 0xff544347
}; // TPM_GENERATED

/**
* Table 12 lists the command codes and their attributes. The only normative column in this table is the column indicating the command code assigned to a specific command (the "Command Code" column). For all other columns, the command and response tables in TPM 2.0 Part 3 are definitive.
*/
export enum TPM_CC // UINT32
{
    /**
    * Compile variable. May decrease based on implementation.
    */
    FIRST = 0x0000011F,
    
    NV_UndefineSpaceSpecial = 0x0000011F,
    
    EvictControl = 0x00000120,
    
    HierarchyControl = 0x00000121,
    
    NV_UndefineSpace = 0x00000122,
    
    ChangeEPS = 0x00000124,
    
    ChangePPS = 0x00000125,
    
    Clear = 0x00000126,
    
    ClearControl = 0x00000127,
    
    ClockSet = 0x00000128,
    
    HierarchyChangeAuth = 0x00000129,
    
    NV_DefineSpace = 0x0000012A,
    
    PCR_Allocate = 0x0000012B,
    
    PCR_SetAuthPolicy = 0x0000012C,
    
    PP_Commands = 0x0000012D,
    
    SetPrimaryPolicy = 0x0000012E,
    
    FieldUpgradeStart = 0x0000012F,
    
    ClockRateAdjust = 0x00000130,
    
    CreatePrimary = 0x00000131,
    
    NV_GlobalWriteLock = 0x00000132,
    
    GetCommandAuditDigest = 0x00000133,
    
    NV_Increment = 0x00000134,
    
    NV_SetBits = 0x00000135,
    
    NV_Extend = 0x00000136,
    
    NV_Write = 0x00000137,
    
    NV_WriteLock = 0x00000138,
    
    DictionaryAttackLockReset = 0x00000139,
    
    DictionaryAttackParameters = 0x0000013A,
    
    NV_ChangeAuth = 0x0000013B,
    
    /**
    * PCR
    */
    PCR_Event = 0x0000013C,
    
    /**
    * PCR
    */
    PCR_Reset = 0x0000013D,
    
    SequenceComplete = 0x0000013E,
    
    SetAlgorithmSet = 0x0000013F,
    
    SetCommandCodeAuditStatus = 0x00000140,
    
    FieldUpgradeData = 0x00000141,
    
    IncrementalSelfTest = 0x00000142,
    
    SelfTest = 0x00000143,
    
    Startup = 0x00000144,
    
    Shutdown = 0x00000145,
    
    StirRandom = 0x00000146,
    
    ActivateCredential = 0x00000147,
    
    Certify = 0x00000148,
    
    /**
    * Policy
    */
    PolicyNV = 0x00000149,
    
    CertifyCreation = 0x0000014A,
    
    Duplicate = 0x0000014B,
    
    GetTime = 0x0000014C,
    
    GetSessionAuditDigest = 0x0000014D,
    
    NV_Read = 0x0000014E,
    
    NV_ReadLock = 0x0000014F,
    
    ObjectChangeAuth = 0x00000150,
    
    /**
    * Policy
    */
    PolicySecret = 0x00000151,
    
    Rewrap = 0x00000152,
    
    Create = 0x00000153,
    
    ECDH_ZGen = 0x00000154,
    
    /**
    * See NOTE 1
    */
    HMAC = 0x00000155,
    
    /**
    * See NOTE 1
    */
    MAC = 0x00000155,
    
    Import = 0x00000156,
    
    Load = 0x00000157,
    
    Quote = 0x00000158,
    
    RSA_Decrypt = 0x00000159,
    
    /**
    * See NOTE 1
    */
    HMAC_Start = 0x0000015B,
    
    /**
    * See NOTE 1
    */
    MAC_Start = 0x0000015B,
    
    SequenceUpdate = 0x0000015C,
    
    Sign = 0x0000015D,
    
    Unseal = 0x0000015E,
    
    /**
    * Policy
    */
    PolicySigned = 0x00000160,
    
    /**
    * Context
    */
    ContextLoad = 0x00000161,
    
    /**
    * Context
    */
    ContextSave = 0x00000162,
    
    ECDH_KeyGen = 0x00000163,
    
    EncryptDecrypt = 0x00000164,
    
    /**
    * Context
    */
    FlushContext = 0x00000165,
    
    LoadExternal = 0x00000167,
    
    MakeCredential = 0x00000168,
    
    /**
    * NV
    */
    NV_ReadPublic = 0x00000169,
    
    /**
    * Policy
    */
    PolicyAuthorize = 0x0000016A,
    
    /**
    * Policy
    */
    PolicyAuthValue = 0x0000016B,
    
    /**
    * Policy
    */
    PolicyCommandCode = 0x0000016C,
    
    /**
    * Policy
    */
    PolicyCounterTimer = 0x0000016D,
    
    /**
    * Policy
    */
    PolicyCpHash = 0x0000016E,
    
    /**
    * Policy
    */
    PolicyLocality = 0x0000016F,
    
    /**
    * Policy
    */
    PolicyNameHash = 0x00000170,
    
    /**
    * Policy
    */
    PolicyOR = 0x00000171,
    
    /**
    * Policy
    */
    PolicyTicket = 0x00000172,
    
    ReadPublic = 0x00000173,
    
    RSA_Encrypt = 0x00000174,
    
    StartAuthSession = 0x00000176,
    
    VerifySignature = 0x00000177,
    
    ECC_Parameters = 0x00000178,
    
    FirmwareRead = 0x00000179,
    
    GetCapability = 0x0000017A,
    
    GetRandom = 0x0000017B,
    
    GetTestResult = 0x0000017C,
    
    Hash = 0x0000017D,
    
    /**
    * PCR
    */
    PCR_Read = 0x0000017E,
    
    /**
    * Policy
    */
    PolicyPCR = 0x0000017F,
    
    PolicyRestart = 0x00000180,
    
    ReadClock = 0x00000181,
    
    PCR_Extend = 0x00000182,
    
    PCR_SetAuthValue = 0x00000183,
    
    NV_Certify = 0x00000184,
    
    EventSequenceComplete = 0x00000185,
    
    HashSequenceStart = 0x00000186,
    
    /**
    * Policy
    */
    PolicyPhysicalPresence = 0x00000187,
    
    /**
    * Policy
    */
    PolicyDuplicationSelect = 0x00000188,
    
    /**
    * Policy
    */
    PolicyGetDigest = 0x00000189,
    
    TestParms = 0x0000018A,
    
    Commit = 0x0000018B,
    
    /**
    * Policy
    */
    PolicyPassword = 0x0000018C,
    
    ZGen_2Phase = 0x0000018D,
    
    EC_Ephemeral = 0x0000018E,
    
    /**
    * Policy
    */
    PolicyNvWritten = 0x0000018F,
    
    /**
    * Policy
    */
    PolicyTemplate = 0x00000190,
    
    CreateLoaded = 0x00000191,
    
    /**
    * Policy
    */
    PolicyAuthorizeNV = 0x00000192,
    
    EncryptDecrypt2 = 0x00000193,
    
    AC_GetCapability = 0x00000194,
    
    AC_Send = 0x00000195,
    
    /**
    * Policy
    */
    Policy_AC_SendSelect = 0x00000196,
    
    /**
    * Compile variable. May increase based on implementation.
    */
    LAST = 0x00000196,
    
    CC_VEND = 0x20000000,
    
    /**
    * Used for testing of command dispatch
    */
    Vendor_TCG_Test = TPM_CC.CC_VEND+0x0000
}; // TPM_CC

/**
* In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM 2.0 response code. See Response Code Details in TPM 2.0 Part 1.
*/
export enum TPM_RC // UINT32
{
    SUCCESS = 0x000,
    
    /**
    * defined for compatibility with TPM 1.2
    */
    BAD_TAG = 0x01E,
    
    /**
    * set for all format 0 response codes
    */
    RC_VER1 = 0x100,
    
    /**
    * TPM not initialized by TPM2_Startup or already initialized
    */
    INITIALIZE = TPM_RC.RC_VER1 + 0x000,
    
    /**
    * commands not being accepted because of a TPM failure NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
    */
    FAILURE = TPM_RC.RC_VER1 + 0x001,
    
    /**
    * improper use of a sequence handle
    */
    SEQUENCE = TPM_RC.RC_VER1 + 0x003,
    
    /**
    * not currently used
    */
    PRIVATE = TPM_RC.RC_VER1 + 0x00B,
    
    /**
    * not currently used
    */
    HMAC = TPM_RC.RC_VER1 + 0x019,
    
    /**
    * the command is disabled
    */
    DISABLED = TPM_RC.RC_VER1 + 0x020,
    
    /**
    * command failed because audit sequence required exclusivity
    */
    EXCLUSIVE = TPM_RC.RC_VER1 + 0x021,
    
    /**
    * authorization handle is not correct for command
    */
    AUTH_TYPE = TPM_RC.RC_VER1 + 0x024,
    
    /**
    * command requires an authorization session for handle and it is not present.
    */
    AUTH_MISSING = TPM_RC.RC_VER1 + 0x025,
    
    /**
    * policy failure in math operation or an invalid authPolicy value
    */
    POLICY = TPM_RC.RC_VER1 + 0x026,
    
    /**
    * PCR check fail
    */
    PCR = TPM_RC.RC_VER1 + 0x027,
    
    /**
    * PCR have changed since checked.
    */
    PCR_CHANGED = TPM_RC.RC_VER1 + 0x028,
    
    /**
    * for all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the TPM is not in field upgrade mode
    */
    UPGRADE = TPM_RC.RC_VER1 + 0x02D,
    
    /**
    * context ID counter is at maximum.
    */
    TOO_MANY_CONTEXTS = TPM_RC.RC_VER1 + 0x02E,
    
    /**
    * authValue or authPolicy is not available for selected entity.
    */
    AUTH_UNAVAILABLE = TPM_RC.RC_VER1 + 0x02F,
    
    /**
    * a _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
    */
    REBOOT = TPM_RC.RC_VER1 + 0x030,
    
    /**
    * the protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.
    */
    UNBALANCED = TPM_RC.RC_VER1 + 0x031,
    
    /**
    * command commandSize value is inconsistent with contents of the command buffer; either the size is not the same as the octets loaded by the hardware interface layer or the value is not large enough to hold a command header
    */
    COMMAND_SIZE = TPM_RC.RC_VER1 + 0x042,
    
    /**
    * command code not supported
    */
    COMMAND_CODE = TPM_RC.RC_VER1 + 0x043,
    
    /**
    * the value of authorizationSize is out of range or the number of octets in the Authorization Area is greater than required
    */
    AUTHSIZE = TPM_RC.RC_VER1 + 0x044,
    
    /**
    * use of an authorization session with a context command or another command that cannot have an authorization session.
    */
    AUTH_CONTEXT = TPM_RC.RC_VER1 + 0x045,
    
    /**
    * NV offset+size is out of range.
    */
    NV_RANGE = TPM_RC.RC_VER1 + 0x046,
    
    /**
    * Requested allocation size is larger than allowed.
    */
    NV_SIZE = TPM_RC.RC_VER1 + 0x047,
    
    /**
    * NV access locked.
    */
    NV_LOCKED = TPM_RC.RC_VER1 + 0x048,
    
    /**
    * NV access authorization fails in command actions (this failure does not affect lockout.action)
    */
    NV_AUTHORIZATION = TPM_RC.RC_VER1 + 0x049,
    
    /**
    * an NV Index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored
    */
    NV_UNINITIALIZED = TPM_RC.RC_VER1 + 0x04A,
    
    /**
    * insufficient space for NV allocation
    */
    NV_SPACE = TPM_RC.RC_VER1 + 0x04B,
    
    /**
    * NV Index or persistent object already defined
    */
    NV_DEFINED = TPM_RC.RC_VER1 + 0x04C,
    
    /**
    * context in TPM2_ContextLoad() is not valid
    */
    BAD_CONTEXT = TPM_RC.RC_VER1 + 0x050,
    
    /**
    * cpHash value already set or not correct for use
    */
    CPHASH = TPM_RC.RC_VER1 + 0x051,
    
    /**
    * handle for parent is not a valid parent
    */
    PARENT = TPM_RC.RC_VER1 + 0x052,
    
    /**
    * some function needs testing.
    */
    NEEDS_TEST = TPM_RC.RC_VER1 + 0x053,
    
    /**
    * returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.
    */
    NO_RESULT = TPM_RC.RC_VER1 + 0x054,
    
    /**
    * the sensitive area did not unmarshal correctly after decryption this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred
    */
    SENSITIVE = TPM_RC.RC_VER1 + 0x055,
    
    /**
    * largest version 1 code that is not a warning
    */
    RC_MAX_FM0 = TPM_RC.RC_VER1 + 0x07F,
    
    /**
    * This bit is SET in all format 1 response codes The codes in this group may have a value added to them to indicate the handle, session, or parameter to which they apply.
    */
    RC_FMT1 = 0x080,
    
    /**
    * asymmetric algorithm not supported or not correct
    */
    ASYMMETRIC = TPM_RC.RC_FMT1 + 0x001,
    
    /**
    * inconsistent attributes
    */
    ATTRIBUTES = TPM_RC.RC_FMT1 + 0x002,
    
    /**
    * hash algorithm not supported or not appropriate
    */
    HASH = TPM_RC.RC_FMT1 + 0x003,
    
    /**
    * value is out of range or is not correct for the context
    */
    VALUE = TPM_RC.RC_FMT1 + 0x004,
    
    /**
    * hierarchy is not enabled or is not correct for the use
    */
    HIERARCHY = TPM_RC.RC_FMT1 + 0x005,
    
    /**
    * key size is not supported
    */
    KEY_SIZE = TPM_RC.RC_FMT1 + 0x007,
    
    /**
    * mask generation function not supported
    */
    MGF = TPM_RC.RC_FMT1 + 0x008,
    
    /**
    * mode of operation not supported
    */
    MODE = TPM_RC.RC_FMT1 + 0x009,
    
    /**
    * the type of the value is not appropriate for the use
    */
    TYPE = TPM_RC.RC_FMT1 + 0x00A,
    
    /**
    * the handle is not correct for the use
    */
    HANDLE = TPM_RC.RC_FMT1 + 0x00B,
    
    /**
    * unsupported key derivation function or function not appropriate for use
    */
    KDF = TPM_RC.RC_FMT1 + 0x00C,
    
    /**
    * value was out of allowed range.
    */
    RANGE = TPM_RC.RC_FMT1 + 0x00D,
    
    /**
    * the authorization HMAC check failed and DA counter incremented
    */
    AUTH_FAIL = TPM_RC.RC_FMT1 + 0x00E,
    
    /**
    * invalid nonce size or nonce value mismatch
    */
    NONCE = TPM_RC.RC_FMT1 + 0x00F,
    
    /**
    * authorization requires assertion of PP
    */
    PP = TPM_RC.RC_FMT1 + 0x010,
    
    /**
    * unsupported or incompatible scheme
    */
    SCHEME = TPM_RC.RC_FMT1 + 0x012,
    
    /**
    * structure is the wrong size
    */
    SIZE = TPM_RC.RC_FMT1 + 0x015,
    
    /**
    * unsupported symmetric algorithm or key size, or not appropriate for instance
    */
    SYMMETRIC = TPM_RC.RC_FMT1 + 0x016,
    
    /**
    * incorrect structure tag
    */
    TAG = TPM_RC.RC_FMT1 + 0x017,
    
    /**
    * union selector is incorrect
    */
    SELECTOR = TPM_RC.RC_FMT1 + 0x018,
    
    /**
    * the TPM was unable to unmarshal a value because there were not enough octets in the input buffer
    */
    INSUFFICIENT = TPM_RC.RC_FMT1 + 0x01A,
    
    /**
    * the signature is not valid
    */
    SIGNATURE = TPM_RC.RC_FMT1 + 0x01B,
    
    /**
    * key fields are not compatible with the selected use
    */
    KEY = TPM_RC.RC_FMT1 + 0x01C,
    
    /**
    * a policy check failed
    */
    POLICY_FAIL = TPM_RC.RC_FMT1 + 0x01D,
    
    /**
    * integrity check failed
    */
    INTEGRITY = TPM_RC.RC_FMT1 + 0x01F,
    
    /**
    * invalid ticket
    */
    TICKET = TPM_RC.RC_FMT1 + 0x020,
    
    /**
    * authorization failure without DA implications
    */
    BAD_AUTH = TPM_RC.RC_FMT1 + 0x022,
    
    /**
    * the policy has expired
    */
    EXPIRED = TPM_RC.RC_FMT1 + 0x023,
    
    /**
    * the commandCode in the policy is not the commandCode of the command or the command code in a policy command references a command that is not implemented
    */
    POLICY_CC = TPM_RC.RC_FMT1 + 0x024,
    
    /**
    * public and sensitive portions of an object are not cryptographically bound
    */
    BINDING = TPM_RC.RC_FMT1 + 0x025,
    
    /**
    * curve not supported
    */
    CURVE = TPM_RC.RC_FMT1 + 0x026,
    
    /**
    * point is not on the required curve.
    */
    ECC_POINT = TPM_RC.RC_FMT1 + 0x027,
    
    /**
    * set for warning response codes
    */
    RC_WARN = 0x900,
    
    /**
    * gap for context ID is too large
    */
    CONTEXT_GAP = TPM_RC.RC_WARN + 0x001,
    
    /**
    * out of memory for object contexts
    */
    OBJECT_MEMORY = TPM_RC.RC_WARN + 0x002,
    
    /**
    * out of memory for session contexts
    */
    SESSION_MEMORY = TPM_RC.RC_WARN + 0x003,
    
    /**
    * out of shared object/session memory or need space for internal operations
    */
    MEMORY = TPM_RC.RC_WARN + 0x004,
    
    /**
    * out of session handles a session must be flushed before a new session may be created
    */
    SESSION_HANDLES = TPM_RC.RC_WARN + 0x005,
    
    /**
    * out of object handles the handle space for objects is depleted and a reboot is required NOTE 1 This cannot occur on the reference implementation. NOTE 2 There is no reason why an implementation would implement a design that would deplete handle space. Platform specifications are encouraged to forbid it.
    */
    OBJECT_HANDLES = TPM_RC.RC_WARN + 0x006,
    
    /**
    * bad locality
    */
    LOCALITY = TPM_RC.RC_WARN + 0x007,
    
    /**
    * the TPM has suspended operation on the command; forward progress was made and the command may be retried See TPM 2.0 Part 1, Multi-tasking. NOTE This cannot occur on the reference implementation.
    */
    YIELDED = TPM_RC.RC_WARN + 0x008,
    
    /**
    * the command was canceled
    */
    CANCELED = TPM_RC.RC_WARN + 0x009,
    
    /**
    * TPM is performing self-tests
    */
    TESTING = TPM_RC.RC_WARN + 0x00A,
    
    /**
    * the 1st handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H0 = TPM_RC.RC_WARN + 0x010,
    
    /**
    * the 2nd handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H1 = TPM_RC.RC_WARN + 0x011,
    
    /**
    * the 3rd handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H2 = TPM_RC.RC_WARN + 0x012,
    
    /**
    * the 4th handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H3 = TPM_RC.RC_WARN + 0x013,
    
    /**
    * the 5th handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H4 = TPM_RC.RC_WARN + 0x014,
    
    /**
    * the 6th handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H5 = TPM_RC.RC_WARN + 0x015,
    
    /**
    * the 7th handle in the handle area references a transient object or session that is not loaded
    */
    REFERENCE_H6 = TPM_RC.RC_WARN + 0x016,
    
    /**
    * the 1st authorization session handle references a session that is not loaded
    */
    REFERENCE_S0 = TPM_RC.RC_WARN + 0x018,
    
    /**
    * the 2nd authorization session handle references a session that is not loaded
    */
    REFERENCE_S1 = TPM_RC.RC_WARN + 0x019,
    
    /**
    * the 3rd authorization session handle references a session that is not loaded
    */
    REFERENCE_S2 = TPM_RC.RC_WARN + 0x01A,
    
    /**
    * the 4th authorization session handle references a session that is not loaded
    */
    REFERENCE_S3 = TPM_RC.RC_WARN + 0x01B,
    
    /**
    * the 5th session handle references a session that is not loaded
    */
    REFERENCE_S4 = TPM_RC.RC_WARN + 0x01C,
    
    /**
    * the 6th session handle references a session that is not loaded
    */
    REFERENCE_S5 = TPM_RC.RC_WARN + 0x01D,
    
    /**
    * the 7th authorization session handle references a session that is not loaded
    */
    REFERENCE_S6 = TPM_RC.RC_WARN + 0x01E,
    
    /**
    * the TPM is rate-limiting accesses to prevent wearout of NV
    */
    NV_RATE = TPM_RC.RC_WARN + 0x020,
    
    /**
    * authorizations for objects subject to DA protection are not allowed at this time because the TPM is in DA lockout mode
    */
    LOCKOUT = TPM_RC.RC_WARN + 0x021,
    
    /**
    * the TPM was not able to start the command
    */
    RETRY = TPM_RC.RC_WARN + 0x022,
    
    /**
    * the command may require writing of NV and NV is not current accessible
    */
    NV_UNAVAILABLE = TPM_RC.RC_WARN + 0x023,
    
    /**
    * this value is reserved and shall not be returned by the TPM
    */
    NOT_USED = TPM_RC.RC_WARN + 0x7F,
    
    /**
    * add to a parameter-related error
    */
    P = 0x040,
    
    /**
    * add to a session-related error
    */
    S = 0x800,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _1 = 0x100,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _2 = 0x200,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _3 = 0x300,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _4 = 0x400,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _5 = 0x500,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _6 = 0x600,
    
    /**
    * add to a parameter-, handle-, or session-related error
    */
    _7 = 0x700,
    
    /**
    * add to a parameter-related error
    */
    _8 = 0x800,
    
    /**
    * add to a parameter-related error
    */
    _9 = 0x900,
    
    /**
    * add to a parameter-related error
    */
    A = 0xA00,
    
    /**
    * add to a parameter-related error
    */
    B = 0xB00,
    
    /**
    * add to a parameter-related error
    */
    C = 0xC00,
    
    /**
    * add to a parameter-related error
    */
    D = 0xD00,
    
    /**
    * add to a parameter-related error
    */
    E = 0xE00,
    
    /**
    * add to a parameter-related error
    */
    F = 0xF00,
    
    /**
    * number mask
    */
    N_MASK = 0xF00,
    
    /**
    * Response buffer returned by the TPM is too short
    */
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001,
    
    /**
    * Too old TCP server version
    */
    TSS_TCP_SERVER_TOO_OLD = 0x40280002,
    
    /**
    * Bad ack from the TCP end point
    */
    TSS_TCP_BAD_ACK = 0x40280003,
    
    /**
    * Wrong length of the response buffer returned by the TPM
    */
    TSS_TCP_BAD_RESP_LEN = 0x40280004,
    
    /**
    * TPM2_Startup returned unexpected response code
    */
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005,
    
    /**
    * Invalid size tag in the TPM response TCP packet
    */
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006,
    
    /**
    * Sending data to TPM failed
    */
    TSS_SEND_OP_FAILED = 0x40280011,
    
    /**
    * Response buffer returned by the TPM is too short
    */
    TSS_RESP_BUF_TOO_SHORT = 0x40280021,
    
    /**
    * Invalid tag in the response buffer returned by the TPM
    */
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022,
    
    /**
    * Windows TBS error TPM_E_COMMAND_BLOCKED
    */
    TBS_COMMAND_BLOCKED = 0x80280400,
    
    /**
    * Windows TBS error TPM_E_INVALID_HANDLE
    */
    TBS_INVALID_HANDLE = 0x80280401,
    
    /**
    * Windows TBS error TPM_E_DUPLICATE_VHANDLE
    */
    TBS_DUPLICATE_V_HANDLE = 0x80280402,
    
    /**
    * Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED
    */
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403,
    
    /**
    * Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
    */
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404,
    
    /**
    * Windows TBS returned success but empty response buffer
    */
    TBS_UNKNOWN_ERROR = 0x80284000,
    
    /**
    * Windows TBS error TBS_E_INTERNAL_ERROR
    */
    TBS_INTERNAL_ERROR = 0x80284001,
    
    /**
    * Windows TBS error TBS_E_BAD_PARAMETER
    */
    TBS_BAD_PARAMETER = 0x80284002,
    
    /**
    * Windows TBS error TBS_E_INVALID_OUTPUT_POINTER
    */
    TBS_INVALID_OUTPUT_POINTER = 0x80284003,
    
    /**
    * Windows TBS error TBS_E_INVALID_CONTEXT
    */
    TBS_INVALID_CONTEXT = 0x80284004,
    
    /**
    * Windows TBS error TBS_E_INSUFFICIENT_BUFFER
    */
    TBS_INSUFFICIENT_BUFFER = 0x80284005,
    
    /**
    * Windows TBS error TBS_E_IOERROR
    */
    TBS_IO_ERROR = 0x80284006,
    
    /**
    * Windows TBS error TBS_E_INVALID_CONTEXT_PARAM
    */
    TBS_INVALID_CONTEXT_PARAM = 0x80284007,
    
    /**
    * Windows TBS error TBS_E_SERVICE_NOT_RUNNING
    */
    TBS_SERVICE_NOT_RUNNING = 0x80284008,
    
    /**
    * Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS
    */
    TBS_TOO_MANY_CONTEXTS = 0x80284009,
    
    /**
    * Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES
    */
    TBS_TOO_MANY_RESOURCES = 0x8028400A,
    
    /**
    * Windows TBS error TBS_E_SERVICE_START_PENDING
    */
    TBS_SERVICE_START_PENDING = 0x8028400B,
    
    /**
    * Windows TBS error TBS_E_PPI_NOT_SUPPORTED
    */
    TBS_PPI_NOT_SUPPORTED = 0x8028400C,
    
    /**
    * Windows TBS error TBS_E_COMMAND_CANCELED
    */
    TBS_COMMAND_CANCELED = 0x8028400D,
    
    /**
    * Windows TBS error TBS_E_BUFFER_TOO_LARGE
    */
    TBS_BUFFER_TOO_LARGE = 0x8028400E,
    
    /**
    * Windows TBS error TBS_E_TPM_NOT_FOUND
    */
    TBS_NOT_FOUND = 0x8028400F,
    
    /**
    * Windows TBS error TBS_E_SERVICE_DISABLED
    */
    TBS_SERVICE_DISABLED = 0x80284010,
    
    /**
    * Windows TBS error TBS_E_ACCESS_DENIED
    */
    TBS_ACCESS_DENIED = 0x80284012,
    
    /**
    * Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED
    */
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014,
    
    /**
    * Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND
    */
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
}; // TPM_RC

/**
* A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal oscillator is divided. A change to the divider will change the rate at which Clock and Time change.
*/
export enum TPM_CLOCK_ADJUST // INT8
{
    /**
    * Slow the Clock update rate by one coarse adjustment step.
    */
    COARSE_SLOWER = -3,
    
    /**
    * Slow the Clock update rate by one medium adjustment step.
    */
    MEDIUM_SLOWER = -2,
    
    /**
    * Slow the Clock update rate by one fine adjustment step.
    */
    FINE_SLOWER = -1,
    
    /**
    * No change to the Clock update rate.
    */
    NO_CHANGE = 0,
    
    /**
    * Speed the Clock update rate by one fine adjustment step.
    */
    FINE_FASTER = 1,
    
    /**
    * Speed the Clock update rate by one medium adjustment step.
    */
    MEDIUM_FASTER = 2,
    
    /**
    * Speed the Clock update rate by one coarse adjustment step.
    */
    COARSE_FASTER = 3
}; // TPM_CLOCK_ADJUST

/**
* Table 18 Definition of (UINT16) TPM_EO Constants (IN/OUT)
*/
export enum TPM_EO // UINT16
{
    /**
    * A = B
    */
    EQ = 0x0000,
    
    /**
    * A B
    */
    NEQ = 0x0001,
    
    /**
    * A ) B signed
    */
    SIGNED_GT = 0x0002,
    
    /**
    * A ) B unsigned
    */
    UNSIGNED_GT = 0x0003,
    
    /**
    * A ( B signed
    */
    SIGNED_LT = 0x0004,
    
    /**
    * A ( B unsigned
    */
    UNSIGNED_LT = 0x0005,
    
    /**
    * A B signed
    */
    SIGNED_GE = 0x0006,
    
    /**
    * A B unsigned
    */
    UNSIGNED_GE = 0x0007,
    
    /**
    * A B signed
    */
    SIGNED_LE = 0x0008,
    
    /**
    * A B unsigned
    */
    UNSIGNED_LE = 0x0009,
    
    /**
    * All bits SET in B are SET in A. ((A AND B)=B)
    */
    BITSET = 0x000A,
    
    /**
    * All bits SET in B are CLEAR in A. ((A AND B)=0)
    */
    BITCLEAR = 0x000B
}; // TPM_EO

/**
* Structure tags are used to disambiguate structures. They are 16-bit values with the most significant bit SET so that they do not overlap TPM_ALG_ID values. A single exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this specification. This value is used when the TPM is compatible with a previous TPM specification and the TPM cannot determine which family of response code to return because the command tag is not valid.
*/
export enum TPM_ST // UINT16
{
    /**
    * tag value for a response; used when there is an error in the tag. This is also the value returned from a TPM 1.2 when an error occurs. This value is used in this specification because an error in the command tag may prevent determination of the family. When this tag is used in the response, the response code will be TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code for TPM_BADTAG. NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my return the old value instead of the new value.
    */
    RSP_COMMAND = 0x00C4,
    
    /**
    * no structure type specified
    */
    NULL = 0X8000,
    
    /**
    * tag value for a command/response for a command defined in this specification; indicating that the command/response has no attached sessions and no authorizationSize/parameterSize value is present If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall have this value.
    */
    NO_SESSIONS = 0x8001,
    
    /**
    * tag value for a command/response for a command defined in this specification; indicating that the command/response has one or more attached sessions and the authorizationSize/parameterSize field is present
    */
    SESSIONS = 0x8002,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_NV = 0x8014,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_COMMAND_AUDIT = 0x8015,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_SESSION_AUDIT = 0x8016,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_CERTIFY = 0x8017,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_QUOTE = 0x8018,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_TIME = 0x8019,
    
    /**
    * tag for an attestation structure
    */
    ATTEST_CREATION = 0x801A,
    
    /**
    * tag for a ticket type
    */
    CREATION = 0x8021,
    
    /**
    * tag for a ticket type
    */
    VERIFIED = 0x8022,
    
    /**
    * tag for a ticket type
    */
    AUTH_SECRET = 0x8023,
    
    /**
    * tag for a ticket type
    */
    HASHCHECK = 0x8024,
    
    /**
    * tag for a ticket type
    */
    AUTH_SIGNED = 0x8025,
    
    /**
    * tag for a structure describing a Field Upgrade Policy
    */
    FU_MANIFEST = 0x8029
}; // TPM_ST

/**
* These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The defined startup sequences are:
*/
export enum TPM_SU // UINT16
{
    /**
    * on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Reset). on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
    */
    CLEAR = 0x0000,
    
    /**
    * on TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save state required for an orderly startup (TPM Restart or TPM Resume) on TPM2_Startup(), indicates that the TPM should restore the state saved by TPM2_Shutdown(TPM_SU_STATE)
    */
    STATE = 0x0001
}; // TPM_SU

/**
* This type is used in TPM2_StartAuthSession() to indicate the type of the session to be created.
*/
export enum TPM_SE // UINT8
{
    HMAC = 0x00,
    
    POLICY = 0x01,
    
    /**
    * The policy session is being used to compute the policyHash and not for command authorization. This setting modifies some policy commands and prevents session from being used to authorize a command.
    */
    TRIAL = 0x03
}; // TPM_SE

/**
* The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to be returned. The format of the response varies according to the type of the value.
*/
export enum TPM_CAP // UINT32
{
    FIRST = 0x00000000,
    
    /**
    * TPML_ALG_PROPERTY
    */
    ALGS = 0x00000000,
    
    /**
    * TPML_HANDLE
    */
    HANDLES = 0x00000001,
    
    /**
    * TPML_CCA
    */
    COMMANDS = 0x00000002,
    
    /**
    * TPML_CC
    */
    PP_COMMANDS = 0x00000003,
    
    /**
    * TPML_CC
    */
    AUDIT_COMMANDS = 0x00000004,
    
    /**
    * TPML_PCR_SELECTION
    */
    PCRS = 0x00000005,
    
    /**
    * TPML_TAGGED_TPM_PROPERTY
    */
    TPM_PROPERTIES = 0x00000006,
    
    /**
    * TPML_TAGGED_PCR_PROPERTY
    */
    PCR_PROPERTIES = 0x00000007,
    
    /**
    * TPML_ECC_CURVE
    */
    ECC_CURVES = 0x00000008,
    
    /**
    * TPML_TAGGED_POLICY
    */
    AUTH_POLICIES = 0x00000009,
    
    LAST = 0x00000009,
    
    /**
    * manufacturer-specific values
    */
    VENDOR_PROPERTY = 0x00000100
}; // TPM_CAP

/**
* The TPM_PT constants are used in TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
*/
export enum TPM_PT // UINT32
{
    /**
    * indicates no property type
    */
    NONE = 0x00000000,
    
    /**
    * The number of properties in each group. NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
    */
    PT_GROUP = 0x00000100,
    
    /**
    * the group of fixed properties returned as TPMS_TAGGED_PROPERTY The values in this group are only changed due to a firmware change in the TPM.
    */
    PT_FIXED = TPM_PT.PT_GROUP * 1,
    
    /**
    * a 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)
    */
    FAMILY_INDICATOR = TPM_PT.PT_FIXED + 0,
    
    /**
    * the level of the specification NOTE 1 For this specification, the level is zero. NOTE 2 The level is on the title page of the specification.
    */
    LEVEL = TPM_PT.PT_FIXED + 1,
    
    /**
    * the specification Revision times 100 EXAMPLE Revision 01.01 would have a value of 101. NOTE The Revision value is on the title page of the specification.
    */
    REVISION = TPM_PT.PT_FIXED + 2,
    
    /**
    * the specification day of year using TCG calendar EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16). NOTE The specification date is on the title page of the specification or errata. S(see 6.1).
    */
    DAY_OF_YEAR = TPM_PT.PT_FIXED + 3,
    
    /**
    * the specification year using the CE EXAMPLE The year 2010 has a value of 000007DA16. NOTE The specification date is on the title page of the specification or errata. S(see 6.1).
    */
    YEAR = TPM_PT.PT_FIXED + 4,
    
    /**
    * the vendor ID unique to each TPM manufacturer
    */
    MANUFACTURER = TPM_PT.PT_FIXED + 5,
    
    /**
    * the first four characters of the vendor ID string NOTE When the vendor string is fewer than 16 octets, the additional property values do not have to be present. A vendor string of 4 octets can be represented in one 32-bit value and no null terminating character is required.
    */
    VENDOR_STRING_1 = TPM_PT.PT_FIXED + 6,
    
    /**
    * the second four characters of the vendor ID string
    */
    VENDOR_STRING_2 = TPM_PT.PT_FIXED + 7,
    
    /**
    * the third four characters of the vendor ID string
    */
    VENDOR_STRING_3 = TPM_PT.PT_FIXED + 8,
    
    /**
    * the fourth four characters of the vendor ID sting
    */
    VENDOR_STRING_4 = TPM_PT.PT_FIXED + 9,
    
    /**
    * vendor-defined value indicating the TPM model
    */
    VENDOR_TPM_TYPE = TPM_PT.PT_FIXED + 10,
    
    /**
    * the most-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.8.
    */
    FIRMWARE_VERSION_1 = TPM_PT.PT_FIXED + 11,
    
    /**
    * the least-significant 32 bits of a TPM vendor-specific value indicating the version number of the firmware. See 10.12.2 and 10.12.8.
    */
    FIRMWARE_VERSION_2 = TPM_PT.PT_FIXED + 12,
    
    /**
    * the maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)
    */
    INPUT_BUFFER = TPM_PT.PT_FIXED + 13,
    
    /**
    * the minimum number of transient objects that can be held in TPM RAM NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    */
    HR_TRANSIENT_MIN = TPM_PT.PT_FIXED + 14,
    
    /**
    * the minimum number of persistent objects that can be held in TPM NV memory NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    */
    HR_PERSISTENT_MIN = TPM_PT.PT_FIXED + 15,
    
    /**
    * the minimum number of authorization sessions that can be held in TPM RAM NOTE This minimum shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    */
    HR_LOADED_MIN = TPM_PT.PT_FIXED + 16,
    
    /**
    * the number of authorization sessions that may be active at a time A session is active when it has a context associated with its handle. The context may either be in TPM RAM or be context saved. NOTE This value shall be no less than the minimum value required by the platform-specific specification to which the TPM is built.
    */
    ACTIVE_SESSIONS_MAX = TPM_PT.PT_FIXED + 17,
    
    /**
    * the number of PCR implemented NOTE This number is determined by the defined attributes, not the number of PCR that are populated.
    */
    PCR_COUNT = TPM_PT.PT_FIXED + 18,
    
    /**
    * the minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect NOTE This value is not determined by the number of PCR implemented but by the number of PCR required by the platform-specific specification with which the TPM is compliant or by the implementer if not adhering to a platform-specific specification.
    */
    PCR_SELECT_MIN = TPM_PT.PT_FIXED + 19,
    
    /**
    * the maximum allowed difference (unsigned) between the contextID values of two saved session contexts This value shall be 2n-1, where n is at least 16.
    */
    CONTEXT_GAP_MAX = TPM_PT.PT_FIXED + 20,
    
    /**
    * the maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute NOTE It is allowed for this value to be larger than the number of NV Indexes that can be defined. This would be indicative of a TPM implementation that did not use different implementation technology for different NV Index types.
    */
    NV_COUNTERS_MAX = TPM_PT.PT_FIXED + 22,
    
    /**
    * the maximum size of an NV Index data area
    */
    NV_INDEX_MAX = TPM_PT.PT_FIXED + 23,
    
    /**
    * a TPMA_MEMORY indicating the memory management method for the TPM
    */
    MEMORY = TPM_PT.PT_FIXED + 24,
    
    /**
    * interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV
    */
    CLOCK_UPDATE = TPM_PT.PT_FIXED + 25,
    
    /**
    * the algorithm used for the integrity HMAC on saved contexts and for hashing the fuData of TPM2_FirmwareRead()
    */
    CONTEXT_HASH = TPM_PT.PT_FIXED + 26,
    
    /**
    * TPM_ALG_ID, the algorithm used for encryption of saved contexts
    */
    CONTEXT_SYM = TPM_PT.PT_FIXED + 27,
    
    /**
    * TPM_KEY_BITS, the size of the key used for encryption of saved contexts
    */
    CONTEXT_SYM_SIZE = TPM_PT.PT_FIXED + 28,
    
    /**
    * the modulus - 1 of the count for NV update of an orderly counter The returned value is MAX_ORDERLY_COUNT. This will have a value of 2N 1 where 1 N 32 NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and TPMA_NV_ORDERLY SET. NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on the next increment.
    */
    ORDERLY_COUNT = TPM_PT.PT_FIXED + 29,
    
    /**
    * the maximum value for commandSize in a command
    */
    MAX_COMMAND_SIZE = TPM_PT.PT_FIXED + 30,
    
    /**
    * the maximum value for responseSize in a response
    */
    MAX_RESPONSE_SIZE = TPM_PT.PT_FIXED + 31,
    
    /**
    * the maximum size of a digest that can be produced by the TPM
    */
    MAX_DIGEST = TPM_PT.PT_FIXED + 32,
    
    /**
    * the maximum size of an object context that will be returned by TPM2_ContextSave
    */
    MAX_OBJECT_CONTEXT = TPM_PT.PT_FIXED + 33,
    
    /**
    * the maximum size of a session context that will be returned by TPM2_ContextSave
    */
    MAX_SESSION_CONTEXT = TPM_PT.PT_FIXED + 34,
    
    /**
    * platform-specific family (a TPM_PS value)(see Table 25) NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant platform-specific specification. In the reference implementation, all of these values are 0.
    */
    PS_FAMILY_INDICATOR = TPM_PT.PT_FIXED + 35,
    
    /**
    * the level of the platform-specific specification
    */
    PS_LEVEL = TPM_PT.PT_FIXED + 36,
    
    /**
    * the specification Revision times 100 for the platform-specific specification EXAMPLE Revision 01.01 would have a value of 101.
    */
    PS_REVISION = TPM_PT.PT_FIXED + 37,
    
    /**
    * the platform-specific TPM specification day of year using TCG calendar EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
    */
    PS_DAY_OF_YEAR = TPM_PT.PT_FIXED + 38,
    
    /**
    * the platform-specific TPM specification year using the CE EXAMPLE The year 2010 has a value of 000007DA16.
    */
    PS_YEAR = TPM_PT.PT_FIXED + 39,
    
    /**
    * the number of split signing operations supported by the TPM
    */
    SPLIT_MAX = TPM_PT.PT_FIXED + 40,
    
    /**
    * total number of commands implemented in the TPM
    */
    TOTAL_COMMANDS = TPM_PT.PT_FIXED + 41,
    
    /**
    * number of commands from the TPM library that are implemented
    */
    LIBRARY_COMMANDS = TPM_PT.PT_FIXED + 42,
    
    /**
    * number of vendor commands that are implemented
    */
    VENDOR_COMMANDS = TPM_PT.PT_FIXED + 43,
    
    /**
    * the maximum data size in one NV write or NV read command
    */
    NV_BUFFER_MAX = TPM_PT.PT_FIXED + 44,
    
    /**
    * a TPMA_MODES value, indicating that the TPM is designed for these modes.
    */
    MODES = TPM_PT.PT_FIXED + 45,
    
    /**
    * the maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().
    */
    MAX_CAP_BUFFER = TPM_PT.PT_FIXED + 46,
    
    /**
    * the group of variable properties returned as TPMS_TAGGED_PROPERTY The properties in this group change because of a Protected Capability other than a firmware update. The values are not necessarily persistent across all power transitions.
    */
    PT_VAR = TPM_PT.PT_GROUP * 2,
    
    /**
    * TPMA_PERMANENT
    */
    PERMANENT = TPM_PT.PT_VAR + 0,
    
    /**
    * TPMA_STARTUP_CLEAR
    */
    STARTUP_CLEAR = TPM_PT.PT_VAR + 1,
    
    /**
    * the number of NV Indexes currently defined
    */
    HR_NV_INDEX = TPM_PT.PT_VAR + 2,
    
    /**
    * the number of authorization sessions currently loaded into TPM RAM
    */
    HR_LOADED = TPM_PT.PT_VAR + 3,
    
    /**
    * the number of additional authorization sessions, of any type, that could be loaded into TPM RAM This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be loaded. Any command that changes the RAM memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one authorization session would fit into RAM.
    */
    HR_LOADED_AVAIL = TPM_PT.PT_VAR + 4,
    
    /**
    * the number of active authorization sessions currently being tracked by the TPM This is the sum of the loaded and saved sessions.
    */
    HR_ACTIVE = TPM_PT.PT_VAR + 5,
    
    /**
    * the number of additional authorization sessions, of any type, that could be created This value is an estimate. If this value is at least 1, then at least one authorization session of any type may be created. Any command that changes the RAM memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one authorization session could be created.
    */
    HR_ACTIVE_AVAIL = TPM_PT.PT_VAR + 6,
    
    /**
    * estimate of the number of additional transient objects that could be loaded into TPM RAM This value is an estimate. If this value is at least 1, then at least one object of any type may be loaded. Any command that changes the memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one transient object would fit into RAM.
    */
    HR_TRANSIENT_AVAIL = TPM_PT.PT_VAR + 7,
    
    /**
    * the number of persistent objects currently loaded into TPM NV memory
    */
    HR_PERSISTENT = TPM_PT.PT_VAR + 8,
    
    /**
    * the number of additional persistent objects that could be loaded into NV memory This value is an estimate. If this value is at least 1, then at least one object of any type may be made persistent. Any command that changes the NV memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one persistent object would fit into NV memory.
    */
    HR_PERSISTENT_AVAIL = TPM_PT.PT_VAR + 9,
    
    /**
    * the number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute
    */
    NV_COUNTERS = TPM_PT.PT_VAR + 10,
    
    /**
    * the number of additional NV Indexes that can be defined with their TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET This value is an estimate. If this value is at least 1, then at least one NV Index may be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any command that changes the NV memory allocation can make this estimate invalid. NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
    */
    NV_COUNTERS_AVAIL = TPM_PT.PT_VAR + 11,
    
    /**
    * code that limits the algorithms that may be used with the TPM
    */
    ALGORITHM_SET = TPM_PT.PT_VAR + 12,
    
    /**
    * the number of loaded ECC curves
    */
    LOADED_CURVES = TPM_PT.PT_VAR + 13,
    
    /**
    * the current value of the lockout counter (failedTries)
    */
    LOCKOUT_COUNTER = TPM_PT.PT_VAR + 14,
    
    /**
    * the number of authorization failures before DA lockout is invoked
    */
    MAX_AUTH_FAIL = TPM_PT.PT_VAR + 15,
    
    /**
    * the number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented
    */
    LOCKOUT_INTERVAL = TPM_PT.PT_VAR + 16,
    
    /**
    * the number of seconds after a lockoutAuth failure before use of lockoutAuth may be attempted again
    */
    LOCKOUT_RECOVERY = TPM_PT.PT_VAR + 17,
    
    /**
    * number of milliseconds before the TPM will accept another command that will modify NV This value is an approximation and may go up or down over time.
    */
    NV_WRITE_RECOVERY = TPM_PT.PT_VAR + 18,
    
    /**
    * the high-order 32 bits of the command audit counter
    */
    AUDIT_COUNTER_0 = TPM_PT.PT_VAR + 19,
    
    /**
    * the low-order 32 bits of the command audit counter
    */
    AUDIT_COUNTER_1 = TPM_PT.PT_VAR + 20
}; // TPM_PT

/**
* The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property being selected or returned. The PCR properties can be read when capability == TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of property, the next higher value is returned, if it exists.
*/
export enum TPM_PT_PCR // UINT32
{
    /**
    * bottom of the range of TPM_PT_PCR properties
    */
    FIRST = 0x00000000,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE
    */
    SAVE = 0x00000000,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0 This property is only present if a locality other than 0 is implemented.
    */
    EXTEND_L0 = 0x00000001,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 0
    */
    RESET_L0 = 0x00000002,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1 This property is only present if locality 1 is implemented.
    */
    EXTEND_L1 = 0x00000003,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 1 This property is only present if locality 1 is implemented.
    */
    RESET_L1 = 0x00000004,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2 This property is only present if localities 1 and 2 are implemented.
    */
    EXTEND_L2 = 0x00000005,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 2 This property is only present if localities 1 and 2 are implemented.
    */
    RESET_L2 = 0x00000006,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3 This property is only present if localities 1, 2, and 3 are implemented.
    */
    EXTEND_L3 = 0x00000007,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 3 This property is only present if localities 1, 2, and 3 are implemented.
    */
    RESET_L3 = 0x00000008,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4 This property is only present if localities 1, 2, 3, and 4 are implemented.
    */
    EXTEND_L4 = 0x00000009,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by TPM2_PCR_Reset() from locality 4 This property is only present if localities 1, 2, 3, and 4 are implemented.
    */
    RESET_L4 = 0x0000000A,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or Extend) will not increment the pcrUpdateCounter
    */
    NO_INCREMENT = 0x00000011,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event following a _TPM_Hash_Start event.
    */
    DRTM_RESET = 0x00000012,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy This property is only present if the TPM supports policy control of a PCR.
    */
    POLICY = 0x00000013,
    
    /**
    * a SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an authorization value This property is only present if the TPM supports authorization control of a PCR.
    */
    AUTH = 0x00000014,
    
    /**
    * top of the range of TPM_PT_PCR properties of the implementation If the TPM receives a request for a PCR property with a value larger than this, the TPM will return a zero length list and set the moreData parameter to NO. NOTE This is an implementation-specific value. The value shown reflects the reference code implementation.
    */
    LAST = 0x00000014
}; // TPM_PT_PCR

/**
* The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.
*/
export enum TPM_PS // UINT32
{
    /**
    * not platform specific
    */
    MAIN = 0x00000000,
    
    /**
    * PC Client
    */
    PC = 0x00000001,
    
    /**
    * PDA (includes all mobile devices that are not specifically cell phones)
    */
    PDA = 0x00000002,
    
    /**
    * Cell Phone
    */
    CELL_PHONE = 0x00000003,
    
    /**
    * Server WG
    */
    SERVER = 0x00000004,
    
    /**
    * Peripheral WG
    */
    PERIPHERAL = 0x00000005,
    
    /**
    * TSS WG (deprecated)
    */
    TSS = 0x00000006,
    
    /**
    * Storage WG
    */
    STORAGE = 0x00000007,
    
    /**
    * Authentication WG
    */
    AUTHENTICATION = 0x00000008,
    
    /**
    * Embedded WG
    */
    EMBEDDED = 0x00000009,
    
    /**
    * Hardcopy WG
    */
    HARDCOPY = 0x0000000A,
    
    /**
    * Infrastructure WG (deprecated)
    */
    INFRASTRUCTURE = 0x0000000B,
    
    /**
    * Virtualization WG
    */
    VIRTUALIZATION = 0x0000000C,
    
    /**
    * Trusted Network Connect WG (deprecated)
    */
    TNC = 0x0000000D,
    
    /**
    * Multi-tenant WG (deprecated)
    */
    MULTI_TENANT = 0x0000000E,
    
    /**
    * Technical Committee (deprecated)
    */
    TC = 0x0000000F
}; // TPM_PS

/**
* The 32-bit handle space is divided into 256 regions of equal size with 224 values in each. Each of these ranges represents a handle type.
*/
export enum TPM_HT // UINT8
{
    /**
    * PCR consecutive numbers, starting at 0, that reference the PCR registers A platform-specific specification will set the minimum number of PCR and an implementation may have more.
    */
    PCR = 0x00,
    
    /**
    * NV Index assigned by the caller
    */
    NV_INDEX = 0x01,
    
    /**
    * HMAC Authorization Session assigned by the TPM when the session is created
    */
    HMAC_SESSION = 0x02,
    
    /**
    * Loaded Authorization Session used only in the context of TPM2_GetCapability This type references both loaded HMAC and loaded policy authorization sessions.
    */
    LOADED_SESSION = 0x02,
    
    /**
    * Policy Authorization Session assigned by the TPM when the session is created
    */
    POLICY_SESSION = 0x03,
    
    /**
    * Saved Authorization Session used only in the context of TPM2_GetCapability This type references saved authorization session contexts for which the TPM is maintaining tracking information.
    */
    SAVED_SESSION = 0x03,
    
    /**
    * Permanent Values assigned by this specification in Table 28
    */
    PERMANENT = 0x40,
    
    /**
    * Transient Objects assigned by the TPM when an object is loaded into transient-object memory or when a persistent object is converted to a transient object
    */
    TRANSIENT = 0x80,
    
    /**
    * Persistent Objects assigned by the TPM when a loaded transient object is made persistent
    */
    PERSISTENT = 0x81,
    
    /**
    * Attached Component handle for an Attached Component.
    */
    AC = 0x90
}; // TPM_HT

/**
* Table 28 lists the architecturally defined handles that cannot be changed. The handles include authorization handles, and special handles.
*/
export enum TPM_RH // TPM_HANDLE
{
    FIRST = 0x40000000,
    
    /**
    * not used1
    */
    SRK = 0x40000000,
    
    /**
    * handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy
    */
    OWNER = 0x40000001,
    
    /**
    * not used1
    */
    REVOKE = 0x40000002,
    
    /**
    * not used1
    */
    TRANSPORT = 0x40000003,
    
    /**
    * not used1
    */
    OPERATOR = 0x40000004,
    
    /**
    * not used1
    */
    ADMIN = 0x40000005,
    
    /**
    * not used1
    */
    EK = 0x40000006,
    
    /**
    * a handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty Policy authPolicy.
    */
    NULL = 0x40000007,
    
    /**
    * value reserved to the TPM to indicate a handle location that has not been initialized or assigned
    */
    UNASSIGNED = 0x40000008,
    
    /**
    * authorization value used to indicate a password authorization session
    */
    RS_PW = 0x40000009,
    
    /**
    * references the authorization associated with the dictionary attack lockout reset
    */
    LOCKOUT = 0x4000000A,
    
    /**
    * references the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy
    */
    ENDORSEMENT = 0x4000000B,
    
    /**
    * references the Platform Primary Seed (PPS), platformAuth, and platformPolicy
    */
    PLATFORM = 0x4000000C,
    
    /**
    * for phEnableNV
    */
    PLATFORM_NV = 0x4000000D,
    
    /**
    * Start of a range of authorization values that are vendor-specific. A TPM may support any of the values in this range as are needed for vendor-specific purposes. Disabled if ehEnable is CLEAR. NOTE Any includes none.
    */
    AUTH_00 = 0x40000010,
    
    /**
    * End of the range of vendor-specific authorization values.
    */
    AUTH_FF = 0x4000010F,
    
    /**
    * the top of the reserved handle area This is set to allow TPM2_GetCapability() to know where to stop. It may vary as implementations add to the permanent handle area.
    */
    LAST = 0x4000010F
}; // TPM_RH

/**
* This table lists the values of the TPM_NT field of a TPMA_NV. See Table 205 for usage.
*/
export enum TPM_NT // UINT32
{
    /**
    * Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    */
    ORDINARY = 0x0,
    
    /**
    * Counter contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    */
    COUNTER = 0x1,
    
    /**
    * Bit Field contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    */
    BITS = 0x2,
    
    /**
    * Extend contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    */
    EXTEND = 0x4,
    
    /**
    * PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    */
    PIN_FAIL = 0x8,
    
    /**
    * PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    */
    PIN_PASS = 0x9
}; // TPM_NT

/**
* These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value returned from an attached component.
*/
export enum TPM_AT // UINT32
{
    /**
    * in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    */
    ANY = 0x00000000,
    
    /**
    * indicates a TCG defined, device-specific error
    */
    ERROR = 0x00000001,
    
    /**
    * indicates the most significant 32 bits of a pairing value for the AC
    */
    PV1 = 0x00000002,
    
    /**
    * value added to a TPM_AT to indicate a vendor-specific tag value
    */
    VEND = 0x80000000
}; // TPM_AT

/**
* These constants are the TCG-defined error values returned by an AC.
*/
export enum TPM_AE // UINT32
{
    /**
    * in a command, a non-specific request for AC information; in a response, indicates that outputData is not meaningful
    */
    NONE = 0x00000000
}; // TPM_AE

/**
* These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.
*/
export enum PLATFORM // UINT32
{
    FAMILY = TPM_SPEC.FAMILY,
    
    LEVEL = TPM_SPEC.LEVEL,
    
    VERSION = TPM_SPEC.VERSION,
    
    YEAR = TPM_SPEC.YEAR,
    
    DAY_OF_YEAR = TPM_SPEC.DAY_OF_YEAR
}; // PLATFORM

/**
* This table contains a collection of values used in various parts of the reference code. The values shown are illustrative.
*/
export enum Implementation // UINT32
{
    /**
    * temporary define
    */
    FIELD_UPGRADE_IMPLEMENTED = Logic.NO,
    
    /**
    * The number of bits in a word. This is used in the big number library to set the unit of allocation. The reference implementation allows values of 32 and 64. It should be set to a value that is compatible with libraries that are used (e.g, OpenSSL).
    */
    RADIX_BITS = 32,
    
    /**
    * The byte alignment for hash structure
    */
    HASH_ALIGNMENT = 4,
    
    /**
    * The alignment for symmetric structures.
    */
    SYMMETRIC_ALIGNMENT = 4,
    
    /**
    * Selection of the library that provides the basic hashing functions.
    */
    HASH_LIB = ImplementationConstants.OSSL,
    
    /**
    * Selection of the library that provides the low-level symmetric cryptography. Choices are determined by the vendor (See LibSupport.h for implications).
    */
    SYM_LIB = ImplementationConstants.OSSL,
    
    /**
    * Selection of the library that provides the big number math including ECC. Choices are determined by the vendor (See LibSupport.h for implications).
    */
    MATH_LIB = ImplementationConstants.OSSL,
    
    /**
    * the number of PCR in the TPM
    */
    IMPLEMENTATION_PCR = 24,
    
    /**
    * the number of PCR required by the relevant platform specification
    */
    PLATFORM_PCR = 24,
    
    /**
    * the D-RTM PCR NOTE This value is not defined when the TPM does not implement D-RTM
    */
    DRTM_PCR = 17,
    
    /**
    * the PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.
    */
    HCRTM_PCR = 0,
    
    /**
    * the number of localities supported by the TPM This is expected to be either 5 for a PC, or 1 for just about everything else.
    */
    NUM_LOCALITIES = 5,
    
    /**
    * the maximum number of handles in the handle area This should be produced by the Part 3 parser but is here for now.
    */
    MAX_HANDLE_NUM = 3,
    
    /**
    * the number of simultaneously active sessions that are supported by the TPM implementation
    */
    MAX_ACTIVE_SESSIONS = 64,
    
    /**
    * the number of sessions that the TPM may have in memory
    */
    MAX_LOADED_SESSIONS = 3,
    
    /**
    * this is the current maximum value
    */
    MAX_SESSION_NUM = 3,
    
    /**
    * the number of simultaneously loaded objects that are supported by the TPM; this number does not include the objects that may be placed in NV memory by TPM2_EvictControl().
    */
    MAX_LOADED_OBJECTS = 3,
    
    /**
    * the minimum number of evict objects supported by the TPM
    */
    MIN_EVICT_OBJECTS = 2,
    
    PCR_SELECT_MIN = ((Implementation.PLATFORM_PCR+7)/8),
    
    PCR_SELECT_MAX = ((Implementation.IMPLEMENTATION_PCR+7)/8),
    
    /**
    * number of PCR groups that have individual policies
    */
    NUM_POLICY_PCR_GROUP = 1,
    
    /**
    * number of PCR groups that have individual authorization values
    */
    NUM_AUTHVALUE_PCR_GROUP = 1,
    
    MAX_CONTEXT_SIZE = 2474,
    
    MAX_DIGEST_BUFFER = 1024,
    
    /**
    * maximum data size allowed in an NV Index
    */
    MAX_NV_INDEX_SIZE = 2048,
    
    /**
    * maximum data size in one NV read or write command
    */
    MAX_NV_BUFFER_SIZE = 1024,
    
    /**
    * maximum size of a capability buffer
    */
    MAX_CAP_BUFFER = 1024,
    
    /**
    * size of NV memory in octets
    */
    NV_MEMORY_SIZE = 16384,
    
    /**
    * the TPM will not allocate a non-counter index if it would prevent allocation of this number of indices.
    */
    MIN_COUNTER_INDICES = 8,
    
    NUM_STATIC_PCR = 16,
    
    /**
    * number of algorithms that can be in a list
    */
    MAX_ALG_LIST_SIZE = 64,
    
    /**
    * size of the Primary Seed in octets
    */
    PRIMARY_SEED_SIZE = 32,
    
    /**
    * context encryption algorithm Just use the root so that the macros in GpMacros.h will work correctly.
    */
    CONTEXT_ENCRYPT_ALGORITHM = TPM_ALG_ID.AES,
    
    /**
    * the update interval expressed as a power of 2 seconds A value of 12 is 4,096 seconds (~68 minutes).
    */
    NV_CLOCK_UPDATE_INTERVAL = 12,
    
    /**
    * number of PCR groups that allow policy/auth
    */
    NUM_POLICY_PCR = 1,
    
    /**
    * maximum size of a command
    */
    MAX_COMMAND_SIZE = 4096,
    
    /**
    * maximum size of a response
    */
    MAX_RESPONSE_SIZE = 4096,
    
    /**
    * number between 1 and 32 inclusive
    */
    ORDERLY_BITS = 8,
    
    /**
    * the maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value
    */
    MAX_SYM_DATA = 128,
    
    MAX_RNG_ENTROPY_SIZE = 64,
    
    /**
    * Number of bytes used for the RAM index space. If this is not large enough, it might not be possible to allocate orderly indices.
    */
    RAM_INDEX_SPACE = 512,
    
    /**
    * 216 + 1
    */
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x00010001,
    
    /**
    * indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented
    */
    ENABLE_PCR_NO_INCREMENT = Logic.YES,
    
    CRT_FORMAT_RSA = Logic.YES,
    
    VENDOR_COMMAND_COUNT = 0,
    
    /**
    * MAX_RSA_KEY_BYTES is auto generated from the RSA key size selection in Table 4. If RSA is not implemented, this may need to be manually removed.
    */
    PRIVATE_VENDOR_SPECIFIC_BYTES = ((ImplementationConstants.MAX_RSA_KEY_BYTES/2) * (3 + Implementation.CRT_FORMAT_RSA * 2)),
    
    /**
    * Maximum size of the vendor-specific buffer
    */
    MAX_VENDOR_BUFFER_SIZE = 1024
}; // Implementation

/**
* The definitions in Table 29 are used to define many of the interface data types.
*/
export enum TPM_HC // TPM_HANDLE
{
    /**
    * to mask off the HR
    */
    HR_HANDLE_MASK = 0x00FFFFFF,
    
    /**
    * to mask off the variable part
    */
    HR_RANGE_MASK = 0xFF000000,
    
    HR_SHIFT = 24,
    
    HR_PCR = (TPM_HT.PCR << TPM_HC.HR_SHIFT),
    
    HR_HMAC_SESSION = (TPM_HT.HMAC_SESSION << TPM_HC.HR_SHIFT),
    
    HR_POLICY_SESSION = (TPM_HT.POLICY_SESSION << TPM_HC.HR_SHIFT),
    
    HR_TRANSIENT = (TPM_HT.TRANSIENT << TPM_HC.HR_SHIFT),
    
    HR_PERSISTENT = (TPM_HT.PERSISTENT << TPM_HC.HR_SHIFT),
    
    HR_NV_INDEX = (TPM_HT.NV_INDEX << TPM_HC.HR_SHIFT),
    
    HR_PERMANENT = (TPM_HT.PERMANENT << TPM_HC.HR_SHIFT),
    
    /**
    * first PCR
    */
    PCR_FIRST = (TPM_HC.HR_PCR + 0),
    
    /**
    * last PCR
    */
    PCR_LAST = (TPM_HC.PCR_FIRST + Implementation.IMPLEMENTATION_PCR-1),
    
    /**
    * first HMAC session
    */
    HMAC_SESSION_FIRST = (TPM_HC.HR_HMAC_SESSION + 0),
    
    /**
    * last HMAC session
    */
    HMAC_SESSION_LAST = (TPM_HC.HMAC_SESSION_FIRST+Implementation.MAX_ACTIVE_SESSIONS-1),
    
    /**
    * used in GetCapability
    */
    LOADED_SESSION_FIRST = TPM_HC.HMAC_SESSION_FIRST,
    
    /**
    * used in GetCapability
    */
    LOADED_SESSION_LAST = TPM_HC.HMAC_SESSION_LAST,
    
    /**
    * first policy session
    */
    POLICY_SESSION_FIRST = (TPM_HC.HR_POLICY_SESSION + 0),
    
    /**
    * last policy session
    */
    POLICY_SESSION_LAST = (TPM_HC.POLICY_SESSION_FIRST + Implementation.MAX_ACTIVE_SESSIONS-1),
    
    /**
    * first transient object
    */
    TRANSIENT_FIRST = (TPM_HC.HR_TRANSIENT + 0),
    
    /**
    * used in GetCapability
    */
    ACTIVE_SESSION_FIRST = TPM_HC.POLICY_SESSION_FIRST,
    
    /**
    * used in GetCapability
    */
    ACTIVE_SESSION_LAST = TPM_HC.POLICY_SESSION_LAST,
    
    /**
    * last transient object
    */
    TRANSIENT_LAST = (TPM_HC.TRANSIENT_FIRST+Implementation.MAX_LOADED_OBJECTS-1),
    
    /**
    * first persistent object
    */
    PERSISTENT_FIRST = (TPM_HC.HR_PERSISTENT + 0),
    
    /**
    * last persistent object
    */
    PERSISTENT_LAST = (TPM_HC.PERSISTENT_FIRST + 0x00FFFFFF),
    
    /**
    * first platform persistent object
    */
    PLATFORM_PERSISTENT = (TPM_HC.PERSISTENT_FIRST + 0x00800000),
    
    /**
    * first allowed NV Index
    */
    NV_INDEX_FIRST = (TPM_HC.HR_NV_INDEX + 0),
    
    /**
    * last allowed NV Index
    */
    NV_INDEX_LAST = (TPM_HC.NV_INDEX_FIRST + 0x00FFFFFF),
    
    PERMANENT_FIRST = TPM_RH.FIRST,
    
    PERMANENT_LAST = TPM_RH.LAST,
    
    /**
    * AC aliased NV Index
    */
    HR_NV_AC = ((TPM_HT.NV_INDEX << TPM_HC.HR_SHIFT) + 0xD00000),
    
    /**
    * first NV Index aliased to Attached Component
    */
    NV_AC_FIRST = (TPM_HC.HR_NV_AC + 0),
    
    /**
    * last NV Index aliased to Attached Component
    */
    NV_AC_LAST = (TPM_HC.HR_NV_AC + 0x0000FFFF),
    
    /**
    * AC Handle
    */
    HR_AC = (TPM_HT.AC << TPM_HC.HR_SHIFT),
    
    /**
    * first Attached Component
    */
    AC_FIRST = (TPM_HC.HR_AC + 0),
    
    /**
    * last Attached Component
    */
    AC_LAST = (TPM_HC.HR_AC + 0x0000FFFF)
}; // TPM_HC

/**
* This structure defines the attributes of an algorithm.
*/
export enum TPMA_ALGORITHM // UINT32
{
    /**
    * SET (1): an asymmetric algorithm with public and private portions CLEAR (0): not an asymmetric algorithm
    */
    asymmetric = 0x1,
    
    /**
    * SET (1): a symmetric block cipher CLEAR (0): not a symmetric block cipher
    */
    symmetric = 0x2,
    
    /**
    * SET (1): a hash algorithm CLEAR (0): not a hash algorithm
    */
    hash = 0x4,
    
    /**
    * SET (1): an algorithm that may be used as an object type CLEAR (0): an algorithm that is not used as an object type
    */
    object = 0x8,
    
    /**
    * SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of signing algorithm. CLEAR (0): not a signing algorithm
    */
    signing = 0x100,
    
    /**
    * SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and hash will indicate the type of encryption/decryption algorithm. CLEAR (0): not an encryption/decryption algorithm
    */
    encrypting = 0x200,
    
    /**
    * SET (1): a method such as a key derivative function (KDF) CLEAR (0): not a method
    */
    method = 0x400
    
}; // TPMA_ALGORITHM

/**
* This attribute structure indicates an objects use, its authorization types, and its relationship to other objects.
*/
export enum TPMA_OBJECT // UINT32
{
    /**
    * SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change. CLEAR (0): The hierarchy of the object may change as a result of this object or an ancestor key being duplicated for use in another hierarchy. NOTE fixedTPM does not indicate that key material resides on a single TPM. (see sensitiveDataOrigin).
    */
    fixedTPM = 0x2,
    
    /**
    * SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR). CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and subsequent Startup().
    */
    stClear = 0x4,
    
    /**
    * SET (1): The parent of the object may not change. CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of the object.
    */
    fixedParent = 0x10,
    
    /**
    * SET (1): Indicates that, when the object was created with TPM2_Create() or TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue. CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by the caller.
    */
    sensitiveDataOrigin = 0x20,
    
    /**
    * SET (1): Approval of USER role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session. CLEAR (0): Approval of USER role actions with this object may only be done with a policy session.
    */
    userWithAuth = 0x40,
    
    /**
    * SET (1): Approval of ADMIN role actions with this object may only be done with a policy session. CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session or with a password using the authValue of the object or a policy session.
    */
    adminWithPolicy = 0x80,
    
    /**
    * SET (1): The object is not subject to dictionary attack protections. CLEAR (0): The object is subject to dictionary attack protections.
    */
    noDA = 0x400,
    
    /**
    * SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and newParentHandle shall not be TPM_RH_NULL. CLEAR (0): The object may be duplicated without an inner wrapper on the private portion of the object and the new parent may be TPM_RH_NULL.
    */
    encryptedDuplication = 0x800,
    
    /**
    * SET (1): Key usage is restricted to manipulate structures of known format; the parent of this key shall have restricted SET. CLEAR (0): Key usage is not restricted to use on special formats.
    */
    restricted = 0x10000,
    
    /**
    * SET (1): The private portion of the key may be used to decrypt. CLEAR (0): The private portion of the key may not be used to decrypt.
    */
    decrypt = 0x20000,
    
    /**
    * SET (1): For a symmetric cipher object, the private portion of the key may be used to encrypt. For other objects, the private portion of the key may be used to sign. CLEAR (0): The private portion of the key may not be used to sign or encrypt.
    */
    sign = 0x40000,
    
    /**
    * Alias to the Sign value.
    */
    encrypt = 0x40000
    
}; // TPMA_OBJECT

/**
* This octet in each session is used to identify the session type, indicate its relationship to any handles in the command, and indicate its use in parameter encryption.
*/
export enum TPMA_SESSION // UINT8
{
    /**
    * SET (1): In a command, this setting indicates that the session is to remain active after successful completion of the command. In a response, it indicates that the session is still active. If SET in the command, this attribute shall be SET in the response. CLEAR (0): In a command, this setting indicates that the TPM should close the session and flush any related context when the command completes successfully. In a response, it indicates that the session is closed and the context is no longer active. This attribute has no meaning for a password authorization and the TPM will allow any setting of the attribute in the command and SET the attribute in the response. This attribute will only be CLEAR in one response for a logical session. If the attribute is CLEAR, the context associated with the session is no longer in use and the space is available. A session created after another session is ended may have the same handle but logically is not the same session. This attribute has no effect if the command does not complete successfully.
    */
    continueSession = 0x1,
    
    /**
    * SET (1): In a command, this setting indicates that the command should only be executed if the session is exclusive at the start of the command. In a response, it indicates that the session is exclusive. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES). CLEAR (0): In a command, indicates that the session need not be exclusive at the start of the command. In a response, indicates that the session is not exclusive.
    */
    auditExclusive = 0x2,
    
    /**
    * SET (1): In a command, this setting indicates that the audit digest of the session should be initialized and the exclusive status of the session SET. This setting is only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES). CLEAR (0): In a command, indicates that the audit digest should not be initialized. This bit is always CLEAR in a response.
    */
    auditReset = 0x4,
    
    /**
    * SET (1): In a command, this setting indicates that the first parameter in the command is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0 Part 1. The TPM will decrypt the parameter after performing any HMAC computations and before unmarshaling the parameter. In a response, the attribute is copied from the request but has no effect on the response. CLEAR (0): Session not used for encryption. For a password authorization, this attribute will be CLEAR in both the command and response. This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization. This attribute may be SET in combination with any other session attributes.
    */
    decrypt = 0x20,
    
    /**
    * SET (1): In a command, this setting indicates that the TPM should use this session to encrypt the first parameter in the response. In a response, it indicates that the attribute was set in the command and that the TPM used the session to encrypt the first parameter in the response using the parameter encryption scheme described in TPM 2.0 Part 1. CLEAR (0): Session not used for encryption. For a password authorization, this attribute will be CLEAR in both the command and response. This attribute may be SET in a session that is not associated with a command handle. Such a session is provided for purposes of encrypting a parameter and not for authorization.
    */
    encrypt = 0x40,
    
    /**
    * SET (1): In a command or response, this setting indicates that the session is for audit and that auditExclusive and auditReset have meaning. This session may also be used for authorization, encryption, or decryption. The encrypted and encrypt fields may be SET or CLEAR. CLEAR (0): Session is not used for audit. If SET in the command, then this attribute will be SET in the response.
    */
    audit = 0x80
    
}; // TPMA_SESSION

/**
* In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of the command that created the object. No more than one of the locality attributes shall be set in the creation data.
*/
export enum TPMA_LOCALITY // UINT8
{
    LOC_ZERO = 0x1,
    
    LOC_ONE = 0x2,
    
    LOC_TWO = 0x4,
    
    LOC_THREE = 0x8,
    
    LOC_FOUR = 0x10,
    
    /**
    * If any of these bits is set, an extended locality is indicated
    */
    Extended_BIT_0 = 0x20,
    
    Extended_BIT_1 = 0x40,
    
    Extended_BIT_2 = 0x80
    
}; // TPMA_LOCALITY

/**
* The attributes in this structure are persistent and are not changed as a result of _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change as the result of specific Protected Capabilities. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
*/
export enum TPMA_PERMANENT // UINT32
{
    /**
    * SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear(). CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
    */
    ownerAuthSet = 0x1,
    
    /**
    * SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the last TPM2_Clear(). CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
    */
    endorsementAuthSet = 0x2,
    
    /**
    * SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last TPM2_Clear(). CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
    */
    lockoutAuthSet = 0x4,
    
    /**
    * SET (1): TPM2_Clear() is disabled. CLEAR (0): TPM2_Clear() is enabled. NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
    */
    disableClear = 0x100,
    
    /**
    * SET (1): The TPM is in lockout, when failedTries is equal to maxTries.
    */
    inLockout = 0x200,
    
    /**
    * SET (1): The EPS was created by the TPM. CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
    */
    tpmGeneratedEPS = 0x400
    
}; // TPMA_PERMANENT

/**
* This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
*/
export enum TPMA_STARTUP_CLEAR // UINT32
{
    /**
    * SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be used for authorization. CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and objects in the platform hierarchy, including persistent objects, cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    */
    phEnable = 0x1,
    
    /**
    * SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for authorization. NV indices defined using owner authorization are accessible. CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects in the Storage hierarchy, persistent objects, and NV indices defined using owner authorization cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    */
    shEnable = 0x2,
    
    /**
    * SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to authorize commands. CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects in the endorsement hierarchy, including persistent objects, cannot be used. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
    */
    ehEnable = 0x4,
    
    /**
    * SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The platform can create define and undefine indices. CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined (TPM_RC_HANDLE) indices. NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute. NOTE read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index does not exist, it also returns this error code if the index is disabled. Otherwise, the TPM would leak the existence of an index even when disabled.
    */
    phEnableNV = 0x8,
    
    /**
    * SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup(). CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type. NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed by a TPM2_Startup() of any type. However, the TPM will return an error if TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
    */
    orderly = 0x80000000
    
}; // TPMA_STARTUP_CLEAR

/**
* This structure of this attribute is used to report the memory management method used by the TPM for transient objects and authorization sessions. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
*/
export enum TPMA_MEMORY // UINT32
{
    /**
    * SET (1): indicates that the RAM memory used for authorization session contexts is shared with the memory used for transient objects CLEAR (0): indicates that the memory used for authorization sessions is not shared with memory used for transient objects
    */
    sharedRAM = 0x1,
    
    /**
    * SET (1): indicates that the NV memory used for persistent objects is shared with the NV memory used for NV Index values CLEAR (0): indicates that the persistent objects and NV Index values are allocated from separate sections of NV
    */
    sharedNV = 0x2,
    
    /**
    * SET (1): indicates that the TPM copies persistent objects to a transient-object slot in RAM when the persistent object is referenced in a command. The TRM is required to make sure that an object slot is available. CLEAR (0): indicates that the TPM does not use transient-object slots when persistent objects are referenced
    */
    objectCopiedToRam = 0x4
    
}; // TPMA_MEMORY

/**
* This structure defines the attributes of a command from a context management perspective. The fields of the structure indicate to the TPM Resource Manager (TRM) the number of resources required by a command and how the command affects the TPMs resources.
*/
export enum TPMA_CC // TPM_CC
{
    /**
    * indicates the command being selected
    */
    commandIndex_BIT_0 = 0x1,
    
    commandIndex_BIT_1 = 0x2,
    
    commandIndex_BIT_2 = 0x4,
    
    commandIndex_BIT_3 = 0x8,
    
    commandIndex_BIT_4 = 0x10,
    
    commandIndex_BIT_5 = 0x20,
    
    commandIndex_BIT_6 = 0x40,
    
    commandIndex_BIT_7 = 0x80,
    
    commandIndex_BIT_8 = 0x100,
    
    commandIndex_BIT_9 = 0x200,
    
    commandIndex_BIT_10 = 0x400,
    
    commandIndex_BIT_11 = 0x800,
    
    commandIndex_BIT_12 = 0x1000,
    
    commandIndex_BIT_13 = 0x2000,
    
    commandIndex_BIT_14 = 0x4000,
    
    commandIndex_BIT_15 = 0x8000,
    
    /**
    * SET (1): indicates that the command may write to NV CLEAR (0): indicates that the command does not write to NV
    */
    nv = 0x400000,
    
    /**
    * SET (1): This command could flush any number of loaded contexts. CLEAR (0): no additional changes other than indicated by the flushed attribute
    */
    extensive = 0x800000,
    
    /**
    * SET (1): The context associated with any transient handle in the command will be flushed when this command completes. CLEAR (0): No context is flushed as a side effect of this command.
    */
    flushed = 0x1000000,
    
    /**
    * indicates the number of the handles in the handle area for this command
    */
    cHandles_BIT_0 = 0x2000000,
    
    cHandles_BIT_1 = 0x4000000,
    
    cHandles_BIT_2 = 0x8000000,
    
    /**
    * SET (1): indicates the presence of the handle area in the response
    */
    rHandle = 0x10000000,
    
    /**
    * SET (1): indicates that the command is vendor-specific CLEAR (0): indicates that the command is defined in a version of this specification
    */
    V = 0x20000000,
    
    /**
    * allocated for software; shall be zero
    */
    Res_BIT_0 = 0x40000000,
    
    Res_BIT_1 = 0x80000000
    
}; // TPMA_CC

/**
* This structure of this attribute is used to report that the TPM is designed for these modes. This structure may be read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
*/
export enum TPMA_MODES // UINT32
{
    /**
    * SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2 requirements at Level 1 or higher.
    */
    FIPS_140_2 = 0x1
    
}; // TPMA_MODES

/**
* A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the Index is changed from TPM 1.2 in order to include the Index in the reserved handle space. Handles in this range use the digest of the public area of the Index as the Name of the entity in authorization computations
*/
export enum TPM_NV_INDEX // UINT32
{
    /**
    * The Index of the NV location
    */
    index_BIT_0 = 0x1,
    
    index_BIT_1 = 0x2,
    
    index_BIT_2 = 0x4,
    
    index_BIT_3 = 0x8,
    
    index_BIT_4 = 0x10,
    
    index_BIT_5 = 0x20,
    
    index_BIT_6 = 0x40,
    
    index_BIT_7 = 0x80,
    
    index_BIT_8 = 0x100,
    
    index_BIT_9 = 0x200,
    
    index_BIT_10 = 0x400,
    
    index_BIT_11 = 0x800,
    
    index_BIT_12 = 0x1000,
    
    index_BIT_13 = 0x2000,
    
    index_BIT_14 = 0x4000,
    
    index_BIT_15 = 0x8000,
    
    index_BIT_16 = 0x10000,
    
    index_BIT_17 = 0x20000,
    
    index_BIT_18 = 0x40000,
    
    index_BIT_19 = 0x80000,
    
    index_BIT_20 = 0x100000,
    
    index_BIT_21 = 0x200000,
    
    index_BIT_22 = 0x400000,
    
    index_BIT_23 = 0x800000,
    
    /**
    * constant value of TPM_HT_NV_INDEX indicating the NV Index range
    */
    RhNv_BIT_0 = 0x1000000,
    
    RhNv_BIT_1 = 0x2000000,
    
    RhNv_BIT_2 = 0x4000000,
    
    RhNv_BIT_3 = 0x8000000,
    
    RhNv_BIT_4 = 0x10000000,
    
    RhNv_BIT_5 = 0x20000000,
    
    RhNv_BIT_6 = 0x40000000,
    
    RhNv_BIT_7 = 0x80000000
    
}; // TPM_NV_INDEX

/**
* This structure allows the TPM to keep track of the data and permissions to manipulate an NV Index.
*/
export enum TPMA_NV // UINT32
{
    /**
    * SET (1): The Index data can be written if Platform Authorization is provided. CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
    */
    PPWRITE = 0x1,
    
    /**
    * SET (1): The Index data can be written if Owner Authorization is provided. CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
    */
    OWNERWRITE = 0x2,
    
    /**
    * SET (1): Authorizations to change the Index contents that require USER role may be provided with an HMAC session or password. CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with an HMAC session or password.
    */
    AUTHWRITE = 0x4,
    
    /**
    * SET (1): Authorizations to change the Index contents that require USER role may be provided with a policy session. CLEAR (0): Authorizations to change the Index contents that require USER role may not be provided with a policy session. NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
    */
    POLICYWRITE = 0x8,
    
    /**
    * Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().
    */
    ORDINARY = 0x0,
    
    /**
    * Counter contains an 8-octet value that is to be used as a counter and can only be modified with TPM2_NV_Increment()
    */
    COUNTER = 0x10,
    
    /**
    * Bit Field contains an 8-octet value to be used as a bit field and can only be modified with TPM2_NV_SetBits().
    */
    BITS = 0x20,
    
    /**
    * Extend contains a digest-sized value used like a PCR. The Index can only be modified using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
    */
    EXTEND = 0x40,
    
    /**
    * PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit
    */
    PIN_FAIL = 0x80,
    
    /**
    * PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit
    */
    PIN_PASS = 0x90,
    
    /**
    * The type of the index. NOTE A TPM is not required to support all TPM_NT values
    */
    TpmNt_BIT_0 = 0x10,
    
    TpmNt_BIT_1 = 0x20,
    
    TpmNt_BIT_2 = 0x40,
    
    TpmNt_BIT_3 = 0x80,
    
    /**
    * SET (1): Index may not be deleted unless the authPolicy is satisfied using TPM2_NV_UndefineSpaceSpecial(). CLEAR (0): Index may be deleted with proper platform or owner authorization using TPM2_NV_UndefineSpace(). NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an Empty Policy) cannot be deleted.
    */
    POLICY_DELETE = 0x400,
    
    /**
    * SET (1): Index cannot be written. CLEAR (0): Index can be written.
    */
    WRITELOCKED = 0x800,
    
    /**
    * SET (1): A partial write of the Index data is not allowed. The write size shall match the defined space size. CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
    */
    WRITEALL = 0x1000,
    
    /**
    * SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location. CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITE_STCLEAR is also CLEAR.
    */
    WRITEDEFINE = 0x2000,
    
    /**
    * SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location until the next TPM Reset or TPM Restart. CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE is also CLEAR.
    */
    WRITE_STCLEAR = 0x4000,
    
    /**
    * SET (1): If TPM2_NV_GlobalWriteLock() is successful, then further writes to this location are not permitted until the next TPM Reset or TPM Restart. CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
    */
    GLOBALLOCK = 0x8000,
    
    /**
    * SET (1): The Index data can be read if Platform Authorization is provided. CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
    */
    PPREAD = 0x10000,
    
    /**
    * SET (1): The Index data can be read if Owner Authorization is provided. CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
    */
    OWNERREAD = 0x20000,
    
    /**
    * SET (1): The Index data may be read if the authValue is provided. CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
    */
    AUTHREAD = 0x40000,
    
    /**
    * SET (1): The Index data may be read if the authPolicy is satisfied. CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
    */
    POLICYREAD = 0x80000,
    
    /**
    * SET (1): Authorization failures of the Index do not affect the DA logic and authorization of the Index is not blocked when the TPM is in Lockout mode. CLEAR (0): Authorization failures of the Index will increment the authorization failure counter and authorizations of this Index are not allowed when the TPM is in Lockout mode.
    */
    NO_DA = 0x2000000,
    
    /**
    * SET (1): NV Index state is only required to be saved when the TPM performs an orderly shutdown (TPM2_Shutdown()). CLEAR (0): NV Index state is required to be persistent after the command to update the Index completes successfully (that is, the NV update is synchronous with the update command). NOTE If TPMA_NV_ORDERLY is SET, TPMA_NV_WRITTEN will be CLEAR by TPM Reset.
    */
    ORDERLY = 0x4000000,
    
    /**
    * SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart. CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart. NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
    */
    CLEAR_STCLEAR = 0x8000000,
    
    /**
    * SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart. CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
    */
    READLOCKED = 0x10000000,
    
    /**
    * SET (1): Index has been written. CLEAR (0): Index has not been written.
    */
    WRITTEN = 0x20000000,
    
    /**
    * SET (1): This Index may be undefined with Platform Authorization but not with Owner Authorization. CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform Authorization. The TPM will validate that this attribute is SET when the Index is defined using Platform Authorization and will validate that this attribute is CLEAR when the Index is defined using Owner Authorization.
    */
    PLATFORMCREATE = 0x40000000,
    
    /**
    * SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index. CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
    */
    READ_STCLEAR = 0x80000000
    
}; // TPMA_NV

/**
 * TPM union interface
 */
export interface TpmUnion extends TpmMarshaller
{
    GetUnionSelector(): TPM_ALG_ID | TPM_CAP | TPM_ST;
}


/**
* Table 84 Definition of TPMU_NAME Union ()
*/
export interface TPMU_NAME extends TpmUnion {}

/**
* Table 110 Definition of TPMU_CAPABILITIES Union (OUT)
*/
export interface TPMU_CAPABILITIES extends TpmUnion {}

/**
* Table 122 Definition of TPMU_ATTEST Union (OUT)
*/
export interface TPMU_ATTEST extends TpmUnion {}

/**
* This union is used to collect the symmetric encryption key sizes.
*/
export interface TPMU_SYM_KEY_BITS extends TpmUnion {}

/**
* This is the union of all modes for all symmetric algorithms.
*/
export interface TPMU_SYM_MODE extends TpmUnion {}

/**
* This union allows additional parameters to be added for a symmetric cipher. Currently, no additional parameters are required for any of the symmetric algorithms.
*/
export interface TPMU_SYM_DETAILS extends TpmUnion {}

/**
* This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are determined by context. When an object is being derived, the derivation values are present.
*/
export interface TPMU_SENSITIVE_CREATE extends TpmUnion {}

/**
* Table 147 Definition of TPMU_SCHEME_KEYEDHASH Union (IN/OUT, S)
*/
export interface TPMU_SCHEME_KEYEDHASH extends TpmUnion {}

/**
* This is the union of all of the signature schemes.
*/
export interface TPMU_SIG_SCHEME extends TpmUnion {}

/**
* Table 156 Definition of TPMU_KDF_SCHEME Union (IN/OUT, S)
*/
export interface TPMU_KDF_SCHEME extends TpmUnion {}

/**
* This union of all asymmetric schemes is used in each of the asymmetric scheme structures. The actual scheme structure is defined by the interface type used for the selector (TPMI_ALG_ASYM_SCHEME).
*/
export interface TPMU_ASYM_SCHEME extends TpmUnion {}

/**
* A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by a particular TPM implementation. The union allows substitution of any signature algorithm wherever a signature is required in a structure.
*/
export interface TPMU_SIGNATURE extends TpmUnion {}

/**
* This structure is used to hold either an ephemeral public point for ECDH, an OAEP-encrypted block for RSA, or a symmetrically encrypted value. This structure is defined for the limited purpose of determining the size of a TPM2B_ENCRYPTED_SECRET.
*/
export interface TPMU_ENCRYPTED_SECRET extends TpmUnion {}

/**
* This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
*/
export interface TPMU_PUBLIC_ID extends TpmUnion {}

/**
* Table 189 defines the possible parameter definition structures that may be contained in the public portion of a key. If the Object can be a parent, the first field must be a TPMT_SYM_DEF_OBJECT. See 11.1.7.
*/
export interface TPMU_PUBLIC_PARMS extends TpmUnion {}

/**
* Table 195 Definition of TPMU_SENSITIVE_COMPOSITE Union (IN/OUT, S)
*/
export interface TPMU_SENSITIVE_COMPOSITE extends TpmUnion {}

function createUnion<U extends TpmUnion>(unionType: string, selector: TPM_ALG_ID | TPM_CAP | TPM_ST): U
{
    let u: TpmUnion = null;
    
    switch (unionType) {
    case 'TPMU_CAPABILITIES':
        switch (selector) {
            case TPM_CAP.ALGS: u = new TPML_ALG_PROPERTY(); break;
            case TPM_CAP.HANDLES: u = new TPML_HANDLE(); break;
            case TPM_CAP.COMMANDS: u = new TPML_CCA(); break;
            case TPM_CAP.PP_COMMANDS: u = new TPML_CC(); break;
            case TPM_CAP.AUDIT_COMMANDS: u = new TPML_CC(); break;
            case TPM_CAP.PCRS: u = new TPML_PCR_SELECTION(); break;
            case TPM_CAP.TPM_PROPERTIES: u = new TPML_TAGGED_TPM_PROPERTY(); break;
            case TPM_CAP.PCR_PROPERTIES: u = new TPML_TAGGED_PCR_PROPERTY(); break;
            case TPM_CAP.ECC_CURVES: u = new TPML_ECC_CURVE(); break;
            case TPM_CAP.AUTH_POLICIES: u = new TPML_TAGGED_POLICY(); break;
        }
        break;
    case 'TPMU_ATTEST':
        switch (selector) {
            case TPM_ST.ATTEST_CERTIFY: u = new TPMS_CERTIFY_INFO(); break;
            case TPM_ST.ATTEST_CREATION: u = new TPMS_CREATION_INFO(); break;
            case TPM_ST.ATTEST_QUOTE: u = new TPMS_QUOTE_INFO(); break;
            case TPM_ST.ATTEST_COMMAND_AUDIT: u = new TPMS_COMMAND_AUDIT_INFO(); break;
            case TPM_ST.ATTEST_SESSION_AUDIT: u = new TPMS_SESSION_AUDIT_INFO(); break;
            case TPM_ST.ATTEST_TIME: u = new TPMS_TIME_ATTEST_INFO(); break;
            case TPM_ST.ATTEST_NV: u = new TPMS_NV_CERTIFY_INFO(); break;
        }
        break;
    case 'TPMU_SYM_DETAILS':
        switch (selector) {
            case TPM_ALG_ID.TDES: u = new TPMS_TDES_SYM_DETAILS(); break;
            case TPM_ALG_ID.AES: u = new TPMS_AES_SYM_DETAILS(); break;
            case TPM_ALG_ID.SM4: u = new TPMS_SM4_SYM_DETAILS(); break;
            case TPM_ALG_ID.CAMELLIA: u = new TPMS_CAMELLIA_SYM_DETAILS(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_ANY_SYM_DETAILS(); break;
            case TPM_ALG_ID.XOR: u = new TPMS_XOR_SYM_DETAILS(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_SYM_DETAILS(); break;
        }
        break;
    case 'TPMU_SENSITIVE_CREATE':
        switch (selector) {
            case TPM_ALG_ID.ANY: u = null; break;
            case TPM_ALG_ID.ANY2: u = new TPMS_DERIVE(); break;
        }
        break;
    case 'TPMU_SCHEME_KEYEDHASH':
        switch (selector) {
            case TPM_ALG_ID.HMAC: u = new TPMS_SCHEME_HMAC(); break;
            case TPM_ALG_ID.XOR: u = new TPMS_SCHEME_XOR(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_SCHEME_KEYEDHASH(); break;
        }
        break;
    case 'TPMU_SIG_SCHEME':
        switch (selector) {
            case TPM_ALG_ID.RSASSA: u = new TPMS_SIG_SCHEME_RSASSA(); break;
            case TPM_ALG_ID.RSAPSS: u = new TPMS_SIG_SCHEME_RSAPSS(); break;
            case TPM_ALG_ID.ECDSA: u = new TPMS_SIG_SCHEME_ECDSA(); break;
            case TPM_ALG_ID.ECDAA: u = new TPMS_SIG_SCHEME_ECDAA(); break;
            case TPM_ALG_ID.SM2: u = new TPMS_SIG_SCHEME_SM2(); break;
            case TPM_ALG_ID.ECSCHNORR: u = new TPMS_SIG_SCHEME_ECSCHNORR(); break;
            case TPM_ALG_ID.HMAC: u = new TPMS_SCHEME_HMAC(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_SCHEME_HASH(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_SIG_SCHEME(); break;
        }
        break;
    case 'TPMU_KDF_SCHEME':
        switch (selector) {
            case TPM_ALG_ID.MGF1: u = new TPMS_SCHEME_MGF1(); break;
            case TPM_ALG_ID.KDF1_SP800_56A: u = new TPMS_SCHEME_KDF1_SP800_56A(); break;
            case TPM_ALG_ID.KDF2: u = new TPMS_SCHEME_KDF2(); break;
            case TPM_ALG_ID.KDF1_SP800_108: u = new TPMS_SCHEME_KDF1_SP800_108(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_KDF_SCHEME(); break;
        }
        break;
    case 'TPMU_ASYM_SCHEME':
        switch (selector) {
            case TPM_ALG_ID.ECDH: u = new TPMS_KEY_SCHEME_ECDH(); break;
            case TPM_ALG_ID.ECMQV: u = new TPMS_KEY_SCHEME_ECMQV(); break;
            case TPM_ALG_ID.RSASSA: u = new TPMS_SIG_SCHEME_RSASSA(); break;
            case TPM_ALG_ID.RSAPSS: u = new TPMS_SIG_SCHEME_RSAPSS(); break;
            case TPM_ALG_ID.ECDSA: u = new TPMS_SIG_SCHEME_ECDSA(); break;
            case TPM_ALG_ID.ECDAA: u = new TPMS_SIG_SCHEME_ECDAA(); break;
            case TPM_ALG_ID.SM2: u = new TPMS_SIG_SCHEME_SM2(); break;
            case TPM_ALG_ID.ECSCHNORR: u = new TPMS_SIG_SCHEME_ECSCHNORR(); break;
            case TPM_ALG_ID.RSAES: u = new TPMS_ENC_SCHEME_RSAES(); break;
            case TPM_ALG_ID.OAEP: u = new TPMS_ENC_SCHEME_OAEP(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_SCHEME_HASH(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_ASYM_SCHEME(); break;
        }
        break;
    case 'TPMU_SIGNATURE':
        switch (selector) {
            case TPM_ALG_ID.RSASSA: u = new TPMS_SIGNATURE_RSASSA(); break;
            case TPM_ALG_ID.RSAPSS: u = new TPMS_SIGNATURE_RSAPSS(); break;
            case TPM_ALG_ID.ECDSA: u = new TPMS_SIGNATURE_ECDSA(); break;
            case TPM_ALG_ID.ECDAA: u = new TPMS_SIGNATURE_ECDAA(); break;
            case TPM_ALG_ID.SM2: u = new TPMS_SIGNATURE_SM2(); break;
            case TPM_ALG_ID.ECSCHNORR: u = new TPMS_SIGNATURE_ECSCHNORR(); break;
            case TPM_ALG_ID.HMAC: u = new TPMT_HA(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_SCHEME_HASH(); break;
            case TPM_ALG_ID.NULL: u = new TPMS_NULL_SIGNATURE(); break;
        }
        break;
    case 'TPMU_PUBLIC_ID':
        switch (selector) {
            case TPM_ALG_ID.KEYEDHASH: u = new TPM2B_DIGEST_Keyedhash(); break;
            case TPM_ALG_ID.SYMCIPHER: u = new TPM2B_DIGEST_Symcipher(); break;
            case TPM_ALG_ID.RSA: u = new TPM2B_PUBLIC_KEY_RSA(); break;
            case TPM_ALG_ID.ECC: u = new TPMS_ECC_POINT(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_DERIVE(); break;
        }
        break;
    case 'TPMU_PUBLIC_PARMS':
        switch (selector) {
            case TPM_ALG_ID.KEYEDHASH: u = new TPMS_KEYEDHASH_PARMS(); break;
            case TPM_ALG_ID.SYMCIPHER: u = new TPMS_SYMCIPHER_PARMS(); break;
            case TPM_ALG_ID.RSA: u = new TPMS_RSA_PARMS(); break;
            case TPM_ALG_ID.ECC: u = new TPMS_ECC_PARMS(); break;
            case TPM_ALG_ID.ANY: u = new TPMS_ASYM_PARMS(); break;
        }
        break;
    case 'TPMU_SENSITIVE_COMPOSITE':
        switch (selector) {
            case TPM_ALG_ID.RSA: u = new TPM2B_PRIVATE_KEY_RSA(); break;
            case TPM_ALG_ID.ECC: u = new TPM2B_ECC_PARAMETER(); break;
            case TPM_ALG_ID.KEYEDHASH: u = new TPM2B_SENSITIVE_DATA(); break;
            case TPM_ALG_ID.SYMCIPHER: u = new TPM2B_SYM_KEY(); break;
            case TPM_ALG_ID.ANY: u = new TPM2B_PRIVATE_VENDOR_SPECIFIC(); break;
        }
        break;
    default:
        throw new Error('CreateUnion(' + unionType + ', ' + selector + '): Unrecognized union type');
    }
    if (u == null)
        throw new Error("Unknown selector value" + selector + " for " + unionType +  " union");
    return u as U;
} // createUnion()
/**
* Base class for empty union elements. An empty union element does not contain any data to marshal. This data structure can be used in place of any other union initialized with its own empty element.
*/
export class TPMS_NULL_UNION extends TpmStructure implements TPMU_SYM_KEY_BITS, TPMU_SYM_MODE, TPMU_SYM_DETAILS, TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME, TPMU_KDF_SCHEME, TPMU_ASYM_SCHEME, TPMU_SIGNATURE 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // TPMS_NULL_UNION

/**
* TPM Hash structure
*/
export class TPMT_HA extends TpmStructure implements TPMU_SIGNATURE
{
    constructor(
        /**
        * Algorithm
        */
        public hashAlg: TPM_ALG_ID = 0,
        /**
        * Hash value
        */
        public digest: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.HMAC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hashAlg, 2);
        buf.toTpm2B(this.digest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hashAlg = buf.fromTpm(2);
        this.digest = buf.bufferFromTpm(Crypto.digestSize(this.hashAlg));
    }
} // TPMT_HA

/**
* TPM object handle (and related data)
*/
export class TPM_HANDLE extends TpmStructure
{
    constructor(
        /**
        * TPM key handle
        */
        public handle: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.handle, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.fromTpm(4);
    }
} // TPM_HANDLE

/**
* This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected.
*/
export class TPMS_EMPTY extends TpmStructure implements TPMU_ASYM_SCHEME 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSAES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // TPMS_EMPTY

/**
* This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.
*/
export class TPMS_ALGORITHM_DESCRIPTION extends TpmStructure
{
    constructor(
        /**
        * an algorithm
        */
        public alg: TPM_ALG_ID = 0,
        /**
        * the attributes of the algorithm
        */
        public attributes: TPMA_ALGORITHM = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.alg, 2);
        buf.toTpm(this.attributes, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.alg = buf.fromTpm(2);
        this.attributes = buf.fromTpm(4);
    }
} // TPMS_ALGORITHM_DESCRIPTION

/**
* This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM.
*/
export class TPM2B_DIGEST extends TpmStructure implements TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KEYEDHASH;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_DIGEST

/**
* This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
*/
export class TPM2B_DATA extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_DATA

/**
* Table 76 Definition of Types for TPM2B_NONCE
*/
export class TPM2B_NONCE extends TPM2B_DIGEST
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        buffer: Buffer = null
    ) { super(buffer); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPM2B_NONCE

/**
* This structure is used for an authorization value and limits an authValue to being no larger than the largest digest produced by a TPM. In order to ensure consistency within an object, the authValue may be no larger than the size of the digest produced by the objects nameAlg. This ensures that any TPM that can load the object will be able to handle the authValue of the object.
*/
export class TPM2B_AUTH extends TPM2B_DIGEST
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        buffer: Buffer = null
    ) { super(buffer); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPM2B_AUTH

/**
* This type is a sized buffer that can hold an operand for a comparison with an NV Index location. The maximum size of the operand is implementation dependent but a TPM is required to support an operand size that is at least as big as the digest produced by any of the hash algorithms implemented on the TPM.
*/
export class TPM2B_OPERAND extends TPM2B_DIGEST
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        buffer: Buffer = null
    ) { super(buffer); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPM2B_OPERAND

/**
* This type is a sized buffer that can hold event data.
*/
export class TPM2B_EVENT extends TpmStructure
{
    constructor(
        /**
        * the operand
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_EVENT

/**
* This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
*/
export class TPM2B_MAX_BUFFER extends TpmStructure
{
    constructor(
        /**
        * the operand
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_MAX_BUFFER

/**
* This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
*/
export class TPM2B_MAX_NV_BUFFER extends TpmStructure
{
    constructor(
        /**
        * the operand NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_MAX_NV_BUFFER

/**
* This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less.
*/
export class TPM2B_TIMEOUT extends TpmStructure
{
    constructor(
        /**
        * the timeout value
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_TIMEOUT

/**
* This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM.
*/
export class TPM2B_IV extends TpmStructure
{
    constructor(
        /**
        * the IV value
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_IV

/**
* This buffer holds a Name for any entity type.
*/
export class TPM2B_NAME extends TpmStructure
{
    constructor(
        /**
        * the Name structure
        */
        public name: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.name);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.name = buf.fromTpm2B(2);
    }
} // TPM2B_NAME

/**
* This structure provides a standard method of specifying a list of PCR.
*/
export class TPMS_PCR_SELECT extends TpmStructure
{
    constructor(
        /**
        * the bit map of selected PCR
        */
        public pcrSelect: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.pcrSelect);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrSelect = buf.fromTpm2B(1);
    }
} // TPMS_PCR_SELECT

/**
* Table 87 Definition of TPMS_PCR_SELECTION Structure
*/
export class TPMS_PCR_SELECTION extends TpmStructure
{
    constructor(
        /**
        * the hash algorithm associated with the selection
        */
        public hash: TPM_ALG_ID = 0,
        /**
        * the bit map of selected PCR
        */
        public pcrSelect: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hash, 2);
        buf.toTpm2B(this.pcrSelect);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hash = buf.fromTpm(2);
        this.pcrSelect = buf.fromTpm2B(1);
    }
} // TPMS_PCR_SELECTION

/**
* This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by
*/
export class TPMT_TK_CREATION extends TpmStructure
{
    constructor(
        /**
        * ticket structure tag
        */
        public tag: TPM_ST = 0,
        /**
        * the hierarchy containing name
        */
        public hierarchy: TPM_HANDLE = null,
        /**
        * This shall be the HMAC produced using a proof value of hierarchy.
        */
        public digest: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 2);
        this.hierarchy.toTpm(buf);
        buf.toTpm2B(this.digest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
    }
} // TPMT_TK_CREATION

/**
* This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by
*/
export class TPMT_TK_VERIFIED extends TpmStructure
{
    constructor(
        /**
        * ticket structure tag
        */
        public tag: TPM_ST = 0,
        /**
        * the hierarchy containing keyName
        */
        public hierarchy: TPM_HANDLE = null,
        /**
        * This shall be the HMAC produced using a proof value of hierarchy.
        */
        public digest: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 2);
        this.hierarchy.toTpm(buf);
        buf.toTpm2B(this.digest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
    }
} // TPMT_TK_VERIFIED

/**
* This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by
*/
export class TPMT_TK_AUTH extends TpmStructure
{
    constructor(
        /**
        * ticket structure tag
        */
        public tag: TPM_ST = 0,
        /**
        * the hierarchy of the object used to produce the ticket
        */
        public hierarchy: TPM_HANDLE = null,
        /**
        * This shall be the HMAC produced using a proof value of hierarchy.
        */
        public digest: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 2);
        this.hierarchy.toTpm(buf);
        buf.toTpm2B(this.digest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.tag = buf.fromTpm(2);
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
    }
} // TPMT_TK_AUTH

/**
* This ticket is produced by TPM2_SequenceComplete() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
*/
export class TPMT_TK_HASHCHECK extends TpmStructure
{
    constructor(
        /**
        * ticket structure tag
        */
        public tag: TPM_ST = 0,
        /**
        * the hierarchy
        */
        public hierarchy: TPM_HANDLE = null,
        /**
        * This shall be the HMAC produced using a proof value of hierarchy.
        */
        public digest: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 2);
        this.hierarchy.toTpm(buf);
        buf.toTpm2B(this.digest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
    }
} // TPMT_TK_HASHCHECK

/**
* This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
*/
export class TPMS_ALG_PROPERTY extends TpmStructure
{
    constructor(
        /**
        * an algorithm identifier
        */
        public alg: TPM_ALG_ID = 0,
        /**
        * the attributes of the algorithm
        */
        public algProperties: TPMA_ALGORITHM = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.alg, 2);
        buf.toTpm(this.algProperties, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.alg = buf.fromTpm(2);
        this.algProperties = buf.fromTpm(4);
    }
} // TPMS_ALG_PROPERTY

/**
* This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability().
*/
export class TPMS_TAGGED_PROPERTY extends TpmStructure
{
    constructor(
        /**
        * a property identifier
        */
        public property: TPM_PT = 0,
        /**
        * the value of the property
        */
        public value: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.property, 4);
        buf.toTpm(this.value, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.property = buf.fromTpm(4);
        this.value = buf.fromTpm(4);
    }
} // TPMS_TAGGED_PROPERTY

/**
* This structure is used in TPM2_GetCapability() to return the attributes of the PCR.
*/
export class TPMS_TAGGED_PCR_SELECT extends TpmStructure
{
    constructor(
        /**
        * the property identifier
        */
        public tag: TPM_PT_PCR = 0,
        /**
        * the bit map of PCR with the identified property
        */
        public pcrSelect: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 4);
        buf.toTpm2B(this.pcrSelect);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.tag = buf.fromTpm(4);
        this.pcrSelect = buf.fromTpm2B(1);
    }
} // TPMS_TAGGED_PCR_SELECT

/**
* This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle.
*/
export class TPMS_TAGGED_POLICY extends TpmStructure
{
    constructor(
        /**
        * a permanent handle
        */
        public handle: TPM_HANDLE = null,
        /**
        * the policy algorithm and hash
        */
        public policyHash: TPMT_HA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        this.policyHash.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.policyHash = buf.createFromTpm(TPMT_HA);
    }
} // TPMS_TAGGED_POLICY

/**
* A list of command codes may be input to the TPM or returned by the TPM depending on the command.
*/
export class TPML_CC extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * a list of command codes The maximum only applies to a command code list in a command. The response size is limited only by the size of the parameter buffer.
        */
        public commandCodes: TPM_CC[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.PP_COMMANDS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_CC>(this.commandCodes, 4, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.commandCodes = buf.valArrFromTpm(4, 4);
    }
} // TPML_CC

/**
* This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).
*/
export class TPML_CCA extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * a list of command codes attributes
        */
        public commandAttributes: TPMA_CC[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.COMMANDS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPMA_CC>(this.commandAttributes, 4, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.commandAttributes = buf.valArrFromTpm(4, 4);
    }
} // TPML_CCA

/**
* This list is returned by TPM2_IncrementalSelfTest().
*/
export class TPML_ALG extends TpmStructure
{
    constructor(
        /**
        * a list of algorithm IDs The maximum only applies to an algorithm list in a command. The response size is limited only by the size of the parameter buffer.
        */
        public algorithms: TPM_ALG_ID[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_ALG_ID>(this.algorithms, 2, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.algorithms = buf.valArrFromTpm(2, 4);
    }
} // TPML_ALG

/**
* This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
*/
export class TPML_HANDLE extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * an array of handles
        */
        public handle: TPM_HANDLE[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.HANDLES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPM_HANDLE>(this.handle, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.arrayFromTpm(TPM_HANDLE, 4);
    }
} // TPML_HANDLE

/**
* This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read().
*/
export class TPML_DIGEST extends TpmStructure
{
    constructor(
        /**
        * a list of digests For TPM2_PolicyOR(), all digests will have been computed using the digest of the policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for the bank containing the PCR.
        */
        public digests: TPM2B_DIGEST[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPM2B_DIGEST>(this.digests, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.digests = buf.arrayFromTpm(TPM2B_DIGEST, 4);
    }
} // TPML_DIGEST

/**
* This list is used to convey a list of digest values. This type is returned by TPM2_Event() and TPM2_SequenceComplete() and is an input for TPM2_PCR_Extend().
*/
export class TPML_DIGEST_VALUES extends TpmStructure
{
    constructor(
        /**
        * a list of tagged digests
        */
        public digests: TPMT_HA[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMT_HA>(this.digests, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.digests = buf.arrayFromTpm(TPMT_HA, 4);
    }
} // TPML_DIGEST_VALUES

/**
* This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected.
*/
export class TPML_PCR_SELECTION extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * list of selections
        */
        public pcrSelections: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.PCRS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrSelections, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrSelections = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPML_PCR_SELECTION

/**
* This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability().
*/
export class TPML_ALG_PROPERTY extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * list of properties
        */
        public algProperties: TPMS_ALG_PROPERTY[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.ALGS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_ALG_PROPERTY>(this.algProperties, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.algProperties = buf.arrayFromTpm(TPMS_ALG_PROPERTY, 4);
    }
} // TPML_ALG_PROPERTY

/**
* This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability().
*/
export class TPML_TAGGED_TPM_PROPERTY extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * an array of tagged properties
        */
        public tpmProperty: TPMS_TAGGED_PROPERTY[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.TPM_PROPERTIES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_TAGGED_PROPERTY>(this.tpmProperty, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.tpmProperty = buf.arrayFromTpm(TPMS_TAGGED_PROPERTY, 4);
    }
} // TPML_TAGGED_TPM_PROPERTY

/**
* This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability().
*/
export class TPML_TAGGED_PCR_PROPERTY extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * a tagged PCR selection
        */
        public pcrProperty: TPMS_TAGGED_PCR_SELECT[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.PCR_PROPERTIES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_TAGGED_PCR_SELECT>(this.pcrProperty, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrProperty = buf.arrayFromTpm(TPMS_TAGGED_PCR_SELECT, 4);
    }
} // TPML_TAGGED_PCR_PROPERTY

/**
* This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability().
*/
export class TPML_ECC_CURVE extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * array of ECC curve identifiers
        */
        public eccCurves: TPM_ECC_CURVE[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.ECC_CURVES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_ECC_CURVE>(this.eccCurves, 2, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.eccCurves = buf.valArrFromTpm(2, 4);
    }
} // TPML_ECC_CURVE

/**
* This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list.
*/
export class TPML_TAGGED_POLICY extends TpmStructure implements TPMU_CAPABILITIES 
{
    constructor(
        /**
        * array of tagged policies
        */
        public policies: TPMS_TAGGED_POLICY[] = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_CAP
    {
        return TPM_CAP.AUTH_POLICIES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_TAGGED_POLICY>(this.policies, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policies = buf.arrayFromTpm(TPMS_TAGGED_POLICY, 4);
    }
} // TPML_TAGGED_POLICY

/**
* This data area is returned in response to a TPM2_GetCapability().
*/
export class TPMS_CAPABILITY_DATA extends TpmStructure
{
    constructor(
        /**
        * the capability data (One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)
        */
        public data: TPMU_CAPABILITIES = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.data.GetUnionSelector(), 4);
        this.data.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let capability: TPM_CAP = buf.fromTpm(4);
        this.data = createUnion<TPMU_CAPABILITIES>('TPMU_CAPABILITIES', capability);
        this.data.fromTpm(buf);
    }
} // TPMS_CAPABILITY_DATA

/**
* This structure is used in each of the attestation commands.
*/
export class TPMS_CLOCK_INFO extends TpmStructure
{
    constructor(
        /**
        * time value in milliseconds that advances while the TPM is powered NOTE The interpretation of the time-origin (clock=0) is out of the scope of this specification, although Coordinated Universal Time (UTC) is expected to be a common convention. This structure element is used to report on the TPM's Clock value. This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()). This value may be advanced by TPM2_ClockSet().
        */
        public clock: number = 0,
        /**
        * number of occurrences of TPM Reset since the last TPM2_Clear()
        */
        public resetCount: number = 0,
        /**
        * number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last TPM Reset or TPM2_Clear().
        */
        public restartCount: number = 0,
        /**
        * no value of Clock greater than the current value of Clock has been previously reported by the TPM. Set to YES on TPM2_Clear().
        */
        public safe: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.clock, 8);
        buf.toTpm(this.resetCount, 4);
        buf.toTpm(this.restartCount, 4);
        buf.toTpm(this.safe, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.clock = buf.fromTpm(8);
        this.resetCount = buf.fromTpm(4);
        this.restartCount = buf.fromTpm(4);
        this.safe = buf.fromTpm(1);
    }
} // TPMS_CLOCK_INFO

/**
* This structure is used in the TPM2_GetTime() attestation.
*/
export class TPMS_TIME_INFO extends TpmStructure
{
    constructor(
        /**
        * time in milliseconds since the last _TPM_Init() or TPM2_Startup() This structure element is used to report on the TPM's Time value.
        */
        public time: number = 0,
        /**
        * a structure containing the clock information
        */
        public clockInfo: TPMS_CLOCK_INFO = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.time, 8);
        this.clockInfo.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.time = buf.fromTpm(8);
        this.clockInfo = buf.createFromTpm(TPMS_CLOCK_INFO);
    }
} // TPMS_TIME_INFO

/**
* This structure is used when the TPM performs TPM2_GetTime.
*/
export class TPMS_TIME_ATTEST_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * the Time, Clock, resetCount, restartCount, and Safe indicator
        */
        public time: TPMS_TIME_INFO = null,
        /**
        * a TPM vendor-specific value indicating the version number of the firmware
        */
        public firmwareVersion: number = 0
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_TIME;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.time.toTpm(buf);
        buf.toTpm(this.firmwareVersion, 8);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.time = buf.createFromTpm(TPMS_TIME_INFO);
        this.firmwareVersion = buf.fromTpm(8);
    }
} // TPMS_TIME_ATTEST_INFO

/**
* This is the attested data for TPM2_Certify().
*/
export class TPMS_CERTIFY_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * Name of the certified object
        */
        public name: Buffer = null,
        /**
        * Qualified Name of the certified object
        */
        public qualifiedName: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_CERTIFY;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.name);
        buf.toTpm2B(this.qualifiedName);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.name = buf.fromTpm2B(2);
        this.qualifiedName = buf.fromTpm2B(2);
    }
} // TPMS_CERTIFY_INFO

/**
* This is the attested data for TPM2_Quote().
*/
export class TPMS_QUOTE_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * information on algID, PCR selected and digest
        */
        public pcrSelect: TPMS_PCR_SELECTION[] = null,
        /**
        * digest of the selected PCR using the hash of the signing key
        */
        public pcrDigest: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_QUOTE;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrSelect, 4);
        buf.toTpm2B(this.pcrDigest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrSelect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
        this.pcrDigest = buf.fromTpm2B(2);
    }
} // TPMS_QUOTE_INFO

/**
* This is the attested data for TPM2_GetCommandAuditDigest().
*/
export class TPMS_COMMAND_AUDIT_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * the monotonic audit counter
        */
        public auditCounter: number = 0,
        /**
        * hash algorithm used for the command audit
        */
        public digestAlg: TPM_ALG_ID = 0,
        /**
        * the current value of the audit digest
        */
        public auditDigest: Buffer = null,
        /**
        * digest of the command codes being audited using digestAlg
        */
        public commandDigest: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_COMMAND_AUDIT;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.auditCounter, 8);
        buf.toTpm(this.digestAlg, 2);
        buf.toTpm2B(this.auditDigest);
        buf.toTpm2B(this.commandDigest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auditCounter = buf.fromTpm(8);
        this.digestAlg = buf.fromTpm(2);
        this.auditDigest = buf.fromTpm2B(2);
        this.commandDigest = buf.fromTpm2B(2);
    }
} // TPMS_COMMAND_AUDIT_INFO

/**
* This is the attested data for TPM2_GetSessionAuditDigest().
*/
export class TPMS_SESSION_AUDIT_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * current exclusive status of the session TRUE if all of the commands recorded in the sessionDigest were executed without any intervening TPM command that did not use this audit session
        */
        public exclusiveSession: number = 0,
        /**
        * the current value of the session audit digest
        */
        public sessionDigest: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_SESSION_AUDIT;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.exclusiveSession, 1);
        buf.toTpm2B(this.sessionDigest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.exclusiveSession = buf.fromTpm(1);
        this.sessionDigest = buf.fromTpm2B(2);
    }
} // TPMS_SESSION_AUDIT_INFO

/**
* This is the attested data for TPM2_CertifyCreation().
*/
export class TPMS_CREATION_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * Name of the object
        */
        public objectName: Buffer = null,
        /**
        * creationHash
        */
        public creationHash: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_CREATION;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.objectName);
        buf.toTpm2B(this.creationHash);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.objectName = buf.fromTpm2B(2);
        this.creationHash = buf.fromTpm2B(2);
    }
} // TPMS_CREATION_INFO

/**
* This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify().
*/
export class TPMS_NV_CERTIFY_INFO extends TpmStructure implements TPMU_ATTEST 
{
    constructor(
        /**
        * Name of the NV Index
        */
        public indexName: Buffer = null,
        /**
        * the offset parameter of TPM2_NV_Certify()
        */
        public offset: number = 0,
        /**
        * contents of the NV Index
        */
        public nvContents: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ST
    {
        return TPM_ST.ATTEST_NV;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.indexName);
        buf.toTpm(this.offset, 2);
        buf.toTpm2B(this.nvContents);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.indexName = buf.fromTpm2B(2);
        this.offset = buf.fromTpm(2);
        this.nvContents = buf.fromTpm2B(2);
    }
} // TPMS_NV_CERTIFY_INFO

/**
* This structure is used on each TPM-generated signed structure. The signature is over this structure.
*/
export class TPMS_ATTEST extends TpmStructure
{
    constructor(
        /**
        * the indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
        */
        public magic: TPM_GENERATED = 0,
        /**
        * Qualified Name of the signing key
        */
        public qualifiedSigner: Buffer = null,
        /**
        * external information supplied by caller NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to indicate the components of the digest. The definition of this method indicator is outside the scope of this specification.
        */
        public extraData: Buffer = null,
        /**
        * Clock, resetCount, restartCount, and Safe
        */
        public clockInfo: TPMS_CLOCK_INFO = null,
        /**
        * TPM-vendor-specific value identifying the version number of the firmware
        */
        public firmwareVersion: number = 0,
        /**
        * the type-specific attestation information (One of TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO, TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO, TPMS_NV_CERTIFY_INFO)
        */
        public attested: TPMU_ATTEST = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.magic, 4);
        buf.toTpm(this.attested.GetUnionSelector(), 2);
        buf.toTpm2B(this.qualifiedSigner);
        buf.toTpm2B(this.extraData);
        this.clockInfo.toTpm(buf);
        buf.toTpm(this.firmwareVersion, 8);
        this.attested.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.magic = buf.fromTpm(4);
        let type: TPM_ST = buf.fromTpm(2);
        this.qualifiedSigner = buf.fromTpm2B(2);
        this.extraData = buf.fromTpm2B(2);
        this.clockInfo = buf.createFromTpm(TPMS_CLOCK_INFO);
        this.firmwareVersion = buf.fromTpm(8);
        this.attested = createUnion<TPMU_ATTEST>('TPMU_ATTEST', type);
        this.attested.fromTpm(buf);
    }
} // TPMS_ATTEST

/**
* This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed.
*/
export class TPM2B_ATTEST extends TpmStructure
{
    constructor(
        /**
        * the signed structure
        */
        public attestationData: TPMS_ATTEST = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.attestationData, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.attestationData = buf.sizedFromTpm(TPMS_ATTEST, 2);
    }
} // TPM2B_ATTEST

/**
* This is the format used for each of the authorizations in the session area of a command.
*/
export class TPMS_AUTH_COMMAND extends TpmStructure
{
    constructor(
        /**
        * the session handle
        */
        public sessionHandle: TPM_HANDLE = null,
        /**
        * the session nonce, may be the Empty Buffer
        */
        public nonce: Buffer = null,
        /**
        * the session attributes
        */
        public sessionAttributes: TPMA_SESSION = 0,
        /**
        * either an HMAC, a password, or an EmptyAuth
        */
        public hmac: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.sessionHandle.toTpm(buf);
        buf.toTpm2B(this.nonce);
        buf.toTpm(this.sessionAttributes, 1);
        buf.toTpm2B(this.hmac);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE);
        this.nonce = buf.fromTpm2B(2);
        this.sessionAttributes = buf.fromTpm(1);
        this.hmac = buf.fromTpm2B(2);
    }
} // TPMS_AUTH_COMMAND

/**
* This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order.
*/
export class TPMS_AUTH_RESPONSE extends TpmStructure
{
    constructor(
        /**
        * the session nonce, may be the Empty Buffer
        */
        public nonce: Buffer = null,
        /**
        * the session attributes
        */
        public sessionAttributes: TPMA_SESSION = 0,
        /**
        * either an HMAC or an EmptyAuth
        */
        public hmac: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nonce);
        buf.toTpm(this.sessionAttributes, 1);
        buf.toTpm2B(this.hmac);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nonce = buf.fromTpm2B(2);
        this.sessionAttributes = buf.fromTpm(1);
        this.hmac = buf.fromTpm2B(2);
    }
} // TPMS_AUTH_RESPONSE

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
*/
export class TPMS_NULL_SYM_KEY_BITS extends TPMS_NULL_UNION implements TPMU_SYM_KEY_BITS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SYM_KEY_BITS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
*/
export class TPMS_XOR_SYM_MODE extends TPMS_NULL_UNION implements TPMU_SYM_MODE 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.XOR;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_XOR_SYM_MODE

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
*/
export class TPMS_NULL_SYM_MODE extends TPMS_NULL_UNION implements TPMU_SYM_MODE 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SYM_MODE

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
*/
export class TPMS_TDES_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.TDES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_TDES_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
*/
export class TPMS_AES_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.AES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_AES_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
*/
export class TPMS_SM4_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SM4;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SM4_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
*/
export class TPMS_CAMELLIA_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.CAMELLIA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_CAMELLIA_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
*/
export class TPMS_ANY_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ANY;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_ANY_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
*/
export class TPMS_XOR_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.XOR;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_XOR_SYM_DETAILS

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
*/
export class TPMS_NULL_SYM_DETAILS extends TPMS_NULL_UNION implements TPMU_SYM_DETAILS 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SYM_DETAILS

/**
* The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected.
*/
export class TPMT_SYM_DEF extends TpmStructure
{
    constructor(
        /**
        * symmetric algorithm
        */
        public algorithm: TPM_ALG_ID = 0,
        /**
        * key size in bits
        */
        public keyBits: number = 0,
        /**
        * encryption mode
        */
        public mode: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        nonStandardToTpm(this, buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        nonStandardFromTpm(this, buf);
    }
} // TPMT_SYM_DEF

/**
* This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field.
*/
export class TPMT_SYM_DEF_OBJECT extends TpmStructure
{
    constructor(
        /**
        * symmetric algorithm
        */
        public algorithm: TPM_ALG_ID = 0,
        /**
        * key size in bits
        */
        public keyBits: number = 0,
        /**
        * encryption mode
        */
        public mode: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        nonStandardToTpm(this, buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        nonStandardFromTpm(this, buf);
    }
} // TPMT_SYM_DEF_OBJECT

/**
* This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.
*/
export class TPM2B_SYM_KEY extends TpmStructure implements TPMU_SENSITIVE_COMPOSITE 
{
    constructor(
        /**
        * the key
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SYMCIPHER;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_SYM_KEY

/**
* This structure contains the parameters for a symmetric block cipher object.
*/
export class TPMS_SYMCIPHER_PARMS extends TpmStructure implements TPMU_PUBLIC_PARMS 
{
    constructor(
        /**
        * a symmetric block cipher
        */
        public sym: TPMT_SYM_DEF_OBJECT = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SYMCIPHER;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.sym.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sym = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
    }
} // TPMS_SYMCIPHER_PARMS

/**
* This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
*/
export class TPM2B_LABEL extends TpmStructure
{
    constructor(
        /**
        * symmetic data for a created object or the label and context for a derived object
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_LABEL

/**
* This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter.
*/
export class TPMS_DERIVE extends TpmStructure implements TPMU_SENSITIVE_CREATE, TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * -
        */
        public label: Buffer = null,
        /**
        * -
        */
        public context: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ANY2;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.label);
        buf.toTpm2B(this.context);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.label = buf.fromTpm2B(2);
        this.context = buf.fromTpm2B(2);
    }
} // TPMS_DERIVE

/**
* Table 137 Definition of TPM2B_DERIVE Structure
*/
export class TPM2B_DERIVE extends TpmStructure
{
    constructor(
        /**
        * symmetic data for a created object or the label and context for a derived object
        */
        public buffer: TPMS_DERIVE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.buffer, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.sizedFromTpm(TPMS_DERIVE, 2);
    }
} // TPM2B_DERIVE

/**
* This buffer wraps the TPMU_SENSITIVE_CREATE structure.
*/
export class TPM2B_SENSITIVE_DATA extends TpmStructure implements TPMU_SENSITIVE_COMPOSITE 
{
    constructor(
        /**
        * symmetic data for a created object or the label and context for a derived object
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KEYEDHASH;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_SENSITIVE_DATA

/**
* This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
*/
export class TPMS_SENSITIVE_CREATE extends TpmStructure
{
    constructor(
        /**
        * the USER auth secret value
        */
        public userAuth: Buffer = null,
        /**
        * data to be sealed, a key, or derivation values
        */
        public data: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.userAuth);
        buf.toTpm2B(this.data);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.userAuth = buf.fromTpm2B(2);
        this.data = buf.fromTpm2B(2);
    }
} // TPMS_SENSITIVE_CREATE

/**
* This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes.
*/
export class TPM2B_SENSITIVE_CREATE extends TpmStructure
{
    constructor(
        /**
        * data to be sealed or a symmetric key value.
        */
        public sensitive: TPMS_SENSITIVE_CREATE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.sensitive, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2);
    }
} // TPM2B_SENSITIVE_CREATE

/**
* This structure is the scheme data for schemes that only require a hash to complete their definition.
*/
export class TPMS_SCHEME_HASH extends TpmStructure implements TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME, TPMU_KDF_SCHEME, TPMU_ASYM_SCHEME, TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        public hashAlg: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.HMAC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hashAlg, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hashAlg = buf.fromTpm(2);
    }
} // TPMS_SCHEME_HASH

/**
* This definition is for split signing schemes that require a commit count.
*/
export class TPMS_SCHEME_ECDAA extends TpmStructure implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        public hashAlg: TPM_ALG_ID = 0,
        /**
        * the counter value that is used between TPM2_Commit() and the sign operation
        */
        public count: number = 0
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDAA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hashAlg, 2);
        buf.toTpm(this.count, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hashAlg = buf.fromTpm(2);
        this.count = buf.fromTpm(2);
    }
} // TPMS_SCHEME_ECDAA

/**
* Table 145 Definition of Types for HMAC_SIG_SCHEME
*/
export class TPMS_SCHEME_HMAC extends TPMS_SCHEME_HASH implements TPMU_SCHEME_KEYEDHASH, TPMU_SIG_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.HMAC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_HMAC

/**
* This structure is for the XOR encryption scheme.
*/
export class TPMS_SCHEME_XOR extends TpmStructure implements TPMU_SCHEME_KEYEDHASH 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        public hashAlg: TPM_ALG_ID = 0,
        /**
        * the key derivation function
        */
        public kdf: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.XOR;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hashAlg, 2);
        buf.toTpm(this.kdf, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hashAlg = buf.fromTpm(2);
        this.kdf = buf.fromTpm(2);
    }
} // TPMS_SCHEME_XOR

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
*/
export class TPMS_NULL_SCHEME_KEYEDHASH extends TPMS_NULL_UNION implements TPMU_SCHEME_KEYEDHASH 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SCHEME_KEYEDHASH

/**
* This structure is used for a hash signing object.
*/
export class TPMT_KEYEDHASH_SCHEME extends TpmStructure
{
    constructor(
        /**
        * the scheme parameters (One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)
        */
        public details: TPMU_SCHEME_KEYEDHASH = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_SCHEME_KEYEDHASH>('TPMU_SCHEME_KEYEDHASH', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_KEYEDHASH_SCHEME

/**
* These are the RSA schemes that only need a hash algorithm as a scheme parameter.
*/
export class TPMS_SIG_SCHEME_RSASSA extends TPMS_SCHEME_HASH implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSASSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_RSASSA

/**
* These are the RSA schemes that only need a hash algorithm as a scheme parameter.
*/
export class TPMS_SIG_SCHEME_RSAPSS extends TPMS_SCHEME_HASH implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSAPSS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_RSAPSS

/**
* Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SIG_SCHEME_ECDSA extends TPMS_SCHEME_HASH implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_ECDSA

/**
* Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SIG_SCHEME_SM2 extends TPMS_SCHEME_HASH implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SM2;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_SM2

/**
* Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SIG_SCHEME_ECSCHNORR extends TPMS_SCHEME_HASH implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECSCHNORR;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_ECSCHNORR

/**
* Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SIG_SCHEME_ECDAA extends TPMS_SCHEME_ECDAA implements TPMU_SIG_SCHEME, TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0,
        /**
        * the counter value that is used between TPM2_Commit() and the sign operation
        */
        count: number = 0
    ) { super(hashAlg,count); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDAA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIG_SCHEME_ECDAA

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
*/
export class TPMS_NULL_SIG_SCHEME extends TPMS_NULL_UNION implements TPMU_SIG_SCHEME 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SIG_SCHEME

/**
* Table 152 Definition of TPMT_SIG_SCHEME Structure
*/
export class TPMT_SIG_SCHEME extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public details: TPMU_SIG_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_SIG_SCHEME

/**
* These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_ENC_SCHEME_OAEP extends TPMS_SCHEME_HASH implements TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.OAEP;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_ENC_SCHEME_OAEP

/**
* These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_ENC_SCHEME_RSAES extends TPMS_EMPTY implements TPMU_ASYM_SCHEME 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSAES;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_ENC_SCHEME_RSAES

/**
* These are the ECC schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_KEY_SCHEME_ECDH extends TPMS_SCHEME_HASH implements TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDH;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_KEY_SCHEME_ECDH

/**
* These are the ECC schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_KEY_SCHEME_ECMQV extends TPMS_SCHEME_HASH implements TPMU_ASYM_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECMQV;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_KEY_SCHEME_ECMQV

/**
* These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
*/
export class TPMS_SCHEME_MGF1 extends TPMS_SCHEME_HASH implements TPMU_KDF_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.MGF1;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_MGF1

/**
* These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
*/
export class TPMS_SCHEME_KDF1_SP800_56A extends TPMS_SCHEME_HASH implements TPMU_KDF_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KDF1_SP800_56A;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_KDF1_SP800_56A

/**
* These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
*/
export class TPMS_SCHEME_KDF2 extends TPMS_SCHEME_HASH implements TPMU_KDF_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KDF2;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_KDF2

/**
* These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET.
*/
export class TPMS_SCHEME_KDF1_SP800_108 extends TPMS_SCHEME_HASH implements TPMU_KDF_SCHEME 
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KDF1_SP800_108;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_KDF1_SP800_108

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
*/
export class TPMS_NULL_KDF_SCHEME extends TPMS_NULL_UNION implements TPMU_KDF_SCHEME 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_KDF_SCHEME

/**
* Table 157 Definition of TPMT_KDF_SCHEME Structure
*/
export class TPMT_KDF_SCHEME extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        */
        public details: TPMU_KDF_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_KDF_SCHEME>('TPMU_KDF_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_KDF_SCHEME

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
*/
export class TPMS_NULL_ASYM_SCHEME extends TPMS_NULL_UNION implements TPMU_ASYM_SCHEME 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_ASYM_SCHEME

/**
* This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure.
*/
export class TPMT_ASYM_SCHEME extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public details: TPMU_ASYM_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_ASYM_SCHEME

/**
* Table 162 Definition of {RSA} TPMT_RSA_SCHEME Structure
*/
export class TPMT_RSA_SCHEME extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public details: TPMU_ASYM_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_RSA_SCHEME

/**
* Table 164 Definition of {RSA} TPMT_RSA_DECRYPT Structure
*/
export class TPMT_RSA_DECRYPT extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public details: TPMU_ASYM_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_RSA_DECRYPT

/**
* This sized buffer holds the largest RSA public key supported by the TPM.
*/
export class TPM2B_PUBLIC_KEY_RSA extends TpmStructure implements TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * Value
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_PUBLIC_KEY_RSA

/**
* This sized buffer holds the largest RSA prime number supported by the TPM.
*/
export class TPM2B_PRIVATE_KEY_RSA extends TpmStructure implements TPMU_SENSITIVE_COMPOSITE 
{
    constructor(
        /**
        * -
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_PRIVATE_KEY_RSA

/**
* This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.
*/
export class TPM2B_ECC_PARAMETER extends TpmStructure implements TPMU_SENSITIVE_COMPOSITE 
{
    constructor(
        /**
        * the parameter data
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_ECC_PARAMETER

/**
* This structure holds two ECC coordinates that, together, make up an ECC point.
*/
export class TPMS_ECC_POINT extends TpmStructure implements TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * X coordinate
        */
        public x: Buffer = null,
        /**
        * Y coordinate
        */
        public y: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.x);
        buf.toTpm2B(this.y);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.x = buf.fromTpm2B(2);
        this.y = buf.fromTpm2B(2);
    }
} // TPMS_ECC_POINT

/**
* This structure is defined to allow a point to be a single sized parameter so that it may be encrypted.
*/
export class TPM2B_ECC_POINT extends TpmStructure
{
    constructor(
        /**
        * coordinates
        */
        public point: TPMS_ECC_POINT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.point, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.point = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
    }
} // TPM2B_ECC_POINT

/**
* Table 173 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure
*/
export class TPMT_ECC_SCHEME extends TpmStructure
{
    constructor(
        /**
        * scheme parameters (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public details: TPMU_ASYM_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.details.GetUnionSelector(), 2);
        this.details.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let scheme: TPM_ALG_ID = buf.fromTpm(2);
        this.details = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', scheme);
        this.details.fromTpm(buf);
    }
} // TPMT_ECC_SCHEME

/**
* This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters().
*/
export class TPMS_ALGORITHM_DETAIL_ECC extends TpmStructure
{
    constructor(
        /**
        * identifier for the curve
        */
        public curveID: TPM_ECC_CURVE = 0,
        /**
        * Size in bits of the key
        */
        public keySize: number = 0,
        /**
        * if not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        */
        public kdf: TPMU_KDF_SCHEME = null,
        /**
        * If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be used with this curve. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public sign: TPMU_ASYM_SCHEME = null,
        /**
        * Fp (the modulus)
        */
        public p: Buffer = null,
        /**
        * coefficient of the linear term in the curve equation
        */
        public a: Buffer = null,
        /**
        * constant term for curve equation
        */
        public b: Buffer = null,
        /**
        * x coordinate of base point G
        */
        public gX: Buffer = null,
        /**
        * y coordinate of base point G
        */
        public gY: Buffer = null,
        /**
        * order of G
        */
        public n: Buffer = null,
        /**
        * cofactor (a size of zero indicates a cofactor of 1)
        */
        public h: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.curveID, 2);
        buf.toTpm(this.keySize, 2);
        buf.toTpm(this.kdf.GetUnionSelector(), 2);
        this.kdf.toTpm(buf);
        buf.toTpm(this.sign.GetUnionSelector(), 2);
        this.sign.toTpm(buf);
        buf.toTpm2B(this.p);
        buf.toTpm2B(this.a);
        buf.toTpm2B(this.b);
        buf.toTpm2B(this.gX);
        buf.toTpm2B(this.gY);
        buf.toTpm2B(this.n);
        buf.toTpm2B(this.h);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.curveID = buf.fromTpm(2);
        this.keySize = buf.fromTpm(2);
        let kdfScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.kdf = createUnion<TPMU_KDF_SCHEME>('TPMU_KDF_SCHEME', kdfScheme);
        this.kdf.fromTpm(buf);
        let signScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.sign = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', signScheme);
        this.sign.fromTpm(buf);
        this.p = buf.fromTpm2B(2);
        this.a = buf.fromTpm2B(2);
        this.b = buf.fromTpm2B(2);
        this.gX = buf.fromTpm2B(2);
        this.gY = buf.fromTpm2B(2);
        this.n = buf.fromTpm2B(2);
        this.h = buf.fromTpm2B(2);
    }
} // TPMS_ALGORITHM_DETAIL_ECC

/**
* Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
*/
export class TPMS_SIGNATURE_RSA extends TpmStructure implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        */
        public hash: TPM_ALG_ID = 0,
        /**
        * The signature is the size of a public key.
        */
        public sig: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSASSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hash, 2);
        buf.toTpm2B(this.sig);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hash = buf.fromTpm(2);
        this.sig = buf.fromTpm2B(2);
    }
} // TPMS_SIGNATURE_RSA

/**
* Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
*/
export class TPMS_SIGNATURE_RSASSA extends TPMS_SIGNATURE_RSA implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * The signature is the size of a public key.
        */
        sig: Buffer = null
    ) { super(hash,sig); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSASSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_RSASSA

/**
* Table 175 Definition of {RSA} TPMS_SIGNATURE_RSA Structure
*/
export class TPMS_SIGNATURE_RSAPSS extends TPMS_SIGNATURE_RSA implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used to digest the message TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * The signature is the size of a public key.
        */
        sig: Buffer = null
    ) { super(hash,sig); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSAPSS;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_RSAPSS

/**
* Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
*/
export class TPMS_SIGNATURE_ECC extends TpmStructure implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        */
        public hash: TPM_ALG_ID = 0,
        /**
        * -
        */
        public signatureR: Buffer = null,
        /**
        * -
        */
        public signatureS: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.hash, 2);
        buf.toTpm2B(this.signatureR);
        buf.toTpm2B(this.signatureS);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.hash = buf.fromTpm(2);
        this.signatureR = buf.fromTpm2B(2);
        this.signatureS = buf.fromTpm2B(2);
    }
} // TPMS_SIGNATURE_ECC

/**
* Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
*/
export class TPMS_SIGNATURE_ECDSA extends TPMS_SIGNATURE_ECC implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * -
        */
        signatureR: Buffer = null,
        /**
        * -
        */
        signatureS: Buffer = null
    ) { super(hash,signatureR,signatureS); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_ECDSA

/**
* Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
*/
export class TPMS_SIGNATURE_ECDAA extends TPMS_SIGNATURE_ECC implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * -
        */
        signatureR: Buffer = null,
        /**
        * -
        */
        signatureS: Buffer = null
    ) { super(hash,signatureR,signatureS); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECDAA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_ECDAA

/**
* Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
*/
export class TPMS_SIGNATURE_SM2 extends TPMS_SIGNATURE_ECC implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * -
        */
        signatureR: Buffer = null,
        /**
        * -
        */
        signatureS: Buffer = null
    ) { super(hash,signatureR,signatureS); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SM2;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_SM2

/**
* Table 177 Definition of {ECC} TPMS_SIGNATURE_ECC Structure
*/
export class TPMS_SIGNATURE_ECSCHNORR extends TPMS_SIGNATURE_ECC implements TPMU_SIGNATURE 
{
    constructor(
        /**
        * the hash algorithm used in the signature process TPM_ALG_NULL is not allowed.
        */
        hash: TPM_ALG_ID = 0,
        /**
        * -
        */
        signatureR: Buffer = null,
        /**
        * -
        */
        signatureS: Buffer = null
    ) { super(hash,signatureR,signatureS); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECSCHNORR;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SIGNATURE_ECSCHNORR

/**
* Custom data structure representing an empty element (i.e. the one with no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
*/
export class TPMS_NULL_SIGNATURE extends TPMS_NULL_UNION implements TPMU_SIGNATURE 
{
    constructor(
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.NULL;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_NULL_SIGNATURE

/**
* Table 180 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
*/
export class TPMT_SIGNATURE extends TpmStructure
{
    constructor(
        /**
        * This shall be the actual signature information. (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let sigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', sigAlg);
        this.signature.fromTpm(buf);
    }
} // TPMT_SIGNATURE

/**
* Table 182 Definition of TPM2B_ENCRYPTED_SECRET Structure
*/
export class TPM2B_ENCRYPTED_SECRET extends TpmStructure
{
    constructor(
        /**
        * secret
        */
        public secret: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.secret);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.secret = buf.fromTpm2B(2);
    }
} // TPM2B_ENCRYPTED_SECRET

/**
* This structure describes the parameters that would appear in the public area of a KEYEDHASH object.
*/
export class TPMS_KEYEDHASH_PARMS extends TpmStructure implements TPMU_PUBLIC_PARMS 
{
    constructor(
        /**
        * Indicates the signing method used for a keyedHash signing object. This field also determines the size of the data field for a data object created with TPM2_Create() or TPM2_CreatePrimary(). (One of TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH)
        */
        public scheme: TPMU_SCHEME_KEYEDHASH = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KEYEDHASH;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.scheme.GetUnionSelector(), 2);
        this.scheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let schemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.scheme = createUnion<TPMU_SCHEME_KEYEDHASH>('TPMU_SCHEME_KEYEDHASH', schemeScheme);
        this.scheme.fromTpm(buf);
    }
} // TPMS_KEYEDHASH_PARMS

/**
* This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components.
*/
export class TPMS_ASYM_PARMS extends TpmStructure implements TPMU_PUBLIC_PARMS 
{
    constructor(
        /**
        * the companion symmetric algorithm for a restricted decryption key and shall be set to a supported symmetric algorithm This field is optional for keys that are not decryption keys and shall be set to TPM_ALG_NULL if not used.
        */
        public symmetric: TPMT_SYM_DEF_OBJECT = null,
        /**
        * for a key with the sign attribute SET, a valid signing scheme for the key type for a key with the decrypt attribute SET, a valid key exchange protocol for a key with sign and decrypt attributes, shall be TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public scheme: TPMU_ASYM_SCHEME = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ANY;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.symmetric.toTpm(buf);
        buf.toTpm(this.scheme.GetUnionSelector(), 2);
        this.scheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
        let schemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.scheme = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', schemeScheme);
        this.scheme.fromTpm(buf);
    }
} // TPMS_ASYM_PARMS

/**
* A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs.
*/
export class TPMS_RSA_PARMS extends TpmStructure implements TPMU_PUBLIC_PARMS 
{
    constructor(
        /**
        * for a restricted decryption key, shall be set to a supported symmetric algorithm, key size, and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
        */
        public symmetric: TPMT_SYM_DEF_OBJECT = null,
        /**
        * scheme.scheme shall be: for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL unless the object also has the sign attribute for a restricted decryption key, TPM_ALG_NULL NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be TPM_ALG_NULL. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public scheme: TPMU_ASYM_SCHEME = null,
        /**
        * number of bits in the public modulus
        */
        public keyBits: number = 0,
        /**
        * the public exponent A prime number greater than 2.
        */
        public exponent: number = 0
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.RSA;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.symmetric.toTpm(buf);
        buf.toTpm(this.scheme.GetUnionSelector(), 2);
        this.scheme.toTpm(buf);
        buf.toTpm(this.keyBits, 2);
        buf.toTpm(this.exponent, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
        let schemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.scheme = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', schemeScheme);
        this.scheme.fromTpm(buf);
        this.keyBits = buf.fromTpm(2);
        this.exponent = buf.fromTpm(4);
    }
} // TPMS_RSA_PARMS

/**
* This structure contains the parameters for prime modulus ECC.
*/
export class TPMS_ECC_PARMS extends TpmStructure implements TPMU_PUBLIC_PARMS 
{
    constructor(
        /**
        * for a restricted decryption key, shall be set to a supported symmetric algorithm, key size. and mode. if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
        */
        public symmetric: TPMT_SYM_DEF_OBJECT = null,
        /**
        * If the sign attribute of the key is SET, then this shall be a valid signing scheme. NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field shall have the same value. If the decrypt attribute of the key is SET, then this shall be a valid key exchange scheme or TPM_ALG_NULL. If the key is a Storage Key, then this field shall be TPM_ALG_NULL. (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public scheme: TPMU_ASYM_SCHEME = null,
        /**
        * ECC curve ID
        */
        public curveID: TPM_ECC_CURVE = 0,
        /**
        * an optional key derivation scheme for generating a symmetric key from a Z value If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required to be NULL. NOTE There are currently no commands where this parameter has effect and, in the reference code, this field needs to be set to TPM_ALG_NULL. (One of TPMS_SCHEME_MGF1, TPMS_SCHEME_KDF1_SP800_56A, TPMS_SCHEME_KDF2, TPMS_SCHEME_KDF1_SP800_108, TPMS_NULL_KDF_SCHEME)
        */
        public kdf: TPMU_KDF_SCHEME = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ECC;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.symmetric.toTpm(buf);
        buf.toTpm(this.scheme.GetUnionSelector(), 2);
        this.scheme.toTpm(buf);
        buf.toTpm(this.curveID, 2);
        buf.toTpm(this.kdf.GetUnionSelector(), 2);
        this.kdf.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
        let schemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.scheme = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', schemeScheme);
        this.scheme.fromTpm(buf);
        this.curveID = buf.fromTpm(2);
        let kdfScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.kdf = createUnion<TPMU_KDF_SCHEME>('TPMU_KDF_SCHEME', kdfScheme);
        this.kdf.fromTpm(buf);
    }
} // TPMS_ECC_PARMS

/**
* This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM.
*/
export class TPMT_PUBLIC_PARMS extends TpmStructure
{
    constructor(
        /**
        * the algorithm details (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        */
        public parameters: TPMU_PUBLIC_PARMS = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.parameters.GetUnionSelector(), 2);
        this.parameters.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let type: TPM_ALG_ID = buf.fromTpm(2);
        this.parameters = createUnion<TPMU_PUBLIC_PARMS>('TPMU_PUBLIC_PARMS', type);
        this.parameters.fromTpm(buf);
    }
} // TPMT_PUBLIC_PARMS

/**
* Table 191 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg.
*/
export class TPMT_PUBLIC extends TpmStructure
{
    constructor(
        /**
        * algorithm used for computing the Name of the object NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate that the nameAlg may be TPM_ALG_NULL.
        */
        public nameAlg: TPM_ALG_ID = 0,
        /**
        * attributes that, along with type, determine the manipulations of this object
        */
        public objectAttributes: TPMA_OBJECT = 0,
        /**
        * optional policy for using this key The policy is computed using the nameAlg of the object. NOTE Shall be the Empty Policy if no authorization policy is present.
        */
        public authPolicy: Buffer = null,
        /**
        * the algorithm or structure details (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        */
        public parameters: TPMU_PUBLIC_PARMS = null,
        /**
        * the unique identifier of the structure For an asymmetric key, this would be the public key. (One of TPM2B_DIGEST_Keyedhash, TPM2B_DIGEST_Symcipher, TPM2B_PUBLIC_KEY_RSA, TPMS_ECC_POINT, TPMS_DERIVE)
        */
        public unique: TPMU_PUBLIC_ID = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.parameters.GetUnionSelector(), 2);
        buf.toTpm(this.nameAlg, 2);
        buf.toTpm(this.objectAttributes, 4);
        buf.toTpm2B(this.authPolicy);
        this.parameters.toTpm(buf);
        this.unique.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let type: TPM_ALG_ID = buf.fromTpm(2);
        this.nameAlg = buf.fromTpm(2);
        this.objectAttributes = buf.fromTpm(4);
        this.authPolicy = buf.fromTpm2B(2);
        this.parameters = createUnion<TPMU_PUBLIC_PARMS>('TPMU_PUBLIC_PARMS', type);
        this.parameters.fromTpm(buf);
        this.unique = createUnion<TPMU_PUBLIC_ID>('TPMU_PUBLIC_ID', type);
        this.unique.fromTpm(buf);
    }
    /**
     * Returns the TPM name of this object.  The name is the alg-prepended hash of the public area.
     *
     * @return The TPM object name
     */
    public getName(): Buffer
    {
        let pub = super.asTpm();
        let pubHash = Crypto.hash(this.nameAlg, pub);
        let algBuf = new Buffer(2);
        algBuf.writeInt16BE(this.nameAlg, 0);
        return Buffer.concat([algBuf, pubHash]);
    }
} // TPMT_PUBLIC

/**
* This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area.
*/
export class TPM2B_PUBLIC extends TpmStructure
{
    constructor(
        /**
        * the public area NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed for nameAlg.
        */
        public publicArea: TPMT_PUBLIC = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.publicArea, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.publicArea = buf.sizedFromTpm(TPMT_PUBLIC, 2);
    }
} // TPM2B_PUBLIC

/**
* This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().
*/
export class TPM2B_TEMPLATE extends TpmStructure
{
    constructor(
        /**
        * the public area
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_TEMPLATE

/**
* This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations.
*/
export class TPM2B_PRIVATE_VENDOR_SPECIFIC extends TpmStructure implements TPMU_SENSITIVE_COMPOSITE 
{
    constructor(
        /**
        * -
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.ANY;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_PRIVATE_VENDOR_SPECIFIC

/**
* authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
*/
export class TPMT_SENSITIVE extends TpmStructure
{
    constructor(
        /**
        * user authorization data The authValue may be a zero-length string.
        */
        public authValue: Buffer = null,
        /**
        * for a parent object, the optional protection seed; for other objects, the obfuscation value
        */
        public seedValue: Buffer = null,
        /**
        * the type-specific private data (One of TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA, TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC)
        */
        public sensitive: TPMU_SENSITIVE_COMPOSITE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.sensitive.GetUnionSelector(), 2);
        buf.toTpm2B(this.authValue);
        buf.toTpm2B(this.seedValue);
        this.sensitive.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let sensitiveType: TPM_ALG_ID = buf.fromTpm(2);
        this.authValue = buf.fromTpm2B(2);
        this.seedValue = buf.fromTpm2B(2);
        this.sensitive = createUnion<TPMU_SENSITIVE_COMPOSITE>('TPMU_SENSITIVE_COMPOSITE', sensitiveType);
        this.sensitive.fromTpm(buf);
    }
} // TPMT_SENSITIVE

/**
* The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption.
*/
export class TPM2B_SENSITIVE extends TpmStructure
{
    constructor(
        /**
        * an unencrypted sensitive area
        */
        public sensitiveArea: TPMT_SENSITIVE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.sensitiveArea, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sensitiveArea = buf.sizedFromTpm(TPMT_SENSITIVE, 2);
    }
} // TPM2B_SENSITIVE

/**
* This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled.
*/
export class _PRIVATE extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public integrityOuter: Buffer = null,
        /**
        * could also be a TPM2B_IV
        */
        public integrityInner: Buffer = null,
        /**
        * the sensitive area
        */
        public sensitive: TPMT_SENSITIVE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.integrityOuter);
        buf.toTpm2B(this.integrityInner);
        buf.sizedToTpm(this.sensitive, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.integrityOuter = buf.fromTpm2B(2);
        this.integrityInner = buf.fromTpm2B(2);
        this.sensitive = buf.sizedFromTpm(TPMT_SENSITIVE, 2);
    }
} // _PRIVATE

/**
* The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object.
*/
export class TPM2B_PRIVATE extends TpmStructure
{
    constructor(
        /**
        * an encrypted private area
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_PRIVATE

/**
* This structure is used for sizing the TPM2B_ID_OBJECT.
*/
export class TPMS_ID_OBJECT extends TpmStructure
{
    constructor(
        /**
        * HMAC using the nameAlg of the storage key on the target TPM
        */
        public integrityHMAC: Buffer = null,
        /**
        * credential protector information returned if name matches the referenced object All of the encIdentity is encrypted, including the size field. NOTE The TPM is not required to check that the size is not larger than the digest of the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM that has no digest larger than produced by nameAlg.
        */
        public encIdentity: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.integrityHMAC);
        buf.bufferToTpm(this.encIdentity);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.integrityHMAC = buf.fromTpm2B(2);
        this.encIdentity = buf.bufferFromTpm(buf.getCurStuctRemainingSize());
    }
} // TPMS_ID_OBJECT

/**
* This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential().
*/
export class TPM2B_ID_OBJECT extends TpmStructure
{
    constructor(
        /**
        * an encrypted credential area
        */
        public credential: TPMS_ID_OBJECT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.credential, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.credential = buf.sizedFromTpm(TPMS_ID_OBJECT, 2);
    }
} // TPM2B_ID_OBJECT

/**
* This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets.
*/
export class TPMS_NV_PIN_COUNTER_PARAMETERS extends TpmStructure
{
    constructor(
        /**
        * This counter shows the current number of successful authValue authorization attempts to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue authorization attempts to access a TPM_NT_PIN_FAIL index.
        */
        public pinCount: number = 0,
        /**
        * This threshold is the value of pinCount at which the authValue authorization of the host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
        */
        public pinLimit: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.pinCount, 4);
        buf.toTpm(this.pinLimit, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pinCount = buf.fromTpm(4);
        this.pinLimit = buf.fromTpm(4);
    }
} // TPMS_NV_PIN_COUNTER_PARAMETERS

/**
* This structure describes an NV Index.
*/
export class TPMS_NV_PUBLIC extends TpmStructure
{
    constructor(
        /**
        * the handle of the data area
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * hash algorithm used to compute the name of the Index and used for the authPolicy. For an extend index, the hash algorithm used for the extend.
        */
        public nameAlg: TPM_ALG_ID = 0,
        /**
        * the Index attributes
        */
        public attributes: TPMA_NV = 0,
        /**
        * optional access policy for the Index The policy is computed using the nameAlg NOTE Shall be the Empty Policy if no authorization policy is present.
        */
        public authPolicy: Buffer = null,
        /**
        * the size of the data area The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
        */
        public dataSize: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.nvIndex.toTpm(buf);
        buf.toTpm(this.nameAlg, 2);
        buf.toTpm(this.attributes, 4);
        buf.toTpm2B(this.authPolicy);
        buf.toTpm(this.dataSize, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.nameAlg = buf.fromTpm(2);
        this.attributes = buf.fromTpm(4);
        this.authPolicy = buf.fromTpm2B(2);
        this.dataSize = buf.fromTpm(2);
    }
} // TPMS_NV_PUBLIC

/**
* This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.
*/
export class TPM2B_NV_PUBLIC extends TpmStructure
{
    constructor(
        /**
        * the public area
        */
        public nvPublic: TPMS_NV_PUBLIC = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.nvPublic, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvPublic = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2);
    }
} // TPM2B_NV_PUBLIC

/**
* This structure holds the object or session context data. When saved, the full structure is encrypted.
*/
export class TPM2B_CONTEXT_SENSITIVE extends TpmStructure
{
    constructor(
        /**
        * the sensitive data
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2B_CONTEXT_SENSITIVE

/**
* This structure holds the integrity value and the encrypted data for a context.
*/
export class TPMS_CONTEXT_DATA extends TpmStructure
{
    constructor(
        /**
        * the integrity value
        */
        public integrity: Buffer = null,
        /**
        * the sensitive area
        */
        public encrypted: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.integrity);
        buf.bufferToTpm(this.encrypted);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.integrity = buf.fromTpm2B(2);
        this.encrypted = buf.bufferFromTpm(buf.getCurStuctRemainingSize());
    }
} // TPMS_CONTEXT_DATA

/**
* This structure is used in a TPMS_CONTEXT.
*/
export class TPM2B_CONTEXT_DATA extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public buffer: TPMS_CONTEXT_DATA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.buffer, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.buffer = buf.sizedFromTpm(TPMS_CONTEXT_DATA, 2);
    }
} // TPM2B_CONTEXT_DATA

/**
* This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
*/
export class TPMS_CONTEXT extends TpmStructure
{
    constructor(
        /**
        * the sequence number of the context NOTE Transient object contexts and session contexts used different counters.
        */
        public sequence: number = 0,
        /**
        * a handle indicating if the context is a session, object, or sequence object (see Table 212)
        */
        public savedHandle: TPM_HANDLE = null,
        /**
        * the hierarchy of the context
        */
        public hierarchy: TPM_HANDLE = null,
        /**
        * the context data and integrity HMAC
        */
        public contextBlob: TPMS_CONTEXT_DATA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.sequence, 8);
        this.savedHandle.toTpm(buf);
        this.hierarchy.toTpm(buf);
        buf.sizedToTpm(this.contextBlob, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sequence = buf.fromTpm(8);
        this.savedHandle = buf.createFromTpm(TPM_HANDLE);
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
        this.contextBlob = buf.sizedFromTpm(TPMS_CONTEXT_DATA, 2);
    }
} // TPMS_CONTEXT

/**
* This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present.
*/
export class TPMS_CREATION_DATA extends TpmStructure
{
    constructor(
        /**
        * list indicating the PCR included in pcrDigest
        */
        public pcrSelect: TPMS_PCR_SELECTION[] = null,
        /**
        * digest of the selected PCR using nameAlg of the object for which this structure is being created pcrDigest.size shall be zero if the pcrSelect list is empty.
        */
        public pcrDigest: Buffer = null,
        /**
        * the locality at which the object was created
        */
        public locality: TPMA_LOCALITY = 0,
        /**
        * nameAlg of the parent
        */
        public parentNameAlg: TPM_ALG_ID = 0,
        /**
        * Name of the parent at time of creation The size will match digest size associated with parentNameAlg unless it is TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
        */
        public parentName: Buffer = null,
        /**
        * Qualified Name of the parent at the time of creation Size is the same as parentName.
        */
        public parentQualifiedName: Buffer = null,
        /**
        * association with additional information added by the key creator This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
        */
        public outsideInfo: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrSelect, 4);
        buf.toTpm2B(this.pcrDigest);
        buf.toTpm(this.locality, 1);
        buf.toTpm(this.parentNameAlg, 2);
        buf.toTpm2B(this.parentName);
        buf.toTpm2B(this.parentQualifiedName);
        buf.toTpm2B(this.outsideInfo);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrSelect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
        this.pcrDigest = buf.fromTpm2B(2);
        this.locality = buf.fromTpm(1);
        this.parentNameAlg = buf.fromTpm(2);
        this.parentName = buf.fromTpm2B(2);
        this.parentQualifiedName = buf.fromTpm2B(2);
        this.outsideInfo = buf.fromTpm2B(2);
    }
} // TPMS_CREATION_DATA

/**
* This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero.
*/
export class TPM2B_CREATION_DATA extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public creationData: TPMS_CREATION_DATA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.creationData, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2);
    }
} // TPM2B_CREATION_DATA

/**
* TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value.
*/
export class TPMS_AC_OUTPUT extends TpmStructure
{
    constructor(
        /**
        * tag indicating the contents of data
        */
        public tag: TPM_AT = 0,
        /**
        * the data returned from the AC
        */
        public data: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.tag, 4);
        buf.toTpm(this.data, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.tag = buf.fromTpm(4);
        this.data = buf.fromTpm(4);
    }
} // TPMS_AC_OUTPUT

/**
* This list is only used in TPM2_AC_GetCapability().
*/
export class TPML_AC_CAPABILITIES extends TpmStructure
{
    constructor(
        /**
        * a list of AC values
        */
        public acCapabilities: TPMS_AC_OUTPUT[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_AC_OUTPUT>(this.acCapabilities, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.acCapabilities = buf.arrayFromTpm(TPMS_AC_OUTPUT, 4);
    }
} // TPML_AC_CAPABILITIES

/**
* TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
*/
export class TPM2_Startup_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_SU_CLEAR or TPM_SU_STATE
        */
        public startupType: TPM_SU = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.startupType, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.startupType = buf.fromTpm(2);
    }
} // TPM2_Startup_REQUEST

/**
* TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE.
*/
export class StartupResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // StartupResponse

/**
* This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
*/
export class TPM2_Shutdown_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_SU_CLEAR or TPM_SU_STATE
        */
        public shutdownType: TPM_SU = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.shutdownType, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.shutdownType = buf.fromTpm(2);
    }
} // TPM2_Shutdown_REQUEST

/**
* This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed.
*/
export class ShutdownResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ShutdownResponse

/**
* This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
*/
export class TPM2_SelfTest_REQUEST extends TpmStructure
{
    constructor(
        /**
        * YES if full test to be performed NO if only test of untested functions required
        */
        public fullTest: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.fullTest, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.fullTest = buf.fromTpm(1);
    }
} // TPM2_SelfTest_REQUEST

/**
* This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested.
*/
export class SelfTestResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // SelfTestResponse

/**
* This command causes the TPM to perform a test of the selected algorithms.
*/
export class TPM2_IncrementalSelfTest_REQUEST extends TpmStructure
{
    constructor(
        /**
        * list of algorithms that should be tested
        */
        public toTest: TPM_ALG_ID[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_ALG_ID>(this.toTest, 2, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.toTest = buf.valArrFromTpm(2, 4);
    }
} // TPM2_IncrementalSelfTest_REQUEST

/**
* This command causes the TPM to perform a test of the selected algorithms.
*/
export class IncrementalSelfTestResponse extends TpmStructure
{
    constructor(
        /**
        * list of algorithms that need testing
        */
        public toDoList: TPM_ALG_ID[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_ALG_ID>(this.toDoList, 2, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.toDoList = buf.valArrFromTpm(2, 4);
    }
} // IncrementalSelfTestResponse

/**
* This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
*/
export class TPM2_GetTestResult_REQUEST extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // TPM2_GetTestResult_REQUEST

/**
* This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status.
*/
export class GetTestResultResponse extends TpmStructure
{
    constructor(
        /**
        * test result data contains manufacturer-specific information
        */
        public outData: Buffer = null,
        /**
        * -
        */
        public testResult: TPM_RC = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outData);
        buf.toTpm(this.testResult, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outData = buf.fromTpm2B(2);
        this.testResult = buf.fromTpm(4);
    }
} // GetTestResultResponse

/**
* This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
*/
export class TPM2_StartAuthSession_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of a loaded decrypt key used to encrypt salt may be TPM_RH_NULL Auth Index: None
        */
        public tpmKey: TPM_HANDLE = null,
        /**
        * entity providing the authValue may be TPM_RH_NULL Auth Index: None
        */
        public bind: TPM_HANDLE = null,
        /**
        * initial nonceCaller, sets nonceTPM size for the session shall be at least 16 octets
        */
        public nonceCaller: Buffer = null,
        /**
        * value encrypted according to the type of tpmKey If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
        */
        public encryptedSalt: Buffer = null,
        /**
        * indicates the type of the session; simple HMAC or policy (including a trial policy)
        */
        public sessionType: TPM_SE = 0,
        /**
        * the algorithm and key size for parameter encryption may select TPM_ALG_NULL
        */
        public symmetric: TPMT_SYM_DEF = null,
        /**
        * hash algorithm to use for the session Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
        */
        public authHash: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nonceCaller);
        buf.toTpm2B(this.encryptedSalt);
        buf.toTpm(this.sessionType, 1);
        this.symmetric.toTpm(buf);
        buf.toTpm(this.authHash, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.tpmKey = buf.createFromTpm(TPM_HANDLE);
        this.bind = buf.createFromTpm(TPM_HANDLE);
        this.nonceCaller = buf.fromTpm2B(2);
        this.encryptedSalt = buf.fromTpm2B(2);
        this.sessionType = buf.fromTpm(1);
        this.symmetric = buf.createFromTpm(TPMT_SYM_DEF);
        this.authHash = buf.fromTpm(2);
    }
} // TPM2_StartAuthSession_REQUEST

/**
* This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters.
*/
export class StartAuthSessionResponse extends TpmStructure
{
    constructor(
        /**
        * handle for the newly created session
        */
        public handle: TPM_HANDLE = null,
        /**
        * the initial nonce from the TPM, used in the computation of the sessionKey
        */
        public nonceTPM: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        buf.toTpm2B(this.nonceTPM);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.nonceTPM = buf.fromTpm2B(2);
    }
} // StartAuthSessionResponse

/**
* This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
*/
export class TPM2_PolicyRestart_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the handle for the policy session
        */
        public sessionHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyRestart_REQUEST

/**
* This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed.
*/
export class PolicyRestartResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyRestartResponse

/**
* This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
*/
export class TPM2_Create_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of parent for new object Auth Index: 1 Auth Role: USER
        */
        public parentHandle: TPM_HANDLE = null,
        /**
        * the sensitive data
        */
        public inSensitive: TPMS_SENSITIVE_CREATE = null,
        /**
        * the public template
        */
        public inPublic: TPMT_PUBLIC = null,
        /**
        * data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
        */
        public outsideInfo: Buffer = null,
        /**
        * PCR that will be used in creation data
        */
        public creationPCR: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inSensitive, 2);
        buf.sizedToTpm(this.inPublic, 2);
        buf.toTpm2B(this.outsideInfo);
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.creationPCR, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.parentHandle = buf.createFromTpm(TPM_HANDLE);
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2);
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.outsideInfo = buf.fromTpm2B(2);
        this.creationPCR = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_Create_REQUEST

/**
* This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field.
*/
export class CreateResponse extends TpmStructure
{
    constructor(
        /**
        * the private portion of the object
        */
        public outPrivate: TPM2B_PRIVATE = null,
        /**
        * the public portion of the created object
        */
        public outPublic: TPMT_PUBLIC = null,
        /**
        * contains a TPMS_CREATION_DATA
        */
        public creationData: TPMS_CREATION_DATA = null,
        /**
        * digest of creationData using nameAlg of outPublic
        */
        public creationHash: Buffer = null,
        /**
        * ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
        */
        public creationTicket: TPMT_TK_CREATION = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.outPrivate.toTpm(buf);
        buf.sizedToTpm(this.outPublic, 2);
        buf.sizedToTpm(this.creationData, 2);
        buf.toTpm2B(this.creationHash);
        this.creationTicket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE);
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2);
        this.creationHash = buf.fromTpm2B(2);
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION);
    }
} // CreateResponse

/**
* This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
*/
export class TPM2_Load_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM handle of parent key; shall not be a reserved handle Auth Index: 1 Auth Role: USER
        */
        public parentHandle: TPM_HANDLE = null,
        /**
        * the private portion of the object
        */
        public inPrivate: TPM2B_PRIVATE = null,
        /**
        * the public portion of the object
        */
        public inPublic: TPMT_PUBLIC = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.inPrivate.toTpm(buf);
        buf.sizedToTpm(this.inPublic, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.parentHandle = buf.createFromTpm(TPM_HANDLE);
        this.inPrivate = buf.createFromTpm(TPM2B_PRIVATE);
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
    }
} // TPM2_Load_REQUEST

/**
* This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used.
*/
export class LoadResponse extends TpmStructure
{
    constructor(
        /**
        * handle of type TPM_HT_TRANSIENT for the loaded object
        */
        public handle: TPM_HANDLE = null,
        /**
        * Name of the loaded object
        */
        public name: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        buf.toTpm2B(this.name);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.name = buf.fromTpm2B(2);
    }
} // LoadResponse

/**
* This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
*/
export class TPM2_LoadExternal_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the sensitive portion of the object (optional)
        */
        public inPrivate: TPMT_SENSITIVE = null,
        /**
        * the public portion of the object
        */
        public inPublic: TPMT_PUBLIC = null,
        /**
        * hierarchy with which the object area is associated
        */
        public hierarchy: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inPrivate, 2);
        buf.sizedToTpm(this.inPublic, 2);
        this.hierarchy.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.inPrivate = buf.sizedFromTpm(TPMT_SENSITIVE, 2);
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_LoadExternal_REQUEST

/**
* This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area.
*/
export class LoadExternalResponse extends TpmStructure
{
    constructor(
        /**
        * handle of type TPM_HT_TRANSIENT for the loaded object
        */
        public handle: TPM_HANDLE = null,
        /**
        * name of the loaded object
        */
        public name: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        buf.toTpm2B(this.name);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.name = buf.fromTpm2B(2);
    }
} // LoadExternalResponse

/**
* This command allows access to the public area of a loaded object.
*/
export class TPM2_ReadPublic_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM handle of an object Auth Index: None
        */
        public objectHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_ReadPublic_REQUEST

/**
* This command allows access to the public area of a loaded object.
*/
export class ReadPublicResponse extends TpmStructure
{
    constructor(
        /**
        * structure containing the public area of an object
        */
        public outPublic: TPMT_PUBLIC = null,
        /**
        * name of the object
        */
        public name: Buffer = null,
        /**
        * the Qualified Name of the object
        */
        public qualifiedName: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.outPublic, 2);
        buf.toTpm2B(this.name);
        buf.toTpm2B(this.qualifiedName);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.name = buf.fromTpm2B(2);
        this.qualifiedName = buf.fromTpm2B(2);
    }
} // ReadPublicResponse

/**
* This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
*/
export class TPM2_ActivateCredential_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the object associated with certificate in credentialBlob Auth Index: 1 Auth Role: ADMIN
        */
        public activateHandle: TPM_HANDLE = null,
        /**
        * loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob Auth Index: 2 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * the credential
        */
        public credentialBlob: TPMS_ID_OBJECT = null,
        /**
        * keyHandle algorithm-dependent encrypted seed that protects credentialBlob
        */
        public secret: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.credentialBlob, 2);
        buf.toTpm2B(this.secret);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.activateHandle = buf.createFromTpm(TPM_HANDLE);
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.credentialBlob = buf.sizedFromTpm(TPMS_ID_OBJECT, 2);
        this.secret = buf.fromTpm2B(2);
    }
} // TPM2_ActivateCredential_REQUEST

/**
* This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object.
*/
export class ActivateCredentialResponse extends TpmStructure
{
    constructor(
        /**
        * the decrypted certificate information the data should be no larger than the size of the digest of the nameAlg associated with keyHandle
        */
        public certInfo: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.certInfo);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.certInfo = buf.fromTpm2B(2);
    }
} // ActivateCredentialResponse

/**
* This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
*/
export class TPM2_MakeCredential_REQUEST extends TpmStructure
{
    constructor(
        /**
        * loaded public area, used to encrypt the sensitive area containing the credential key Auth Index: None
        */
        public handle: TPM_HANDLE = null,
        /**
        * the credential information
        */
        public credential: Buffer = null,
        /**
        * Name of the object to which the credential applies
        */
        public objectName: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.credential);
        buf.toTpm2B(this.objectName);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.credential = buf.fromTpm2B(2);
        this.objectName = buf.fromTpm2B(2);
    }
} // TPM2_MakeCredential_REQUEST

/**
* This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
*/
export class MakeCredentialResponse extends TpmStructure
{
    constructor(
        /**
        * the credential
        */
        public credentialBlob: TPMS_ID_OBJECT = null,
        /**
        * handle algorithm-dependent data that wraps the key that encrypts credentialBlob
        */
        public secret: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.credentialBlob, 2);
        buf.toTpm2B(this.secret);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.credentialBlob = buf.sizedFromTpm(TPMS_ID_OBJECT, 2);
        this.secret = buf.fromTpm2B(2);
    }
} // MakeCredentialResponse

/**
* This command returns the data in a loaded Sealed Data Object.
*/
export class TPM2_Unseal_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of a loaded data object Auth Index: 1 Auth Role: USER
        */
        public itemHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.itemHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_Unseal_REQUEST

/**
* This command returns the data in a loaded Sealed Data Object.
*/
export class UnsealResponse extends TpmStructure
{
    constructor(
        /**
        * unsealed data Size of outData is limited to be no more than 128 octets.
        */
        public outData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outData = buf.fromTpm2B(2);
    }
} // UnsealResponse

/**
* This command is used to change the authorization secret for a TPM-resident object.
*/
export class TPM2_ObjectChangeAuth_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the object Auth Index: 1 Auth Role: ADMIN
        */
        public objectHandle: TPM_HANDLE = null,
        /**
        * handle of the parent Auth Index: None
        */
        public parentHandle: TPM_HANDLE = null,
        /**
        * new authorization value
        */
        public newAuth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.newAuth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
        this.parentHandle = buf.createFromTpm(TPM_HANDLE);
        this.newAuth = buf.fromTpm2B(2);
    }
} // TPM2_ObjectChangeAuth_REQUEST

/**
* This command is used to change the authorization secret for a TPM-resident object.
*/
export class ObjectChangeAuthResponse extends TpmStructure
{
    constructor(
        /**
        * private area containing the new authorization value
        */
        public outPrivate: TPM2B_PRIVATE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.outPrivate.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE);
    }
} // ObjectChangeAuthResponse

/**
* This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
*/
export class TPM2_CreateLoaded_REQUEST extends TpmStructure
{
    constructor(
        /**
        * Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER
        */
        public parentHandle: TPM_HANDLE = null,
        /**
        * the sensitive data, see TPM 2.0 Part 1 Sensitive Values
        */
        public inSensitive: TPMS_SENSITIVE_CREATE = null,
        /**
        * the public template
        */
        public inPublic: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inSensitive, 2);
        buf.toTpm2B(this.inPublic);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.parentHandle = buf.createFromTpm(TPM_HANDLE);
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2);
        this.inPublic = buf.fromTpm2B(2);
    }
} // TPM2_CreateLoaded_REQUEST

/**
* This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
*/
export class CreateLoadedResponse extends TpmStructure
{
    constructor(
        /**
        * handle of type TPM_HT_TRANSIENT for created object
        */
        public handle: TPM_HANDLE = null,
        /**
        * the sensitive area of the object (optional)
        */
        public outPrivate: TPM2B_PRIVATE = null,
        /**
        * the public portion of the created object
        */
        public outPublic: TPMT_PUBLIC = null,
        /**
        * the name of the created object
        */
        public name: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        this.outPrivate.toTpm(buf);
        buf.sizedToTpm(this.outPublic, 2);
        buf.toTpm2B(this.name);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE);
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.name = buf.fromTpm2B(2);
    }
} // CreateLoadedResponse

/**
* This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
*/
export class TPM2_Duplicate_REQUEST extends TpmStructure
{
    constructor(
        /**
        * loaded object to duplicate Auth Index: 1 Auth Role: DUP
        */
        public objectHandle: TPM_HANDLE = null,
        /**
        * shall reference the public area of an asymmetric key Auth Index: None
        */
        public newParentHandle: TPM_HANDLE = null,
        /**
        * optional symmetric encryption key The size for this key is set to zero when the TPM is to generate the key. This parameter may be encrypted.
        */
        public encryptionKeyIn: Buffer = null,
        /**
        * definition for the symmetric algorithm to be used for the inner wrapper may be TPM_ALG_NULL if no inner wrapper is applied
        */
        public symmetricAlg: TPMT_SYM_DEF_OBJECT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.encryptionKeyIn);
        this.symmetricAlg.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
        this.newParentHandle = buf.createFromTpm(TPM_HANDLE);
        this.encryptionKeyIn = buf.fromTpm2B(2);
        this.symmetricAlg = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
    }
} // TPM2_Duplicate_REQUEST

/**
* This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
*/
export class DuplicateResponse extends TpmStructure
{
    constructor(
        /**
        * If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then this will be the Empty Buffer; otherwise, it shall contain the TPM-generated, symmetric encryption key for the inner wrapper.
        */
        public encryptionKeyOut: Buffer = null,
        /**
        * private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted
        */
        public duplicate: TPM2B_PRIVATE = null,
        /**
        * seed protected by the asymmetric algorithms of new parent (NP)
        */
        public outSymSeed: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.encryptionKeyOut);
        this.duplicate.toTpm(buf);
        buf.toTpm2B(this.outSymSeed);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.encryptionKeyOut = buf.fromTpm2B(2);
        this.duplicate = buf.createFromTpm(TPM2B_PRIVATE);
        this.outSymSeed = buf.fromTpm2B(2);
    }
} // DuplicateResponse

/**
* This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
*/
export class TPM2_Rewrap_REQUEST extends TpmStructure
{
    constructor(
        /**
        * parent of object Auth Index: 1 Auth Role: User
        */
        public oldParent: TPM_HANDLE = null,
        /**
        * new parent of the object Auth Index: None
        */
        public newParent: TPM_HANDLE = null,
        /**
        * an object encrypted using symmetric key derived from inSymSeed
        */
        public inDuplicate: TPM2B_PRIVATE = null,
        /**
        * the Name of the object being rewrapped
        */
        public name: Buffer = null,
        /**
        * the seed for the symmetric key and HMAC key needs oldParent private key to recover the seed and generate the symmetric key
        */
        public inSymSeed: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.inDuplicate.toTpm(buf);
        buf.toTpm2B(this.name);
        buf.toTpm2B(this.inSymSeed);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.oldParent = buf.createFromTpm(TPM_HANDLE);
        this.newParent = buf.createFromTpm(TPM_HANDLE);
        this.inDuplicate = buf.createFromTpm(TPM2B_PRIVATE);
        this.name = buf.fromTpm2B(2);
        this.inSymSeed = buf.fromTpm2B(2);
    }
} // TPM2_Rewrap_REQUEST

/**
* This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
*/
export class RewrapResponse extends TpmStructure
{
    constructor(
        /**
        * an object encrypted using symmetric key derived from outSymSeed
        */
        public outDuplicate: TPM2B_PRIVATE = null,
        /**
        * seed for a symmetric key protected by newParent asymmetric key
        */
        public outSymSeed: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.outDuplicate.toTpm(buf);
        buf.toTpm2B(this.outSymSeed);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outDuplicate = buf.createFromTpm(TPM2B_PRIVATE);
        this.outSymSeed = buf.fromTpm2B(2);
    }
} // RewrapResponse

/**
* This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
*/
export class TPM2_Import_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the handle of the new parent for the object Auth Index: 1 Auth Role: USER
        */
        public parentHandle: TPM_HANDLE = null,
        /**
        * the optional symmetric encryption key used as the inner wrapper for duplicate If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
        */
        public encryptionKey: Buffer = null,
        /**
        * the public area of the object to be imported This is provided so that the integrity value for duplicate and the object attributes can be checked. NOTE Even if the integrity value of the object is not checked on input, the object Name is required to create the integrity value for the imported object.
        */
        public objectPublic: TPMT_PUBLIC = null,
        /**
        * the symmetrically encrypted duplicate object that may contain an inner symmetric wrapper
        */
        public duplicate: TPM2B_PRIVATE = null,
        /**
        * the seed for the symmetric key and HMAC key inSymSeed is encrypted/encoded using the algorithms of newParent.
        */
        public inSymSeed: Buffer = null,
        /**
        * definition for the symmetric algorithm to use for the inner wrapper If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall be the Empty Buffer.
        */
        public symmetricAlg: TPMT_SYM_DEF_OBJECT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.encryptionKey);
        buf.sizedToTpm(this.objectPublic, 2);
        this.duplicate.toTpm(buf);
        buf.toTpm2B(this.inSymSeed);
        this.symmetricAlg.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.parentHandle = buf.createFromTpm(TPM_HANDLE);
        this.encryptionKey = buf.fromTpm2B(2);
        this.objectPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.duplicate = buf.createFromTpm(TPM2B_PRIVATE);
        this.inSymSeed = buf.fromTpm2B(2);
        this.symmetricAlg = buf.createFromTpm(TPMT_SYM_DEF_OBJECT);
    }
} // TPM2_Import_REQUEST

/**
* This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted.
*/
export class ImportResponse extends TpmStructure
{
    constructor(
        /**
        * the sensitive area encrypted with the symmetric key of parentHandle
        */
        public outPrivate: TPM2B_PRIVATE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.outPrivate.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outPrivate = buf.createFromTpm(TPM2B_PRIVATE);
    }
} // ImportResponse

/**
* This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
*/
export class TPM2_RSA_Encrypt_REQUEST extends TpmStructure
{
    constructor(
        /**
        * reference to public portion of RSA key to use for encryption Auth Index: None
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * message to be encrypted NOTE 1 The data type was chosen because it limits the overall size of the input to no greater than the size of the largest RSA public key. This may be larger than allowed for keyHandle.
        */
        public message: Buffer = null,
        /**
        * the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public inScheme: TPMU_ASYM_SCHEME = null,
        /**
        * optional label L to be associated with the message Size of the buffer is zero if no label is present NOTE 2 See description of label above.
        */
        public label: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.message);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        buf.toTpm2B(this.label);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.message = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.label = buf.fromTpm2B(2);
    }
} // TPM2_RSA_Encrypt_REQUEST

/**
* This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
*/
export class RSA_EncryptResponse extends TpmStructure
{
    constructor(
        /**
        * encrypted output
        */
        public outData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outData = buf.fromTpm2B(2);
    }
} // RSA_EncryptResponse

/**
* This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
*/
export class TPM2_RSA_Decrypt_REQUEST extends TpmStructure
{
    constructor(
        /**
        * RSA key to use for decryption Auth Index: 1 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * cipher text to be decrypted NOTE An encrypted RSA data block is the size of the public modulus.
        */
        public cipherText: Buffer = null,
        /**
        * the padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL (One of TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES, TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME)
        */
        public inScheme: TPMU_ASYM_SCHEME = null,
        /**
        * label whose association with the message is to be verified
        */
        public label: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.cipherText);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        buf.toTpm2B(this.label);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.cipherText = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_ASYM_SCHEME>('TPMU_ASYM_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.label = buf.fromTpm2B(2);
    }
} // TPM2_RSA_Decrypt_REQUEST

/**
* This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1).
*/
export class RSA_DecryptResponse extends TpmStructure
{
    constructor(
        /**
        * decrypted output
        */
        public message: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.message);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.message = buf.fromTpm2B(2);
    }
} // RSA_DecryptResponse

/**
* This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
*/
export class TPM2_ECDH_KeyGen_REQUEST extends TpmStructure
{
    constructor(
        /**
        * Handle of a loaded ECC key public area. Auth Index: None
        */
        public keyHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_ECDH_KeyGen_REQUEST

/**
* This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P [hde]QS).
*/
export class ECDH_KeyGenResponse extends TpmStructure
{
    constructor(
        /**
        * results of P h[de]Qs
        */
        public zPoint: TPMS_ECC_POINT = null,
        /**
        * generated ephemeral public point (Qe)
        */
        public pubPoint: TPMS_ECC_POINT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.zPoint, 2);
        buf.sizedToTpm(this.pubPoint, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.zPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.pubPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
    }
} // ECDH_KeyGenResponse

/**
* This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
*/
export class TPM2_ECDH_ZGen_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of a loaded ECC key Auth Index: 1 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * a public key
        */
        public inPoint: TPMS_ECC_POINT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inPoint, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.inPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
    }
} // TPM2_ECDH_ZGen_REQUEST

/**
* This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ) [hds]QB; where h is the cofactor of the curve).
*/
export class ECDH_ZGenResponse extends TpmStructure
{
    constructor(
        /**
        * X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB
        */
        public outPoint: TPMS_ECC_POINT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.outPoint, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outPoint = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
    }
} // ECDH_ZGenResponse

/**
* This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
*/
export class TPM2_ECC_Parameters_REQUEST extends TpmStructure
{
    constructor(
        /**
        * parameter set selector
        */
        public curveID: TPM_ECC_CURVE = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.curveID, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.curveID = buf.fromTpm(2);
    }
} // TPM2_ECC_Parameters_REQUEST

/**
* This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.
*/
export class ECC_ParametersResponse extends TpmStructure
{
    constructor(
        /**
        * ECC parameters for the selected curve
        */
        public parameters: TPMS_ALGORITHM_DETAIL_ECC = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.parameters.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.parameters = buf.createFromTpm(TPMS_ALGORITHM_DETAIL_ECC);
    }
} // ECC_ParametersResponse

/**
* This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
*/
export class TPM2_ZGen_2Phase_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of an unrestricted decryption key ECC The private key referenced by this handle is used as dS,A Auth Index: 1 Auth Role: USER
        */
        public keyA: TPM_HANDLE = null,
        /**
        * other partys static public key (Qs,B = (Xs,B, Ys,B))
        */
        public inQsB: TPMS_ECC_POINT = null,
        /**
        * other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))
        */
        public inQeB: TPMS_ECC_POINT = null,
        /**
        * the key exchange scheme
        */
        public inScheme: TPM_ALG_ID = 0,
        /**
        * value returned by TPM2_EC_Ephemeral()
        */
        public counter: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inQsB, 2);
        buf.sizedToTpm(this.inQeB, 2);
        buf.toTpm(this.inScheme, 2);
        buf.toTpm(this.counter, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyA = buf.createFromTpm(TPM_HANDLE);
        this.inQsB = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.inQeB = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.inScheme = buf.fromTpm(2);
        this.counter = buf.fromTpm(2);
    }
} // TPM2_ZGen_2Phase_REQUEST

/**
* This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key.
*/
export class ZGen_2PhaseResponse extends TpmStructure
{
    constructor(
        /**
        * X and Y coordinates of the computed value (scheme dependent)
        */
        public outZ1: TPMS_ECC_POINT = null,
        /**
        * X and Y coordinates of the second computed value (scheme dependent)
        */
        public outZ2: TPMS_ECC_POINT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.outZ1, 2);
        buf.sizedToTpm(this.outZ2, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outZ1 = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.outZ2 = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
    }
} // ZGen_2PhaseResponse

/**
* NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
*/
export class TPM2_EncryptDecrypt_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the symmetric key used for the operation Auth Index: 1 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * if YES, then the operation is decryption; if NO, the operation is encryption
        */
        public decrypt: number = 0,
        /**
        * symmetric encryption/decryption mode this field shall match the default mode of the key or be TPM_ALG_NULL.
        */
        public mode: TPM_ALG_ID = 0,
        /**
        * an initial value as required by the algorithm
        */
        public ivIn: Buffer = null,
        /**
        * the data to be encrypted/decrypted
        */
        public inData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.decrypt, 1);
        buf.toTpm(this.mode, 2);
        buf.toTpm2B(this.ivIn);
        buf.toTpm2B(this.inData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.decrypt = buf.fromTpm(1);
        this.mode = buf.fromTpm(2);
        this.ivIn = buf.fromTpm2B(2);
        this.inData = buf.fromTpm2B(2);
    }
} // TPM2_EncryptDecrypt_REQUEST

/**
* NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications.
*/
export class EncryptDecryptResponse extends TpmStructure
{
    constructor(
        /**
        * encrypted or decrypted output
        */
        public outData: Buffer = null,
        /**
        * chaining value to use for IV in next round
        */
        public ivOut: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outData);
        buf.toTpm2B(this.ivOut);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outData = buf.fromTpm2B(2);
        this.ivOut = buf.fromTpm2B(2);
    }
} // EncryptDecryptResponse

/**
* This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
*/
export class TPM2_EncryptDecrypt2_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the symmetric key used for the operation Auth Index: 1 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * the data to be encrypted/decrypted
        */
        public inData: Buffer = null,
        /**
        * if YES, then the operation is decryption; if NO, the operation is encryption
        */
        public decrypt: number = 0,
        /**
        * symmetric mode this field shall match the default mode of the key or be TPM_ALG_NULL.
        */
        public mode: TPM_ALG_ID = 0,
        /**
        * an initial value as required by the algorithm
        */
        public ivIn: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.inData);
        buf.toTpm(this.decrypt, 1);
        buf.toTpm(this.mode, 2);
        buf.toTpm2B(this.ivIn);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.inData = buf.fromTpm2B(2);
        this.decrypt = buf.fromTpm(1);
        this.mode = buf.fromTpm(2);
        this.ivIn = buf.fromTpm2B(2);
    }
} // TPM2_EncryptDecrypt2_REQUEST

/**
* This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted.
*/
export class EncryptDecrypt2Response extends TpmStructure
{
    constructor(
        /**
        * encrypted or decrypted output
        */
        public outData: Buffer = null,
        /**
        * chaining value to use for IV in next round
        */
        public ivOut: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outData);
        buf.toTpm2B(this.ivOut);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outData = buf.fromTpm2B(2);
        this.ivOut = buf.fromTpm2B(2);
    }
} // EncryptDecrypt2Response

/**
* This command performs a hash operation on a data buffer and returns the results.
*/
export class TPM2_Hash_REQUEST extends TpmStructure
{
    constructor(
        /**
        * data to be hashed
        */
        public data: Buffer = null,
        /**
        * algorithm for the hash being computed shall not be TPM_ALG_NULL
        */
        public hashAlg: TPM_ALG_ID = 0,
        /**
        * hierarchy to use for the ticket (TPM_RH_NULL allowed)
        */
        public hierarchy: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.data);
        buf.toTpm(this.hashAlg, 2);
        this.hierarchy.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.data = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_Hash_REQUEST

/**
* This command performs a hash operation on a data buffer and returns the results.
*/
export class HashResponse extends TpmStructure
{
    constructor(
        /**
        * results
        */
        public outHash: Buffer = null,
        /**
        * ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE will be a NULL ticket if the digest may not be signed with a restricted key
        */
        public validation: TPMT_TK_HASHCHECK = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outHash);
        this.validation.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outHash = buf.fromTpm2B(2);
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK);
    }
} // HashResponse

/**
* This command performs an HMAC on the supplied data using the indicated hash algorithm.
*/
export class TPM2_HMAC_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the symmetric signing key providing the HMAC key Auth Index: 1 Auth Role: USER
        */
        public handle: TPM_HANDLE = null,
        /**
        * HMAC data
        */
        public buffer: Buffer = null,
        /**
        * algorithm to use for HMAC
        */
        public hashAlg: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
        buf.toTpm(this.hashAlg, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.buffer = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
    }
} // TPM2_HMAC_REQUEST

/**
* This command performs an HMAC on the supplied data using the indicated hash algorithm.
*/
export class HMACResponse extends TpmStructure
{
    constructor(
        /**
        * the returned HMAC in a sized buffer
        */
        public outHMAC: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outHMAC);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outHMAC = buf.fromTpm2B(2);
    }
} // HMACResponse

/**
* This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
*/
export class TPM2_MAC_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the symmetric signing key providing the MAC key Auth Index: 1 Auth Role: USER
        */
        public handle: TPM_HANDLE = null,
        /**
        * MAC data
        */
        public buffer: Buffer = null,
        /**
        * algorithm to use for MAC
        */
        public inScheme: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
        buf.toTpm(this.inScheme, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.buffer = buf.fromTpm2B(2);
        this.inScheme = buf.fromTpm(2);
    }
} // TPM2_MAC_REQUEST

/**
* This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm.
*/
export class MACResponse extends TpmStructure
{
    constructor(
        /**
        * the returned MAC in a sized buffer
        */
        public outMAC: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outMAC);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outMAC = buf.fromTpm2B(2);
    }
} // MACResponse

/**
* This command returns the next bytesRequested octets from the random number generator (RNG).
*/
export class TPM2_GetRandom_REQUEST extends TpmStructure
{
    constructor(
        /**
        * number of octets to return
        */
        public bytesRequested: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.bytesRequested, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.bytesRequested = buf.fromTpm(2);
    }
} // TPM2_GetRandom_REQUEST

/**
* This command returns the next bytesRequested octets from the random number generator (RNG).
*/
export class GetRandomResponse extends TpmStructure
{
    constructor(
        /**
        * the random octets
        */
        public randomBytes: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.randomBytes);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.randomBytes = buf.fromTpm2B(2);
    }
} // GetRandomResponse

/**
* This command is used to add "additional information" to the RNG state.
*/
export class TPM2_StirRandom_REQUEST extends TpmStructure
{
    constructor(
        /**
        * additional information
        */
        public inData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.inData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.inData = buf.fromTpm2B(2);
    }
} // TPM2_StirRandom_REQUEST

/**
* This command is used to add "additional information" to the RNG state.
*/
export class StirRandomResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // StirRandomResponse

/**
* This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
*/
export class TPM2_HMAC_Start_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of an HMAC key Auth Index: 1 Auth Role: USER
        */
        public handle: TPM_HANDLE = null,
        /**
        * authorization value for subsequent use of the sequence
        */
        public auth: Buffer = null,
        /**
        * the hash algorithm to use for the HMAC
        */
        public hashAlg: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.auth);
        buf.toTpm(this.hashAlg, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.auth = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
    }
} // TPM2_HMAC_Start_REQUEST

/**
* This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
*/
export class HMAC_StartResponse extends TpmStructure
{
    constructor(
        /**
        * a handle to reference the sequence
        */
        public handle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
    }
} // HMAC_StartResponse

/**
* This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
*/
export class TPM2_MAC_Start_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of a MAC key Auth Index: 1 Auth Role: USER
        */
        public handle: TPM_HANDLE = null,
        /**
        * authorization value for subsequent use of the sequence
        */
        public auth: Buffer = null,
        /**
        * the algorithm to use for the MAC
        */
        public inScheme: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.auth);
        buf.toTpm(this.inScheme, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.auth = buf.fromTpm2B(2);
        this.inScheme = buf.fromTpm(2);
    }
} // TPM2_MAC_Start_REQUEST

/**
* This command starts a MAC sequence. The TPM will create and initialize an MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth.
*/
export class MAC_StartResponse extends TpmStructure
{
    constructor(
        /**
        * a handle to reference the sequence
        */
        public handle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
    }
} // MAC_StartResponse

/**
* This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
*/
export class TPM2_HashSequenceStart_REQUEST extends TpmStructure
{
    constructor(
        /**
        * authorization value for subsequent use of the sequence
        */
        public auth: Buffer = null,
        /**
        * the hash algorithm to use for the hash sequence An Event Sequence starts if this is TPM_ALG_NULL.
        */
        public hashAlg: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.auth);
        buf.toTpm(this.hashAlg, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
    }
} // TPM2_HashSequenceStart_REQUEST

/**
* This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH.
*/
export class HashSequenceStartResponse extends TpmStructure
{
    constructor(
        /**
        * a handle to reference the sequence
        */
        public handle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
    }
} // HashSequenceStartResponse

/**
* This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
*/
export class TPM2_SequenceUpdate_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the sequence object Auth Index: 1 Auth Role: USER
        */
        public sequenceHandle: TPM_HANDLE = null,
        /**
        * data to be added to hash
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE);
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2_SequenceUpdate_REQUEST

/**
* This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM.
*/
export class SequenceUpdateResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // SequenceUpdateResponse

/**
* This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
*/
export class TPM2_SequenceComplete_REQUEST extends TpmStructure
{
    constructor(
        /**
        * authorization for the sequence Auth Index: 1 Auth Role: USER
        */
        public sequenceHandle: TPM_HANDLE = null,
        /**
        * data to be added to the hash/HMAC
        */
        public buffer: Buffer = null,
        /**
        * hierarchy of the ticket for a hash
        */
        public hierarchy: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
        this.hierarchy.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE);
        this.buffer = buf.fromTpm2B(2);
        this.hierarchy = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_SequenceComplete_REQUEST

/**
* This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result.
*/
export class SequenceCompleteResponse extends TpmStructure
{
    constructor(
        /**
        * the returned HMAC or digest in a sized buffer
        */
        public result: Buffer = null,
        /**
        * ticket indicating that the sequence of octets used to compute outDigest did not start with TPM_GENERATED_VALUE This is a NULL Ticket when the sequence is HMAC.
        */
        public validation: TPMT_TK_HASHCHECK = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.result);
        this.validation.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.result = buf.fromTpm2B(2);
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK);
    }
} // SequenceCompleteResponse

/**
* This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
*/
export class TPM2_EventSequenceComplete_REQUEST extends TpmStructure
{
    constructor(
        /**
        * PCR to be extended with the Event data Auth Index: 1 Auth Role: USER
        */
        public pcrHandle: TPM_HANDLE = null,
        /**
        * authorization for the sequence Auth Index: 2 Auth Role: USER
        */
        public sequenceHandle: TPM_HANDLE = null,
        /**
        * data to be added to the Event
        */
        public buffer: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.buffer);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE);
        this.sequenceHandle = buf.createFromTpm(TPM_HANDLE);
        this.buffer = buf.fromTpm2B(2);
    }
} // TPM2_EventSequenceComplete_REQUEST

/**
* This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend() with the pcrHandle in each bank extended with the associated digest value.
*/
export class EventSequenceCompleteResponse extends TpmStructure
{
    constructor(
        /**
        * list of digests computed for the PCR
        */
        public results: TPMT_HA[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMT_HA>(this.results, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.results = buf.arrayFromTpm(TPMT_HA, 4);
    }
} // EventSequenceCompleteResponse

/**
* The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
*/
export class TPM2_Certify_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the object to be certified Auth Index: 1 Auth Role: ADMIN
        */
        public objectHandle: TPM_HANDLE = null,
        /**
        * handle of the key used to sign the attestation structure Auth Index: 2 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * user provided qualifying data
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
    }
} // TPM2_Certify_REQUEST

/**
* The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct.
*/
export class CertifyResponse extends TpmStructure
{
    constructor(
        /**
        * the structure that was signed
        */
        public certifyInfo: TPMS_ATTEST = null,
        /**
        * the asymmetric signature over certifyInfo using the key referenced by signHandle (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.certifyInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // CertifyResponse

/**
* This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
*/
export class TPM2_CertifyCreation_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the key that will sign the attestation block Auth Index: 1 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * the object associated with the creation data Auth Index: None
        */
        public objectHandle: TPM_HANDLE = null,
        /**
        * user-provided qualifying data
        */
        public qualifyingData: Buffer = null,
        /**
        * hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()
        */
        public creationHash: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null,
        /**
        * ticket produced by TPM2_Create() or TPM2_CreatePrimary()
        */
        public creationTicket: TPMT_TK_CREATION = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm2B(this.creationHash);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        this.creationTicket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        this.creationHash = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION);
    }
} // TPM2_CertifyCreation_REQUEST

/**
* This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash).
*/
export class CertifyCreationResponse extends TpmStructure
{
    constructor(
        /**
        * the structure that was signed
        */
        public certifyInfo: TPMS_ATTEST = null,
        /**
        * the signature over certifyInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.certifyInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // CertifyCreationResponse

/**
* This command is used to quote PCR values.
*/
export class TPM2_Quote_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of key that will perform signature Auth Index: 1 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * data supplied by the caller
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null,
        /**
        * PCR set to quote
        */
        public PCRselect: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.PCRselect, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.PCRselect = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_Quote_REQUEST

/**
* This command is used to quote PCR values.
*/
export class QuoteResponse extends TpmStructure
{
    constructor(
        /**
        * the quoted information
        */
        public quoted: TPMS_ATTEST = null,
        /**
        * the signature over quoted (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.quoted, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.quoted = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // QuoteResponse

/**
* This command returns a digital signature of the audit session digest.
*/
export class TPM2_GetSessionAuditDigest_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        */
        public privacyAdminHandle: TPM_HANDLE = null,
        /**
        * handle of the signing key Auth Index: 2 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * handle of the audit session Auth Index: None
        */
        public sessionHandle: TPM_HANDLE = null,
        /**
        * user-provided qualifying data may be zero-length
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.privacyAdminHandle = buf.createFromTpm(TPM_HANDLE);
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.sessionHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
    }
} // TPM2_GetSessionAuditDigest_REQUEST

/**
* This command returns a digital signature of the audit session digest.
*/
export class GetSessionAuditDigestResponse extends TpmStructure
{
    constructor(
        /**
        * the audit information that was signed
        */
        public auditInfo: TPMS_ATTEST = null,
        /**
        * the signature over auditInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.auditInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auditInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // GetSessionAuditDigestResponse

/**
* This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
*/
export class TPM2_GetCommandAuditDigest_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        */
        public privacyHandle: TPM_HANDLE = null,
        /**
        * the handle of the signing key Auth Index: 2 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * other data to associate with this audit digest
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.privacyHandle = buf.createFromTpm(TPM_HANDLE);
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
    }
} // TPM2_GetCommandAuditDigest_REQUEST

/**
* This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle.
*/
export class GetCommandAuditDigestResponse extends TpmStructure
{
    constructor(
        /**
        * the auditInfo that was signed
        */
        public auditInfo: TPMS_ATTEST = null,
        /**
        * the signature over auditInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.auditInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auditInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // GetCommandAuditDigestResponse

/**
* This command returns the current values of Time and Clock.
*/
export class TPM2_GetTime_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the privacy administrator (TPM_RH_ENDORSEMENT) Auth Index: 1 Auth Role: USER
        */
        public privacyAdminHandle: TPM_HANDLE = null,
        /**
        * the keyHandle identifier of a loaded key that can perform digital signatures Auth Index: 2 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * data to tick stamp
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.privacyAdminHandle = buf.createFromTpm(TPM_HANDLE);
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
    }
} // TPM2_GetTime_REQUEST

/**
* This command returns the current values of Time and Clock.
*/
export class GetTimeResponse extends TpmStructure
{
    constructor(
        /**
        * standard TPM-generated attestation block
        */
        public timeInfo: TPMS_ATTEST = null,
        /**
        * the signature over timeInfo (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.timeInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.timeInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // GetTimeResponse

/**
* TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
*/
export class TPM2_Commit_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the key that will be used in the signing operation Auth Index: 1 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * a point (M) on the curve used by signHandle
        */
        public P1: TPMS_ECC_POINT = null,
        /**
        * octet array used to derive x-coordinate of a base point
        */
        public s2: Buffer = null,
        /**
        * y coordinate of the point associated with s2
        */
        public y2: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.P1, 2);
        buf.toTpm2B(this.s2);
        buf.toTpm2B(this.y2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.P1 = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.s2 = buf.fromTpm2B(2);
        this.y2 = buf.fromTpm2B(2);
    }
} // TPM2_Commit_REQUEST

/**
* TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME).
*/
export class CommitResponse extends TpmStructure
{
    constructor(
        /**
        * ECC point K [ds](x2, y2)
        */
        public K: TPMS_ECC_POINT = null,
        /**
        * ECC point L [r](x2, y2)
        */
        public L: TPMS_ECC_POINT = null,
        /**
        * ECC point E [r]P1
        */
        public E: TPMS_ECC_POINT = null,
        /**
        * least-significant 16 bits of commitCount
        */
        public counter: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.K, 2);
        buf.sizedToTpm(this.L, 2);
        buf.sizedToTpm(this.E, 2);
        buf.toTpm(this.counter, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.K = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.L = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.E = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.counter = buf.fromTpm(2);
    }
} // CommitResponse

/**
* TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
*/
export class TPM2_EC_Ephemeral_REQUEST extends TpmStructure
{
    constructor(
        /**
        * The curve for the computed ephemeral point
        */
        public curveID: TPM_ECC_CURVE = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.curveID, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.curveID = buf.fromTpm(2);
    }
} // TPM2_EC_Ephemeral_REQUEST

/**
* TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.
*/
export class EC_EphemeralResponse extends TpmStructure
{
    constructor(
        /**
        * ephemeral public key Q [r]G
        */
        public Q: TPMS_ECC_POINT = null,
        /**
        * least-significant 16 bits of commitCount
        */
        public counter: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.Q, 2);
        buf.toTpm(this.counter, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.Q = buf.sizedFromTpm(TPMS_ECC_POINT, 2);
        this.counter = buf.fromTpm(2);
    }
} // EC_EphemeralResponse

/**
* This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
*/
export class TPM2_VerifySignature_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of public key that will be used in the validation Auth Index: None
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * digest of the signed message
        */
        public digest: Buffer = null,
        /**
        * signature to be tested (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.digest);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // TPM2_VerifySignature_REQUEST

/**
* This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM.
*/
export class VerifySignatureResponse extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public validation: TPMT_TK_VERIFIED = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.validation.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.validation = buf.createFromTpm(TPMT_TK_VERIFIED);
    }
} // VerifySignatureResponse

/**
* This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
*/
export class TPM2_Sign_REQUEST extends TpmStructure
{
    constructor(
        /**
        * Handle of key that will perform signing Auth Index: 1 Auth Role: USER
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * digest to be signed
        */
        public digest: Buffer = null,
        /**
        * signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null,
        /**
        * proof that digest was created by the TPM If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag = TPM_ST_CHECKHASH.
        */
        public validation: TPMT_TK_HASHCHECK = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.digest);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        this.validation.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.digest = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.validation = buf.createFromTpm(TPMT_TK_HASHCHECK);
    }
} // TPM2_Sign_REQUEST

/**
* This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key.
*/
export class SignResponse extends TpmStructure
{
    constructor(
        /**
        * the signature (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // SignResponse

/**
* This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
*/
export class TPM2_SetCommandCodeAuditStatus_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public auth: TPM_HANDLE = null,
        /**
        * hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed
        */
        public auditAlg: TPM_ALG_ID = 0,
        /**
        * list of commands that will be added to those that will be audited
        */
        public setList: TPM_CC[] = null,
        /**
        * list of commands that will no longer be audited
        */
        public clearList: TPM_CC[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.auditAlg, 2);
        buf.valArrToTpm<TPM_CC>(this.setList, 4, 4);
        buf.valArrToTpm<TPM_CC>(this.clearList, 4, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.auditAlg = buf.fromTpm(2);
        this.setList = buf.valArrFromTpm(4, 4);
        this.clearList = buf.valArrFromTpm(4, 4);
    }
} // TPM2_SetCommandCodeAuditStatus_REQUEST

/**
* This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time.
*/
export class SetCommandCodeAuditStatusResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // SetCommandCodeAuditStatusResponse

/**
* This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
*/
export class TPM2_PCR_Extend_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the PCR Auth Handle: 1 Auth Role: USER
        */
        public pcrHandle: TPM_HANDLE = null,
        /**
        * list of tagged digest values to be extended
        */
        public digests: TPMT_HA[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMT_HA>(this.digests, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE);
        this.digests = buf.arrayFromTpm(TPMT_HA, 4);
    }
} // TPM2_PCR_Extend_REQUEST

/**
* This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg).
*/
export class PCR_ExtendResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PCR_ExtendResponse

/**
* This command is used to cause an update to the indicated PCR.
*/
export class TPM2_PCR_Event_REQUEST extends TpmStructure
{
    constructor(
        /**
        * Handle of the PCR Auth Handle: 1 Auth Role: USER
        */
        public pcrHandle: TPM_HANDLE = null,
        /**
        * Event data in sized buffer
        */
        public eventData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.eventData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE);
        this.eventData = buf.fromTpm2B(2);
    }
} // TPM2_PCR_Event_REQUEST

/**
* This command is used to cause an update to the indicated PCR.
*/
export class PCR_EventResponse extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public digests: TPMT_HA[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMT_HA>(this.digests, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.digests = buf.arrayFromTpm(TPMT_HA, 4);
    }
} // PCR_EventResponse

/**
* This command returns the values of all PCR specified in pcrSelectionIn.
*/
export class TPM2_PCR_Read_REQUEST extends TpmStructure
{
    constructor(
        /**
        * The selection of PCR to read
        */
        public pcrSelectionIn: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrSelectionIn, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrSelectionIn = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_PCR_Read_REQUEST

/**
* This command returns the values of all PCR specified in pcrSelectionIn.
*/
export class PCR_ReadResponse extends TpmStructure
{
    constructor(
        /**
        * the current value of the PCR update counter
        */
        public pcrUpdateCounter: number = 0,
        /**
        * the PCR in the returned list
        */
        public pcrSelectionOut: TPMS_PCR_SELECTION[] = null,
        /**
        * the contents of the PCR indicated in pcrSelectOut-) pcrSelection[] as tagged digests
        */
        public pcrValues: TPM2B_DIGEST[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.pcrUpdateCounter, 4);
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrSelectionOut, 4);
        buf.arrayToTpm<TPM2B_DIGEST>(this.pcrValues, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrUpdateCounter = buf.fromTpm(4);
        this.pcrSelectionOut = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
        this.pcrValues = buf.arrayFromTpm(TPM2B_DIGEST, 4);
    }
} // PCR_ReadResponse

/**
* This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
*/
export class TPM2_PCR_Allocate_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the requested allocation
        */
        public pcrAllocation: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrAllocation, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.pcrAllocation = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_PCR_Allocate_REQUEST

/**
* This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization.
*/
export class PCR_AllocateResponse extends TpmStructure
{
    constructor(
        /**
        * YES if the allocation succeeded
        */
        public allocationSuccess: number = 0,
        /**
        * maximum number of PCR that may be in a bank
        */
        public maxPCR: number = 0,
        /**
        * number of octets required to satisfy the request
        */
        public sizeNeeded: number = 0,
        /**
        * Number of octets available. Computed before the allocation.
        */
        public sizeAvailable: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.allocationSuccess, 1);
        buf.toTpm(this.maxPCR, 4);
        buf.toTpm(this.sizeNeeded, 4);
        buf.toTpm(this.sizeAvailable, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.allocationSuccess = buf.fromTpm(1);
        this.maxPCR = buf.fromTpm(4);
        this.sizeNeeded = buf.fromTpm(4);
        this.sizeAvailable = buf.fromTpm(4);
    }
} // PCR_AllocateResponse

/**
* This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
*/
export class TPM2_PCR_SetAuthPolicy_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the desired authPolicy
        */
        public authPolicy: Buffer = null,
        /**
        * the hash algorithm of the policy
        */
        public hashAlg: TPM_ALG_ID = 0,
        /**
        * the PCR for which the policy is to be set
        */
        public pcrNum: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.authPolicy);
        buf.toTpm(this.hashAlg, 2);
        this.pcrNum.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.authPolicy = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
        this.pcrNum = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PCR_SetAuthPolicy_REQUEST

/**
* This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset.
*/
export class PCR_SetAuthPolicyResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PCR_SetAuthPolicyResponse

/**
* This command changes the authValue of a PCR or group of PCR.
*/
export class TPM2_PCR_SetAuthValue_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for a PCR that may have an authorization value set Auth Index: 1 Auth Role: USER
        */
        public pcrHandle: TPM_HANDLE = null,
        /**
        * the desired authorization value
        */
        public auth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.auth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE);
        this.auth = buf.fromTpm2B(2);
    }
} // TPM2_PCR_SetAuthValue_REQUEST

/**
* This command changes the authValue of a PCR or group of PCR.
*/
export class PCR_SetAuthValueResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PCR_SetAuthValueResponse

/**
* If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
*/
export class TPM2_PCR_Reset_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the PCR to reset Auth Index: 1 Auth Role: USER
        */
        public pcrHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.pcrHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PCR_Reset_REQUEST

/**
* If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation.
*/
export class PCR_ResetResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PCR_ResetResponse

/**
* This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
*/
export class TPM2_PolicySigned_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for a key that will validate the signature Auth Index: None
        */
        public authObject: TPM_HANDLE = null,
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the policy nonce for the session This can be the Empty Buffer.
        */
        public nonceTPM: Buffer = null,
        /**
        * digest of the command parameters to which this authorization is limited This is not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
        */
        public cpHashA: Buffer = null,
        /**
        * a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.
        */
        public policyRef: Buffer = null,
        /**
        * time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
        */
        public expiration: number = 0,
        /**
        * signed authorization (not optional) (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public auth: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nonceTPM);
        buf.toTpm2B(this.cpHashA);
        buf.toTpm2B(this.policyRef);
        buf.toTpm(this.expiration, 4);
        buf.toTpm(this.auth.GetUnionSelector(), 2);
        this.auth.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authObject = buf.createFromTpm(TPM_HANDLE);
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.nonceTPM = buf.fromTpm2B(2);
        this.cpHashA = buf.fromTpm2B(2);
        this.policyRef = buf.fromTpm2B(2);
        this.expiration = buf.fromTpm(4);
        let authSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.auth = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', authSigAlg);
        this.auth.fromTpm(buf);
    }
} // TPM2_PolicySigned_REQUEST

/**
* This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest
*/
export class PolicySignedResponse extends TpmStructure
{
    constructor(
        /**
        * implementation-specific time value, used to indicate to the TPM when the ticket expires NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
        */
        public timeout: Buffer = null,
        /**
        * produced if the command succeeds and expiration in the command was non-zero; this ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
        */
        public policyTicket: TPMT_TK_AUTH = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.timeout);
        this.policyTicket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.timeout = buf.fromTpm2B(2);
        this.policyTicket = buf.createFromTpm(TPMT_TK_AUTH);
    }
} // PolicySignedResponse

/**
* This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
*/
export class TPM2_PolicySecret_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for an entity providing the authorization Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the policy nonce for the session This can be the Empty Buffer.
        */
        public nonceTPM: Buffer = null,
        /**
        * digest of the command parameters to which this authorization is limited This not the cpHash for this command but the cpHash for the command to which this policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
        */
        public cpHashA: Buffer = null,
        /**
        * a reference to a policy relating to the authorization may be the Empty Buffer Size is limited to be no larger than the nonce size supported on the TPM.
        */
        public policyRef: Buffer = null,
        /**
        * time when authorization will expire, measured in seconds from the time that nonceTPM was generated If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
        */
        public expiration: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nonceTPM);
        buf.toTpm2B(this.cpHashA);
        buf.toTpm2B(this.policyRef);
        buf.toTpm(this.expiration, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.nonceTPM = buf.fromTpm2B(2);
        this.cpHashA = buf.fromTpm2B(2);
        this.policyRef = buf.fromTpm2B(2);
        this.expiration = buf.fromTpm(4);
    }
} // TPM2_PolicySecret_REQUEST

/**
* This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
*/
export class PolicySecretResponse extends TpmStructure
{
    constructor(
        /**
        * implementation-specific time value used to indicate to the TPM when the ticket expires
        */
        public timeout: Buffer = null,
        /**
        * produced if the command succeeds and expiration in the command was non-zero ( See 23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
        */
        public policyTicket: TPMT_TK_AUTH = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.timeout);
        this.policyTicket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.timeout = buf.fromTpm2B(2);
        this.policyTicket = buf.createFromTpm(TPMT_TK_AUTH);
    }
} // PolicySecretResponse

/**
* This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
*/
export class TPM2_PolicyTicket_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * time when authorization will expire The contents are TPM specific. This shall be the value returned when ticket was produced.
        */
        public timeout: Buffer = null,
        /**
        * digest of the command parameters to which this authorization is limited If it is not limited, the parameter will be the Empty Buffer.
        */
        public cpHashA: Buffer = null,
        /**
        * reference to a qualifier for the policy may be the Empty Buffer
        */
        public policyRef: Buffer = null,
        /**
        * name of the object that provided the authorization
        */
        public authName: Buffer = null,
        /**
        * an authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or TPM2_PolicySecret()
        */
        public ticket: TPMT_TK_AUTH = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.timeout);
        buf.toTpm2B(this.cpHashA);
        buf.toTpm2B(this.policyRef);
        buf.toTpm2B(this.authName);
        this.ticket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.timeout = buf.fromTpm2B(2);
        this.cpHashA = buf.fromTpm2B(2);
        this.policyRef = buf.fromTpm2B(2);
        this.authName = buf.fromTpm2B(2);
        this.ticket = buf.createFromTpm(TPMT_TK_AUTH);
    }
} // TPM2_PolicyTicket_REQUEST

/**
* This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it.
*/
export class PolicyTicketResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyTicketResponse

/**
* This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
*/
export class TPM2_PolicyOR_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the list of hashes to check for a match
        */
        public pHashList: TPM2B_DIGEST[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.arrayToTpm<TPM2B_DIGEST>(this.pHashList, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.pHashList = buf.arrayFromTpm(TPM2B_DIGEST, 4);
    }
} // TPM2_PolicyOR_REQUEST

/**
* This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied.
*/
export class PolicyORResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyORResponse

/**
* This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
*/
export class TPM2_PolicyPCR_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * expected digest value of the selected PCR using the hash algorithm of the session; may be zero length
        */
        public pcrDigest: Buffer = null,
        /**
        * the PCR to include in the check digest
        */
        public pcrs: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.pcrDigest);
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.pcrs, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.pcrDigest = buf.fromTpm2B(2);
        this.pcrs = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_PolicyPCR_REQUEST

/**
* This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state.
*/
export class PolicyPCRResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyPCRResponse

/**
* This command indicates that the authorization will be limited to a specific locality.
*/
export class TPM2_PolicyLocality_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the allowed localities for the policy
        */
        public locality: TPMA_LOCALITY = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.locality, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.locality = buf.fromTpm(1);
    }
} // TPM2_PolicyLocality_REQUEST

/**
* This command indicates that the authorization will be limited to a specific locality.
*/
export class PolicyLocalityResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyLocalityResponse

/**
* This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
*/
export class TPM2_PolicyNV_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index of the area to read Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the second operand
        */
        public operandB: Buffer = null,
        /**
        * the octet offset in the NV Index for the start of operand A
        */
        public offset: number = 0,
        /**
        * the comparison to make
        */
        public operation: TPM_EO = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.operandB);
        buf.toTpm(this.offset, 2);
        buf.toTpm(this.operation, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.operandB = buf.fromTpm2B(2);
        this.offset = buf.fromTpm(2);
        this.operation = buf.fromTpm(2);
    }
} // TPM2_PolicyNV_REQUEST

/**
* This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization.
*/
export class PolicyNVResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyNVResponse

/**
* This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
*/
export class TPM2_PolicyCounterTimer_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the second operand
        */
        public operandB: Buffer = null,
        /**
        * the octet offset in the TPMS_TIME_INFO structure for the start of operand A
        */
        public offset: number = 0,
        /**
        * the comparison to make
        */
        public operation: TPM_EO = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.operandB);
        buf.toTpm(this.offset, 2);
        buf.toTpm(this.operation, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.operandB = buf.fromTpm2B(2);
        this.offset = buf.fromTpm(2);
        this.operation = buf.fromTpm(2);
    }
} // TPM2_PolicyCounterTimer_REQUEST

/**
* This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure.
*/
export class PolicyCounterTimerResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyCounterTimerResponse

/**
* This command indicates that the authorization will be limited to a specific command code.
*/
export class TPM2_PolicyCommandCode_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the allowed commandCode
        */
        public code: TPM_CC = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.code, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.code = buf.fromTpm(4);
    }
} // TPM2_PolicyCommandCode_REQUEST

/**
* This command indicates that the authorization will be limited to a specific command code.
*/
export class PolicyCommandCodeResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyCommandCodeResponse

/**
* This command indicates that physical presence will need to be asserted at the time the authorization is performed.
*/
export class TPM2_PolicyPhysicalPresence_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyPhysicalPresence_REQUEST

/**
* This command indicates that physical presence will need to be asserted at the time the authorization is performed.
*/
export class PolicyPhysicalPresenceResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyPhysicalPresenceResponse

/**
* This command is used to allow a policy to be bound to a specific command and command parameters.
*/
export class TPM2_PolicyCpHash_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the cpHash added to the policy
        */
        public cpHashA: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.cpHashA);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.cpHashA = buf.fromTpm2B(2);
    }
} // TPM2_PolicyCpHash_REQUEST

/**
* This command is used to allow a policy to be bound to a specific command and command parameters.
*/
export class PolicyCpHashResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyCpHashResponse

/**
* This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
*/
export class TPM2_PolicyNameHash_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the digest to be added to the policy
        */
        public nameHash: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nameHash);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.nameHash = buf.fromTpm2B(2);
    }
} // TPM2_PolicyNameHash_REQUEST

/**
* This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
*/
export class PolicyNameHashResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyNameHashResponse

/**
* This command allows qualification of duplication to allow duplication to a selected new parent.
*/
export class TPM2_PolicyDuplicationSelect_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the Name of the object to be duplicated
        */
        public objectName: Buffer = null,
        /**
        * the Name of the new parent
        */
        public newParentName: Buffer = null,
        /**
        * if YES, the objectName will be included in the value in policySessionpolicyDigest
        */
        public includeObject: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.objectName);
        buf.toTpm2B(this.newParentName);
        buf.toTpm(this.includeObject, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.objectName = buf.fromTpm2B(2);
        this.newParentName = buf.fromTpm2B(2);
        this.includeObject = buf.fromTpm(1);
    }
} // TPM2_PolicyDuplicationSelect_REQUEST

/**
* This command allows qualification of duplication to allow duplication to a selected new parent.
*/
export class PolicyDuplicationSelectResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyDuplicationSelectResponse

/**
* This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
*/
export class TPM2_PolicyAuthorize_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * digest of the policy being approved
        */
        public approvedPolicy: Buffer = null,
        /**
        * a policy qualifier
        */
        public policyRef: Buffer = null,
        /**
        * Name of a key that can sign a policy addition
        */
        public keySign: Buffer = null,
        /**
        * ticket validating that approvedPolicy and policyRef were signed by keySign
        */
        public checkTicket: TPMT_TK_VERIFIED = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.approvedPolicy);
        buf.toTpm2B(this.policyRef);
        buf.toTpm2B(this.keySign);
        this.checkTicket.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.approvedPolicy = buf.fromTpm2B(2);
        this.policyRef = buf.fromTpm2B(2);
        this.keySign = buf.fromTpm2B(2);
        this.checkTicket = buf.createFromTpm(TPMT_TK_VERIFIED);
    }
} // TPM2_PolicyAuthorize_REQUEST

/**
* This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy.
*/
export class PolicyAuthorizeResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyAuthorizeResponse

/**
* This command allows a policy to be bound to the authorization value of the authorized entity.
*/
export class TPM2_PolicyAuthValue_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyAuthValue_REQUEST

/**
* This command allows a policy to be bound to the authorization value of the authorized entity.
*/
export class PolicyAuthValueResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyAuthValueResponse

/**
* This command allows a policy to be bound to the authorization value of the authorized object.
*/
export class TPM2_PolicyPassword_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyPassword_REQUEST

/**
* This command allows a policy to be bound to the authorization value of the authorized object.
*/
export class PolicyPasswordResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyPasswordResponse

/**
* This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
*/
export class TPM2_PolicyGetDigest_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session Auth Index: None
        */
        public policySession: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyGetDigest_REQUEST

/**
* This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
*/
export class PolicyGetDigestResponse extends TpmStructure
{
    constructor(
        /**
        * the current value of the policySessionpolicyDigest
        */
        public policyDigest: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.policyDigest);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policyDigest = buf.fromTpm2B(2);
    }
} // PolicyGetDigestResponse

/**
* This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
*/
export class TPM2_PolicyNvWritten_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * YES if NV Index is required to have been written NO if NV Index is required not to have been written
        */
        public writtenSet: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.writtenSet, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.writtenSet = buf.fromTpm(1);
    }
} // TPM2_PolicyNvWritten_REQUEST

/**
* This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization.
*/
export class PolicyNvWrittenResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyNvWrittenResponse

/**
* This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
*/
export class TPM2_PolicyTemplate_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the digest to be added to the policy
        */
        public templateHash: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.templateHash);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.templateHash = buf.fromTpm2B(2);
    }
} // TPM2_PolicyTemplate_REQUEST

/**
* This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded().
*/
export class PolicyTemplateResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyTemplateResponse

/**
* This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
*/
export class TPM2_PolicyAuthorizeNV_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index of the area to read Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.policySession = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_PolicyAuthorizeNV_REQUEST

/**
* This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable.
*/
export class PolicyAuthorizeNVResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PolicyAuthorizeNVResponse

/**
* This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
*/
export class TPM2_CreatePrimary_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL Auth Index: 1 Auth Role: USER
        */
        public primaryHandle: TPM_HANDLE = null,
        /**
        * the sensitive data, see TPM 2.0 Part 1 Sensitive Values
        */
        public inSensitive: TPMS_SENSITIVE_CREATE = null,
        /**
        * the public template
        */
        public inPublic: TPMT_PUBLIC = null,
        /**
        * data that will be included in the creation data for this object to provide permanent, verifiable linkage between this object and some object owner data
        */
        public outsideInfo: Buffer = null,
        /**
        * PCR that will be used in creation data
        */
        public creationPCR: TPMS_PCR_SELECTION[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.inSensitive, 2);
        buf.sizedToTpm(this.inPublic, 2);
        buf.toTpm2B(this.outsideInfo);
        buf.arrayToTpm<TPMS_PCR_SELECTION>(this.creationPCR, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.primaryHandle = buf.createFromTpm(TPM_HANDLE);
        this.inSensitive = buf.sizedFromTpm(TPMS_SENSITIVE_CREATE, 2);
        this.inPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.outsideInfo = buf.fromTpm2B(2);
        this.creationPCR = buf.arrayFromTpm(TPMS_PCR_SELECTION, 4);
    }
} // TPM2_CreatePrimary_REQUEST

/**
* This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned.
*/
export class CreatePrimaryResponse extends TpmStructure
{
    constructor(
        /**
        * handle of type TPM_HT_TRANSIENT for created Primary Object
        */
        public handle: TPM_HANDLE = null,
        /**
        * the public portion of the created object
        */
        public outPublic: TPMT_PUBLIC = null,
        /**
        * contains a TPMT_CREATION_DATA
        */
        public creationData: TPMS_CREATION_DATA = null,
        /**
        * digest of creationData using nameAlg of outPublic
        */
        public creationHash: Buffer = null,
        /**
        * ticket used by TPM2_CertifyCreation() to validate that the creation data was produced by the TPM
        */
        public creationTicket: TPMT_TK_CREATION = null,
        /**
        * the name of the created object
        */
        public name: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        buf.sizedToTpm(this.outPublic, 2);
        buf.sizedToTpm(this.creationData, 2);
        buf.toTpm2B(this.creationHash);
        this.creationTicket.toTpm(buf);
        buf.toTpm2B(this.name);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.outPublic = buf.sizedFromTpm(TPMT_PUBLIC, 2);
        this.creationData = buf.sizedFromTpm(TPMS_CREATION_DATA, 2);
        this.creationHash = buf.fromTpm2B(2);
        this.creationTicket = buf.createFromTpm(TPMT_TK_CREATION);
        this.name = buf.fromTpm2B(2);
    }
} // CreatePrimaryResponse

/**
* This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
*/
export class TPM2_HierarchyControl_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the enable being modified TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
        */
        public enable: TPM_HANDLE = null,
        /**
        * YES if the enable should be SET, NO if the enable should be CLEAR
        */
        public state: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.enable.toTpm(buf);
        buf.toTpm(this.state, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.enable = buf.createFromTpm(TPM_HANDLE);
        this.state = buf.fromTpm(1);
    }
} // TPM2_HierarchyControl_REQUEST

/**
* This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided.
*/
export class HierarchyControlResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // HierarchyControlResponse

/**
* This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
*/
export class TPM2_SetPrimaryPolicy_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * an authorization policy digest; may be the Empty Buffer If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
        */
        public authPolicy: Buffer = null,
        /**
        * the hash algorithm to use for the policy If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
        */
        public hashAlg: TPM_ALG_ID = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.authPolicy);
        buf.toTpm(this.hashAlg, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.authPolicy = buf.fromTpm2B(2);
        this.hashAlg = buf.fromTpm(2);
    }
} // TPM2_SetPrimaryPolicy_REQUEST

/**
* This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy).
*/
export class SetPrimaryPolicyResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // SetPrimaryPolicyResponse

/**
* This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
*/
export class TPM2_ChangePPS_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_ChangePPS_REQUEST

/**
* This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer).
*/
export class ChangePPSResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ChangePPSResponse

/**
* This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
*/
export class TPM2_ChangeEPS_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_ChangeEPS_REQUEST

/**
* This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded.
*/
export class ChangeEPSResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ChangeEPSResponse

/**
* This command removes all TPM context associated with a specific Owner.
*/
export class TPM2_Clear_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_Clear_REQUEST

/**
* This command removes all TPM context associated with a specific Owner.
*/
export class ClearResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ClearResponse

/**
* TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
*/
export class TPM2_ClearControl_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public auth: TPM_HANDLE = null,
        /**
        * YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.
        */
        public disable: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.disable, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.disable = buf.fromTpm(1);
    }
} // TPM2_ClearControl_REQUEST

/**
* TPM2_ClearControl() disables and enables the execution of TPM2_Clear().
*/
export class ClearControlResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ClearControlResponse

/**
* This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
*/
export class TPM2_HierarchyChangeAuth_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * new authorization value
        */
        public newAuth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.newAuth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.newAuth = buf.fromTpm2B(2);
    }
} // TPM2_HierarchyChangeAuth_REQUEST

/**
* This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization.
*/
export class HierarchyChangeAuthResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // HierarchyChangeAuthResponse

/**
* This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
*/
export class TPM2_DictionaryAttackLockReset_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
        */
        public lockHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.lockHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_DictionaryAttackLockReset_REQUEST

/**
* This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero.
*/
export class DictionaryAttackLockResetResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // DictionaryAttackLockResetResponse

/**
* This command changes the lockout parameters.
*/
export class TPM2_DictionaryAttackParameters_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_LOCKOUT Auth Index: 1 Auth Role: USER
        */
        public lockHandle: TPM_HANDLE = null,
        /**
        * count of authorization failures before the lockout is imposed
        */
        public newMaxTries: number = 0,
        /**
        * time in seconds before the authorization failure count is automatically decremented A value of zero indicates that DA protection is disabled.
        */
        public newRecoveryTime: number = 0,
        /**
        * time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed A value of zero indicates that a reboot is required.
        */
        public lockoutRecovery: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.newMaxTries, 4);
        buf.toTpm(this.newRecoveryTime, 4);
        buf.toTpm(this.lockoutRecovery, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.lockHandle = buf.createFromTpm(TPM_HANDLE);
        this.newMaxTries = buf.fromTpm(4);
        this.newRecoveryTime = buf.fromTpm(4);
        this.lockoutRecovery = buf.fromTpm(4);
    }
} // TPM2_DictionaryAttackParameters_REQUEST

/**
* This command changes the lockout parameters.
*/
export class DictionaryAttackParametersResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // DictionaryAttackParametersResponse

/**
* This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
*/
export class TPM2_PP_Commands_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+PP Auth Index: 1 Auth Role: USER + Physical Presence
        */
        public auth: TPM_HANDLE = null,
        /**
        * list of commands to be added to those that will require that Physical Presence be asserted
        */
        public setList: TPM_CC[] = null,
        /**
        * list of commands that will no longer require that Physical Presence be asserted
        */
        public clearList: TPM_CC[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.valArrToTpm<TPM_CC>(this.setList, 4, 4);
        buf.valArrToTpm<TPM_CC>(this.clearList, 4, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.setList = buf.valArrFromTpm(4, 4);
        this.clearList = buf.valArrFromTpm(4, 4);
    }
} // TPM2_PP_Commands_REQUEST

/**
* This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy.
*/
export class PP_CommandsResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // PP_CommandsResponse

/**
* This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
*/
export class TPM2_SetAlgorithmSet_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * a TPM vendor-dependent value indicating the algorithm set selection
        */
        public algorithmSet: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.algorithmSet, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.algorithmSet = buf.fromTpm(4);
    }
} // TPM2_SetAlgorithmSet_REQUEST

/**
* This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value.
*/
export class SetAlgorithmSetResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // SetAlgorithmSetResponse

/**
* This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
*/
export class TPM2_FieldUpgradeStart_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_PLATFORM+{PP} Auth Index:1 Auth Role: ADMIN
        */
        public authorization: TPM_HANDLE = null,
        /**
        * handle of a public area that contains the TPM Vendor Authorization Key that will be used to validate manifestSignature Auth Index: None
        */
        public keyHandle: TPM_HANDLE = null,
        /**
        * digest of the first block in the field upgrade sequence
        */
        public fuDigest: Buffer = null,
        /**
        * signature over fuDigest using the key associated with keyHandle (not optional) (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public manifestSignature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.fuDigest);
        buf.toTpm(this.manifestSignature.GetUnionSelector(), 2);
        this.manifestSignature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authorization = buf.createFromTpm(TPM_HANDLE);
        this.keyHandle = buf.createFromTpm(TPM_HANDLE);
        this.fuDigest = buf.fromTpm2B(2);
        let manifestSignatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.manifestSignature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', manifestSignatureSigAlg);
        this.manifestSignature.fromTpm(buf);
    }
} // TPM2_FieldUpgradeStart_REQUEST

/**
* This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest.
*/
export class FieldUpgradeStartResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // FieldUpgradeStartResponse

/**
* This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
*/
export class TPM2_FieldUpgradeData_REQUEST extends TpmStructure
{
    constructor(
        /**
        * field upgrade image data
        */
        public fuData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.fuData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.fuData = buf.fromTpm2B(2);
    }
} // TPM2_FieldUpgradeData_REQUEST

/**
* This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
*/
export class FieldUpgradeDataResponse extends TpmStructure
{
    constructor(
        /**
        * tagged digest of the next block TPM_ALG_NULL if field update is complete
        */
        public nextDigest: TPMT_HA = null,
        /**
        * tagged digest of the first block of the sequence
        */
        public firstDigest: TPMT_HA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.nextDigest.toTpm(buf);
        this.firstDigest.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nextDigest = buf.createFromTpm(TPMT_HA);
        this.firstDigest = buf.createFromTpm(TPMT_HA);
    }
} // FieldUpgradeDataResponse

/**
* This command is used to read a copy of the current firmware installed in the TPM.
*/
export class TPM2_FirmwareRead_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the number of previous calls to this command in this sequence set to 0 on the first call
        */
        public sequenceNumber: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.sequenceNumber, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sequenceNumber = buf.fromTpm(4);
    }
} // TPM2_FirmwareRead_REQUEST

/**
* This command is used to read a copy of the current firmware installed in the TPM.
*/
export class FirmwareReadResponse extends TpmStructure
{
    constructor(
        /**
        * field upgrade image data
        */
        public fuData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.fuData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.fuData = buf.fromTpm2B(2);
    }
} // FirmwareReadResponse

/**
* This command saves a session context, object context, or sequence object context outside the TPM.
*/
export class TPM2_ContextSave_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the resource to save Auth Index: None
        */
        public saveHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.saveHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_ContextSave_REQUEST

/**
* This command saves a session context, object context, or sequence object context outside the TPM.
*/
export class ContextSaveResponse extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public context: TPMS_CONTEXT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.context.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.context = buf.createFromTpm(TPMS_CONTEXT);
    }
} // ContextSaveResponse

/**
* This command is used to reload a context that has been saved by TPM2_ContextSave().
*/
export class TPM2_ContextLoad_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the context blob
        */
        public context: TPMS_CONTEXT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.context.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.context = buf.createFromTpm(TPMS_CONTEXT);
    }
} // TPM2_ContextLoad_REQUEST

/**
* This command is used to reload a context that has been saved by TPM2_ContextSave().
*/
export class ContextLoadResponse extends TpmStructure
{
    constructor(
        /**
        * the handle assigned to the resource after it has been successfully loaded
        */
        public handle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
    }
} // ContextLoadResponse

/**
* This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
*/
export class TPM2_FlushContext_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the handle of the item to flush NOTE This is a use of a handle as a parameter.
        */
        public flushHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.flushHandle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.flushHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_FlushContext_REQUEST

/**
* This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory.
*/
export class FlushContextResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // FlushContextResponse

/**
* This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
*/
export class TPM2_EvictControl_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public auth: TPM_HANDLE = null,
        /**
        * the handle of a loaded object Auth Index: None
        */
        public objectHandle: TPM_HANDLE = null,
        /**
        * if objectHandle is a transient object handle, then this is the persistent handle for the object if objectHandle is a persistent object handle, then it shall be the same value as persistentHandle
        */
        public persistentHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.persistentHandle.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.objectHandle = buf.createFromTpm(TPM_HANDLE);
        this.persistentHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_EvictControl_REQUEST

/**
* This command allows certain Transient Objects to be made persistent or a persistent object to be evicted.
*/
export class EvictControlResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // EvictControlResponse

/**
* This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
*/
export class TPM2_ReadClock_REQUEST extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // TPM2_ReadClock_REQUEST

/**
* This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount.
*/
export class ReadClockResponse extends TpmStructure
{
    constructor(
        /**
        * -
        */
        public currentTime: TPMS_TIME_INFO = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.currentTime.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.currentTime = buf.createFromTpm(TPMS_TIME_INFO);
    }
} // ReadClockResponse

/**
* This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
*/
export class TPM2_ClockSet_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public auth: TPM_HANDLE = null,
        /**
        * new Clock setting in milliseconds
        */
        public newTime: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.newTime, 8);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.newTime = buf.fromTpm(8);
    }
} // TPM2_ClockSet_REQUEST

/**
* This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
*/
export class ClockSetResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ClockSetResponse

/**
* This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
*/
export class TPM2_ClockRateAdjust_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Handle: 1 Auth Role: USER
        */
        public auth: TPM_HANDLE = null,
        /**
        * Adjustment to current Clock update rate
        */
        public rateAdjust: TPM_CLOCK_ADJUST = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.rateAdjust, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.auth = buf.createFromTpm(TPM_HANDLE);
        this.rateAdjust = buf.fromTpm(1);
    }
} // TPM2_ClockRateAdjust_REQUEST

/**
* This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time.
*/
export class ClockRateAdjustResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // ClockRateAdjustResponse

/**
* This command returns various information regarding the TPM and its current state.
*/
export class TPM2_GetCapability_REQUEST extends TpmStructure
{
    constructor(
        /**
        * group selection; determines the format of the response
        */
        public capability: TPM_CAP = 0,
        /**
        * further definition of information
        */
        public property: number = 0,
        /**
        * number of properties of the indicated type to return
        */
        public propertyCount: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.capability, 4);
        buf.toTpm(this.property, 4);
        buf.toTpm(this.propertyCount, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.capability = buf.fromTpm(4);
        this.property = buf.fromTpm(4);
        this.propertyCount = buf.fromTpm(4);
    }
} // TPM2_GetCapability_REQUEST

/**
* This command returns various information regarding the TPM and its current state.
*/
export class GetCapabilityResponse extends TpmStructure
{
    constructor(
        /**
        * flag to indicate if there are more values of this type
        */
        public moreData: number = 0,
        /**
        * the capability data (One of TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_CC, TPML_PCR_SELECTION, TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE, TPML_TAGGED_POLICY)
        */
        public capabilityData: TPMU_CAPABILITIES = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.moreData, 1);
        buf.toTpm(this.capabilityData.GetUnionSelector(), 4);
        this.capabilityData.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.moreData = buf.fromTpm(1);
        let capabilityDataCapability: TPM_CAP = buf.fromTpm(4);
        this.capabilityData = createUnion<TPMU_CAPABILITIES>('TPMU_CAPABILITIES', capabilityDataCapability);
        this.capabilityData.fromTpm(buf);
    }
} // GetCapabilityResponse

/**
* This command is used to check to see if specific combinations of algorithm parameters are supported.
*/
export class TPM2_TestParms_REQUEST extends TpmStructure
{
    constructor(
        /**
        * algorithm parameters to be validated (One of TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS, TPMS_ASYM_PARMS)
        */
        public parameters: TPMU_PUBLIC_PARMS = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.parameters.GetUnionSelector(), 2);
        this.parameters.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        let parametersType: TPM_ALG_ID = buf.fromTpm(2);
        this.parameters = createUnion<TPMU_PUBLIC_PARMS>('TPMU_PUBLIC_PARMS', parametersType);
        this.parameters.fromTpm(buf);
    }
} // TPM2_TestParms_REQUEST

/**
* This command is used to check to see if specific combinations of algorithm parameters are supported.
*/
export class TestParmsResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // TestParmsResponse

/**
* This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
*/
export class TPM2_NV_DefineSpace_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the authorization value
        */
        public auth: Buffer = null,
        /**
        * the public parameters of the NV area
        */
        public publicInfo: TPMS_NV_PUBLIC = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.auth);
        buf.sizedToTpm(this.publicInfo, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.auth = buf.fromTpm2B(2);
        this.publicInfo = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2);
    }
} // TPM2_NV_DefineSpace_REQUEST

/**
* This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED.
*/
export class NV_DefineSpaceResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_DefineSpaceResponse

/**
* This command removes an Index from the TPM.
*/
export class TPM2_NV_UndefineSpace_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index to remove from NV space Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_UndefineSpace_REQUEST

/**
* This command removes an Index from the TPM.
*/
export class NV_UndefineSpaceResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_UndefineSpaceResponse

/**
* This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
*/
export class TPM2_NV_UndefineSpaceSpecial_REQUEST extends TpmStructure
{
    constructor(
        /**
        * Index to be deleted Auth Index: 1 Auth Role: ADMIN
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * TPM_RH_PLATFORM + {PP} Auth Index: 2 Auth Role: USER
        */
        public platform: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.platform = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_UndefineSpaceSpecial_REQUEST

/**
* This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET.
*/
export class NV_UndefineSpaceSpecialResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_UndefineSpaceSpecialResponse

/**
* This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
*/
export class TPM2_NV_ReadPublic_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the NV Index Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_ReadPublic_REQUEST

/**
* This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data.
*/
export class NV_ReadPublicResponse extends TpmStructure
{
    constructor(
        /**
        * the public area of the NV Index
        */
        public nvPublic: TPMS_NV_PUBLIC = null,
        /**
        * the Name of the nvIndex
        */
        public nvName: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.nvPublic, 2);
        buf.toTpm2B(this.nvName);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvPublic = buf.sizedFromTpm(TPMS_NV_PUBLIC, 2);
        this.nvName = buf.fromTpm2B(2);
    }
} // NV_ReadPublicResponse

/**
* This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
*/
export class TPM2_NV_Write_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index of the area to write Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * the data to write
        */
        public data: Buffer = null,
        /**
        * the octet offset into the NV Area
        */
        public offset: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.data);
        buf.toTpm(this.offset, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.data = buf.fromTpm2B(2);
        this.offset = buf.fromTpm(2);
    }
} // TPM2_NV_Write_REQUEST

/**
* This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace().
*/
export class NV_WriteResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_WriteResponse

/**
* This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
*/
export class TPM2_NV_Increment_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index to increment Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_Increment_REQUEST

/**
* This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one.
*/
export class NV_IncrementResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_IncrementResponse

/**
* This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
*/
export class TPM2_NV_Extend_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index to extend Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * the data to extend
        */
        public data: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.data);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.data = buf.fromTpm2B(2);
    }
} // TPM2_NV_Extend_REQUEST

/**
* This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace.
*/
export class NV_ExtendResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_ExtendResponse

/**
* This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
*/
export class TPM2_NV_SetBits_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * NV Index of the area in which the bit is to be set Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * the data to OR with the current contents
        */
        public bits: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.bits, 8);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.bits = buf.fromTpm(8);
    }
} // TPM2_NV_SetBits_REQUEST

/**
* This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index.
*/
export class NV_SetBitsResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_SetBitsResponse

/**
* If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
*/
export class TPM2_NV_WriteLock_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index of the area to lock Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_WriteLock_REQUEST

/**
* If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index.
*/
export class NV_WriteLockResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_WriteLockResponse

/**
* The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
*/
export class TPM2_NV_GlobalWriteLock_REQUEST extends TpmStructure
{
    constructor(
        /**
        * TPM_RH_OWNER or TPM_RH_PLATFORM+{PP} Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_GlobalWriteLock_REQUEST

/**
* The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET.
*/
export class NV_GlobalWriteLockResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_GlobalWriteLockResponse

/**
* This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
*/
export class TPM2_NV_Read_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index to be read Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * number of octets to read
        */
        public size: number = 0,
        /**
        * octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.
        */
        public offset: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.size, 2);
        buf.toTpm(this.offset, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.size = buf.fromTpm(2);
        this.offset = buf.fromTpm(2);
    }
} // TPM2_NV_Read_REQUEST

/**
* This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().
*/
export class NV_ReadResponse extends TpmStructure
{
    constructor(
        /**
        * the data read
        */
        public data: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.data);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.data = buf.fromTpm2B(2);
    }
} // NV_ReadResponse

/**
* If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
*/
export class TPM2_NV_ReadLock_REQUEST extends TpmStructure
{
    constructor(
        /**
        * the handle indicating the source of the authorization value Auth Index: 1 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * the NV Index to be locked Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
    }
} // TPM2_NV_ReadLock_REQUEST

/**
* If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
*/
export class NV_ReadLockResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_ReadLockResponse

/**
* This command allows the authorization secret for an NV Index to be changed.
*/
export class TPM2_NV_ChangeAuth_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the entity Auth Index: 1 Auth Role: ADMIN
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * new authorization value
        */
        public newAuth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.newAuth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.newAuth = buf.fromTpm2B(2);
    }
} // TPM2_NV_ChangeAuth_REQUEST

/**
* This command allows the authorization secret for an NV Index to be changed.
*/
export class NV_ChangeAuthResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // NV_ChangeAuthResponse

/**
* The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
*/
export class TPM2_NV_Certify_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the key used to sign the attestation structure Auth Index: 1 Auth Role: USER
        */
        public signHandle: TPM_HANDLE = null,
        /**
        * handle indicating the source of the authorization value for the NV Index Auth Index: 2 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * Index for the area to be certified Auth Index: None
        */
        public nvIndex: TPM_HANDLE = null,
        /**
        * user-provided qualifying data
        */
        public qualifyingData: Buffer = null,
        /**
        * signing scheme to use if the scheme for signHandle is TPM_ALG_NULL (One of TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME)
        */
        public inScheme: TPMU_SIG_SCHEME = null,
        /**
        * number of octets to certify
        */
        public size: number = 0,
        /**
        * octet offset into the NV area This value shall be less than or equal to the size of the nvIndex data.
        */
        public offset: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.qualifyingData);
        buf.toTpm(this.inScheme.GetUnionSelector(), 2);
        this.inScheme.toTpm(buf);
        buf.toTpm(this.size, 2);
        buf.toTpm(this.offset, 2);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.signHandle = buf.createFromTpm(TPM_HANDLE);
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.nvIndex = buf.createFromTpm(TPM_HANDLE);
        this.qualifyingData = buf.fromTpm2B(2);
        let inSchemeScheme: TPM_ALG_ID = buf.fromTpm(2);
        this.inScheme = createUnion<TPMU_SIG_SCHEME>('TPMU_SIG_SCHEME', inSchemeScheme);
        this.inScheme.fromTpm(buf);
        this.size = buf.fromTpm(2);
        this.offset = buf.fromTpm(2);
    }
} // TPM2_NV_Certify_REQUEST

/**
* The purpose of this command is to certify the contents of an NV Index or portion of an NV Index.
*/
export class NV_CertifyResponse extends TpmStructure
{
    constructor(
        /**
        * the structure that was signed
        */
        public certifyInfo: TPMS_ATTEST = null,
        /**
        * the asymmetric signature over certifyInfo using the key referenced by signHandle (One of TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA, TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TpmHash, TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE)
        */
        public signature: TPMU_SIGNATURE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.sizedToTpm(this.certifyInfo, 2);
        buf.toTpm(this.signature.GetUnionSelector(), 2);
        this.signature.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.certifyInfo = buf.sizedFromTpm(TPMS_ATTEST, 2);
        let signatureSigAlg: TPM_ALG_ID = buf.fromTpm(2);
        this.signature = createUnion<TPMU_SIGNATURE>('TPMU_SIGNATURE', signatureSigAlg);
        this.signature.fromTpm(buf);
    }
} // NV_CertifyResponse

/**
* The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
*/
export class TPM2_AC_GetCapability_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle indicating the Attached Component Auth Index: None
        */
        public ac: TPM_HANDLE = null,
        /**
        * starting info type
        */
        public capability: TPM_AT = 0,
        /**
        * maximum number of values to return
        */
        public count: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.capability, 4);
        buf.toTpm(this.count, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.ac = buf.createFromTpm(TPM_HANDLE);
        this.capability = buf.fromTpm(4);
        this.count = buf.fromTpm(4);
    }
} // TPM2_AC_GetCapability_REQUEST

/**
* The purpose of this command is to obtain information about an Attached Component referenced by an AC handle.
*/
export class AC_GetCapabilityResponse extends TpmStructure
{
    constructor(
        /**
        * flag to indicate whether there are more values
        */
        public moreData: number = 0,
        /**
        * list of capabilities
        */
        public capabilitiesData: TPMS_AC_OUTPUT[] = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.moreData, 1);
        buf.arrayToTpm<TPMS_AC_OUTPUT>(this.capabilitiesData, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.moreData = buf.fromTpm(1);
        this.capabilitiesData = buf.arrayFromTpm(TPMS_AC_OUTPUT, 4);
    }
} // AC_GetCapabilityResponse

/**
* The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
*/
export class TPM2_AC_Send_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle of the object being sent to ac Auth Index: 1 Auth Role: DUP
        */
        public sendObject: TPM_HANDLE = null,
        /**
        * the handle indicating the source of the authorization value Auth Index: 2 Auth Role: USER
        */
        public authHandle: TPM_HANDLE = null,
        /**
        * handle indicating the Attached Component to which the object will be sent Auth Index: None
        */
        public ac: TPM_HANDLE = null,
        /**
        * Optional non sensitive information related to the object
        */
        public acDataIn: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.acDataIn);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.sendObject = buf.createFromTpm(TPM_HANDLE);
        this.authHandle = buf.createFromTpm(TPM_HANDLE);
        this.ac = buf.createFromTpm(TPM_HANDLE);
        this.acDataIn = buf.fromTpm2B(2);
    }
} // TPM2_AC_Send_REQUEST

/**
* The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component.
*/
export class AC_SendResponse extends TpmStructure
{
    constructor(
        /**
        * May include AC specific data or information about an error.
        */
        public acDataOut: TPMS_AC_OUTPUT = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.acDataOut.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.acDataOut = buf.createFromTpm(TPMS_AC_OUTPUT);
    }
} // AC_SendResponse

/**
* This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
*/
export class TPM2_Policy_AC_SendSelect_REQUEST extends TpmStructure
{
    constructor(
        /**
        * handle for the policy session being extended Auth Index: None
        */
        public policySession: TPM_HANDLE = null,
        /**
        * the Name of the Object to be sent
        */
        public objectName: Buffer = null,
        /**
        * the Name associated with authHandle used in the TPM2_AC_Send() command
        */
        public authHandleName: Buffer = null,
        /**
        * the Name of the Attached Component to which the Object will be sent
        */
        public acName: Buffer = null,
        /**
        * if SET, objectName will be included in the value in policySessionpolicyDigest
        */
        public includeObject: number = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.objectName);
        buf.toTpm2B(this.authHandleName);
        buf.toTpm2B(this.acName);
        buf.toTpm(this.includeObject, 1);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.policySession = buf.createFromTpm(TPM_HANDLE);
        this.objectName = buf.fromTpm2B(2);
        this.authHandleName = buf.fromTpm2B(2);
        this.acName = buf.fromTpm2B(2);
        this.includeObject = buf.fromTpm(1);
    }
} // TPM2_Policy_AC_SendSelect_REQUEST

/**
* This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified.
*/
export class Policy_AC_SendSelectResponse extends TpmStructure
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
    }
} // Policy_AC_SendSelectResponse

/**
* This is a placeholder to allow testing of the dispatch code.
*/
export class TPM2_Vendor_TCG_Test_REQUEST extends TpmStructure
{
    constructor(
        /**
        * dummy data
        */
        public inputData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.inputData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.inputData = buf.fromTpm2B(2);
    }
} // TPM2_Vendor_TCG_Test_REQUEST

/**
* This is a placeholder to allow testing of the dispatch code.
*/
export class Vendor_TCG_TestResponse extends TpmStructure
{
    constructor(
        /**
        * dummy data
        */
        public outputData: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.outputData);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.outputData = buf.fromTpm2B(2);
    }
} // Vendor_TCG_TestResponse

/**
* Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
*/
export class TPMS_SCHEME_RSASSA extends TPMS_SIG_SCHEME_RSASSA
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_RSASSA

/**
* Underlying type comment: These are the RSA schemes that only need a hash algorithm as a scheme parameter.
*/
export class TPMS_SCHEME_RSAPSS extends TPMS_SIG_SCHEME_RSAPSS
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_RSAPSS

/**
* Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SCHEME_ECDSA extends TPMS_SIG_SCHEME_ECDSA
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_ECDSA

/**
* Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SCHEME_SM2 extends TPMS_SIG_SCHEME_SM2
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_SM2

/**
* Underlying type comment: Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA.
*/
export class TPMS_SCHEME_ECSCHNORR extends TPMS_SIG_SCHEME_ECSCHNORR
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_ECSCHNORR

/**
* Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_SCHEME_OAEP extends TPMS_ENC_SCHEME_OAEP
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_OAEP

/**
* Underlying type comment: These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_SCHEME_RSAES extends TPMS_ENC_SCHEME_RSAES
{
    constructor(
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_RSAES

/**
* Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_SCHEME_ECDH extends TPMS_KEY_SCHEME_ECDH
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_ECDH

/**
* Underlying type comment: These are the ECC schemes that only need a hash algorithm as a controlling parameter.
*/
export class TPMS_SCHEME_ECMQV extends TPMS_KEY_SCHEME_ECMQV
{
    constructor(
        /**
        * the hash algorithm used to digest the message
        */
        hashAlg: TPM_ALG_ID = 0
    ) { super(hashAlg); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPMS_SCHEME_ECMQV

/**
* Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object)
*/
export class TssObject extends TpmStructure
{
    constructor(
        /**
        * Public part of key
        */
        public Public: TPMT_PUBLIC = null,
        /**
        * Sensitive part of key
        */
        public Sensitive: TPMT_SENSITIVE = null,
        /**
        * Private part is the encrypted sensitive part of key
        */
        public Private: TPM2B_PRIVATE = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.Public.toTpm(buf);
        this.Sensitive.toTpm(buf);
        this.Private.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.Public = buf.createFromTpm(TPMT_PUBLIC);
        this.Sensitive = buf.createFromTpm(TPMT_SENSITIVE);
        this.Private = buf.createFromTpm(TPM2B_PRIVATE);
    }
} // TssObject

/**
* Contains a PCR index and associated hash(pcr-value) [TSS]
*/
export class PcrValue extends TpmStructure
{
    constructor(
        /**
        * PCR Index
        */
        public index: number = 0,
        /**
        * PCR Value
        */
        public value: TPMT_HA = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.index, 4);
        this.value.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.index = buf.fromTpm(4);
        this.value = buf.createFromTpm(TPMT_HA);
    }
} // PcrValue

/**
* Structure representing a session block in a command buffer [TSS]
*/
export class SessionIn extends TpmStructure
{
    constructor(
        /**
        * Session handle
        */
        public handle: TPM_HANDLE = null,
        /**
        * Caller nonce
        */
        public nonceCaller: Buffer = null,
        /**
        * Session attributes
        */
        public attributes: TPMA_SESSION = 0,
        /**
        * AuthValue (or HMAC)
        */
        public auth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.handle.toTpm(buf);
        buf.toTpm2B(this.nonceCaller);
        buf.toTpm(this.attributes, 1);
        buf.toTpm2B(this.auth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.handle = buf.createFromTpm(TPM_HANDLE);
        this.nonceCaller = buf.fromTpm2B(2);
        this.attributes = buf.fromTpm(1);
        this.auth = buf.fromTpm2B(2);
    }
} // SessionIn

/**
* Structure representing a session block in a response buffer [TSS]
*/
export class SessionOut extends TpmStructure
{
    constructor(
        /**
        * TPM nonce
        */
        public nonceTpm: Buffer = null,
        /**
        * Session attributes
        */
        public attributes: TPMA_SESSION = 0,
        /**
        * HMAC value
        */
        public auth: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm2B(this.nonceTpm);
        buf.toTpm(this.attributes, 1);
        buf.toTpm2B(this.auth);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.nonceTpm = buf.fromTpm2B(2);
        this.attributes = buf.fromTpm(1);
        this.auth = buf.fromTpm2B(2);
    }
} // SessionOut

/**
* Command header [TSS]
*/
export class CommandHeader extends TpmStructure
{
    constructor(
        /**
        * Command tag (sessions, or no sessions)
        */
        public Tag: TPM_ST = 0,
        /**
        * Total command buffer length
        */
        public CommandSize: number = 0,
        /**
        * Command code
        */
        public CommandCode: TPM_CC = 0
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        buf.toTpm(this.Tag, 2);
        buf.toTpm(this.CommandSize, 4);
        buf.toTpm(this.CommandCode, 4);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.Tag = buf.fromTpm(2);
        this.CommandSize = buf.fromTpm(4);
        this.CommandCode = buf.fromTpm(4);
    }
} // CommandHeader

/**
* Contains the public and private part of a TPM key
*/
export class TSS_KEY extends TpmStructure
{
    constructor(
        /**
        * Public part of key
        */
        public publicPart: TPMT_PUBLIC = null,
        /**
        * Private part is the encrypted sensitive part of key
        */
        public privatePart: Buffer = null
    ) { super(); }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        this.publicPart.toTpm(buf);
        buf.toTpm2B(this.privatePart);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        this.publicPart = buf.createFromTpm(TPMT_PUBLIC);
        this.privatePart = buf.fromTpm2B(2);
    }
} // TSS_KEY

/**
* Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation
*/
export class TPM2B_DIGEST_Symcipher extends TPM2B_DIGEST implements TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        buffer: Buffer = null
    ) { super(buffer); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.SYMCIPHER;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPM2B_DIGEST_Symcipher

/**
* Auto-derived from TPM2B_DIGEST
*/
export class TPM2B_DIGEST_Keyedhash extends TPM2B_DIGEST implements TPMU_PUBLIC_ID 
{
    constructor(
        /**
        * the buffer area that can be no larger than a digest
        */
        buffer: Buffer = null
    ) { super(buffer); }
    
    /** TpmUnion method */
    GetUnionSelector(): TPM_ALG_ID
    {
        return TPM_ALG_ID.KEYEDHASH;
    }
    
    /** TpmMarshaller method */
    toTpm(buf: TpmBuffer) : void
    {
        super.toTpm(buf);
    }
    
    /** TpmMarshaller method */
    fromTpm(buf: TpmBuffer) : void
    {
        super.fromTpm(buf);
    }
} // TPM2B_DIGEST_Keyedhash

